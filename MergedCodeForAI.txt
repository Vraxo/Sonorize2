<file path="App.cs">
using Avalonia;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Markup.Xaml.Styling;
using Avalonia.Styling;
using Sonorize.ViewModels;
using Sonorize.Views;
using Sonorize.Services;
using Sonorize.Models;
using Avalonia.Themes.Fluent;
using Avalonia.Media;
using System.Diagnostics;

namespace Sonorize;

public class App : Application
{
    public override void Initialize()
    {
        // Delay adding FluentTheme until OnFrameworkInitializationCompleted
    }

    public override void OnFrameworkInitializationCompleted()
    {
        if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
        {
            var settingsService = new SettingsService();
            var appSettings = settingsService.LoadSettings();

            var themeService = new ThemeService(appSettings.PreferredThemeFileName);
            ThemeColors currentCustomTheme = themeService.CurrentTheme;

            var fluentTheme = new FluentTheme();
            Styles.Add(fluentTheme);
            RequestedThemeVariant = ThemeVariant.Dark;
            Debug.WriteLine($"[App] RequestedThemeVariant set to: {RequestedThemeVariant}");

            if (currentCustomTheme.B_AccentColor is ISolidColorBrush accentSolidBrush &&
                currentCustomTheme.B_AccentForeground is ISolidColorBrush accentForegroundSolidBrush)
            {
                Color accentColor = accentSolidBrush.Color;
                Color accentForegroundColor = accentForegroundSolidBrush.Color;
                Debug.WriteLine($"[App] Overriding FluentTheme accent resources. Accent: {accentColor}, AccentFG: {accentForegroundColor}");
                Resources["SystemAccentColor"] = accentColor;
                Resources["SystemAccentColorLight1"] = accentColor.ChangeLightness(0.15);
                Resources["SystemAccentColorLight2"] = accentColor.ChangeLightness(0.30);
                Resources["SystemAccentColorLight3"] = accentColor.ChangeLightness(0.45);
                Resources["SystemAccentColorDark1"] = accentColor.ChangeLightness(-0.15);
                Resources["SystemAccentColorDark2"] = accentColor.ChangeLightness(-0.30);
                Resources["SystemAccentColorDark3"] = accentColor.ChangeLightness(-0.45);
                Resources["AccentFillColorDefaultBrush"] = new SolidColorBrush(accentColor);
                Resources["AccentFillColorSecondaryBrush"] = new SolidColorBrush(accentColor.ChangeLightness(0.15).WithAlpha(204));
                Resources["AccentFillColorTertiaryBrush"] = new SolidColorBrush(accentColor.ChangeLightness(0.30).WithAlpha(153));
                Resources["AccentFillColorDisabledBrush"] = new SolidColorBrush(accentColor.WithAlpha(51));
                Resources["AccentFillColorSelectedTextBackgroundBrush"] = new SolidColorBrush(accentColor);
                Resources["TextOnAccentFillColorPrimaryBrush"] = new SolidColorBrush(accentForegroundColor);
                Resources["TextOnAccentFillColorSecondaryBrush"] = new SolidColorBrush(accentForegroundColor.WithAlpha(178));
                Resources["TextOnAccentFillColorDisabledBrush"] = new SolidColorBrush(accentForegroundColor.WithAlpha(127));
                Resources["AccentControlBackgroundBrush"] = new SolidColorBrush(accentColor);
            }
            else
            {
                Debug.WriteLine("[App] Warning: Custom theme AccentColor or AccentForeground is not a SolidColorBrush. Cannot fully override Fluent accent system.");
            }

            var playbackService = new PlaybackService();
            var loopDataService = new LoopDataService();
            var musicLibraryService = new MusicLibraryService(loopDataService);
            var waveformService = new WaveformService();

            var mainWindowViewModel = new MainWindowViewModel(
                settingsService,
                musicLibraryService,
                playbackService,
                currentCustomTheme,
                waveformService,
                loopDataService);

            desktop.MainWindow = new MainWindow(currentCustomTheme)
            {
                DataContext = mainWindowViewModel
            };

            mainWindowViewModel.LoadInitialDataCommand.Execute(null);
        }

        base.OnFrameworkInitializationCompleted();
    }
}

public static class ColorManipulationExtensions
{
    public static Color WithAlpha(this Color color, byte alpha)
    {
        return new Color(alpha, color.R, color.G, color.B);
    }
}

public static class ColorExtensions
{
    public static Color ChangeLightness(this Color color, double factor)
    {
        var hsl = color.ToHsl();
        double newL = System.Math.Clamp(hsl.L + factor, 0.0, 1.0);
        return HslColor.FromAhsl(hsl.A, hsl.H, hsl.S, newL).ToRgb();
    }
}
</file>

<file path="Program.cs">
using Avalonia;
using System;
using NAudio.MediaFoundation; // Required for MediaFoundationApi

namespace Sonorize;

class Program
{
    // Initialization code. Don't use any Avalonia, third-party APIs or any
    // SynchronizationContext-reliant code before AppMain is called: things aren't initialized
    // yet and stuff might break.
    [STAThread]
    public static void Main(string[] args)
    {
        // Initialize Media Foundation
        try
        {
            MediaFoundationApi.Startup();
            Console.WriteLine("[Program] MediaFoundationApi.Startup() called successfully.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[Program] CRITICAL ERROR: MediaFoundationApi.Startup() failed: {ex.Message}");
            // Optionally, prevent the app from starting or notify the user,
            // as MF features will likely not work.
        }

        try
        {
            BuildAvaloniaApp().StartWithClassicDesktopLifetime(args);
        }
        finally
        {
            // Shutdown Media Foundation
            try
            {
                MediaFoundationApi.Shutdown();
                Console.WriteLine("[Program] MediaFoundationApi.Shutdown() called successfully.");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[Program] ERROR: MediaFoundationApi.Shutdown() failed: {ex.Message}");
            }
        }
    }

    // Avalonia configuration, don't remove; also used by visual designer.
    public static AppBuilder BuildAvaloniaApp()
        => AppBuilder.Configure<App>()
            .UsePlatformDetect()
            .LogToTrace();
}
</file>

<file path="Source\Controls\WaveformDisplayControl.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Media;
using Avalonia.Input;
using System;
using System.Collections.Generic;
using System.Linq; // Required for Enumerable.Empty
using Sonorize.Models; // For LoopRegion
using Sonorize.Services; // For WaveformPoint

namespace Sonorize.Controls;

public class WaveformDisplayControl : Control
{
    // Background Property
    public static readonly StyledProperty<IBrush?> BackgroundProperty =
        Border.BackgroundProperty.AddOwner<WaveformDisplayControl>();

    public IBrush? Background
    {
        get => GetValue(BackgroundProperty);
        set => SetValue(BackgroundProperty, value);
    }

    // Corrected to use IEnumerable<WaveformPoint>
    public static readonly StyledProperty<IEnumerable<WaveformPoint>> WaveformPointsProperty =
        AvaloniaProperty.Register<WaveformDisplayControl, IEnumerable<WaveformPoint>>(
            nameof(WaveformPoints),
            defaultValue: Enumerable.Empty<WaveformPoint>()); // Default to an empty enumerable

    public IEnumerable<WaveformPoint> WaveformPoints
    {
        get => GetValue(WaveformPointsProperty);
        set => SetValue(WaveformPointsProperty, value);
    }

    public static readonly StyledProperty<TimeSpan> CurrentPositionProperty =
        AvaloniaProperty.Register<WaveformDisplayControl, TimeSpan>(nameof(CurrentPosition));

    public TimeSpan CurrentPosition
    {
        get => GetValue(CurrentPositionProperty);
        set => SetValue(CurrentPositionProperty, value);
    }

    public static readonly StyledProperty<TimeSpan> DurationProperty =
        AvaloniaProperty.Register<WaveformDisplayControl, TimeSpan>(nameof(Duration), TimeSpan.FromSeconds(1));

    public TimeSpan Duration
    {
        get => GetValue(DurationProperty);
        set => SetValue(DurationProperty, value);
    }

    public static readonly StyledProperty<LoopRegion?> ActiveLoopProperty =
        AvaloniaProperty.Register<WaveformDisplayControl, LoopRegion?>(nameof(ActiveLoop));

    public LoopRegion? ActiveLoop
    {
        get => GetValue(ActiveLoopProperty);
        set => SetValue(ActiveLoopProperty, value);
    }

    public static readonly StyledProperty<IBrush> WaveformBrushProperty =
        AvaloniaProperty.Register<WaveformDisplayControl, IBrush>(nameof(WaveformBrush), Brushes.DodgerBlue);
    public IBrush WaveformBrush { get => GetValue(WaveformBrushProperty); set => SetValue(WaveformBrushProperty, value); }

    public static readonly StyledProperty<IBrush> PositionMarkerBrushProperty =
        AvaloniaProperty.Register<WaveformDisplayControl, IBrush>(nameof(PositionMarkerBrush), Brushes.Red);
    public IBrush PositionMarkerBrush { get => GetValue(PositionMarkerBrushProperty); set => SetValue(PositionMarkerBrushProperty, value); }

    public static readonly StyledProperty<IBrush> LoopRegionBrushProperty =
        AvaloniaProperty.Register<WaveformDisplayControl, IBrush>(nameof(LoopRegionBrush), new SolidColorBrush(Colors.Orange, 0.3));
    public IBrush LoopRegionBrush { get => GetValue(LoopRegionBrushProperty); set => SetValue(LoopRegionBrushProperty, value); }


    public event EventHandler<TimeSpan>? SeekRequested;

    static WaveformDisplayControl()
    {
        AffectsRender<WaveformDisplayControl>(BackgroundProperty, WaveformPointsProperty, CurrentPositionProperty, DurationProperty, ActiveLoopProperty, WaveformBrushProperty, PositionMarkerBrushProperty, LoopRegionBrushProperty);
    }

    public WaveformDisplayControl()
    {
        ClipToBounds = true;
    }

    protected override void OnPointerPressed(PointerPressedEventArgs e)
    {
        base.OnPointerPressed(e);
        if (Duration.TotalSeconds > 0 && e.GetCurrentPoint(this).Properties.IsLeftButtonPressed)
        {
            var position = e.GetPosition(this);
            var relativeX = position.X / Bounds.Width;
            var seekTime = TimeSpan.FromSeconds(relativeX * Duration.TotalSeconds);
            SeekRequested?.Invoke(this, seekTime);
        }
    }

    public override void Render(DrawingContext context)
    {
        base.Render(context);
        var width = Bounds.Width;
        var height = Bounds.Height;

        if (width <= 0 || height <= 0) return;

        // Draw Background
        if (Background != null)
        {
            context.FillRectangle(Background, Bounds);
        }

        var waveformPen = new Pen(WaveformBrush, 1);
        var positionPen = new Pen(PositionMarkerBrush, 1.5);

        // WaveformPoints is now IEnumerable<WaveformPoint>
        if (WaveformPoints != null && WaveformPoints.Any()) // Use .Any() for IEnumerable
        {
            // If we need Count or indexed access, we might need to ToList() it here,
            // but for simple iteration, this is fine.
            // For performance with potentially large IEnumerable, if Count is needed multiple times,
            // convert to List once.
            var pointsList = WaveformPoints as List<WaveformPoint> ?? WaveformPoints.ToList();
            if (pointsList.Count > 1)
            {
                for (int i = 0; i < pointsList.Count; i++)
                {
                    var point = pointsList[i];
                    var x = point.X * width;
                    var yPeakValue = point.YPeak * (height / 2);
                    context.DrawLine(waveformPen, new Point(x, height / 2 - yPeakValue), new Point(x, height / 2 + yPeakValue));
                }
            }
            else if (pointsList.Count == 1) // Draw a small vertical line for a single point
            {
                var point = pointsList[0];
                var x = point.X * width;
                var yPeakValue = point.YPeak * (height / 2);
                context.DrawLine(waveformPen, new Point(x, height / 2 - yPeakValue), new Point(x, height / 2 + yPeakValue));
            }
            else // No points but not null (e.g., empty collection)
            {
                context.DrawLine(waveformPen, new Point(0, height / 2), new Point(width, height / 2));
            }
        }
        else // WaveformPoints is null or empty
        {
            context.DrawLine(waveformPen, new Point(0, height / 2), new Point(width, height / 2));
        }

        if (ActiveLoop != null && Duration.TotalSeconds > 0)
        {
            var loopStartRatio = ActiveLoop.Start.TotalSeconds / Duration.TotalSeconds;
            var loopEndRatio = ActiveLoop.End.TotalSeconds / Duration.TotalSeconds;
            var loopStartX = loopStartRatio * width;
            var loopEndX = loopEndRatio * width;
            if (loopEndX > loopStartX)
            {
                context.FillRectangle(LoopRegionBrush, new Rect(loopStartX, 0, loopEndX - loopStartX, height));
            }
        }

        if (Duration.TotalSeconds > 0)
        {
            var currentX = (CurrentPosition.TotalSeconds / Duration.TotalSeconds) * width;
            currentX = Math.Clamp(currentX, 0, width);
            context.DrawLine(positionPen, new Point(currentX, 0), new Point(currentX, height));
        }
    }
}
</file>

<file path="Source\Converters\BooleanToPlayPauseIconConverter.cs">
using System;
using Avalonia.Data.Converters;
using System.Globalization;

namespace Sonorize.Converters
{
    public class BooleanToPlayPauseIconConverter : IValueConverter
    {
        public static readonly BooleanToPlayPauseIconConverter Instance = new();

        private const string PlayIcon = "â–¶"; // U+25B6
        private const string PauseIcon = "||"; // U+2016 (Double Vertical Line)

        public object Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
        {
            if (value is bool isPlaying)
            {
                return isPlaying ? PauseIcon : PlayIcon;
            }
            return PlayIcon; // Default to Play icon if value is not a bool
        }

        public object ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
        {
            throw new NotSupportedException();
        }
    }
}
</file>

<file path="Source\Converters\BooleanToPlayPauseTextConverter.cs">
// Path: Source/Views/MainView.cs
using System;
using Avalonia.Data.Converters;

namespace Sonorize.Converters;

public class BooleanToPlayPauseTextConverter : IValueConverter
{
    public static readonly BooleanToPlayPauseTextConverter Instance = new();

    public object Convert(object? value, Type targetType, object? parameter, System.Globalization.CultureInfo culture)
    {
        if (value is bool isPlaying) return isPlaying ? "Pause" : "Play";
        return "Play";
    }
    public object ConvertBack(object? value, Type targetType, object? parameter, System.Globalization.CultureInfo culture)
        => throw new NotSupportedException();
}
</file>

<file path="Source\Converters\BooleanToShuffleIconConverter.cs">
using System;
using Avalonia.Data.Converters;
using System.Globalization;
using System.Diagnostics; // Added for Debug

namespace Sonorize.Converters
{
    public class BooleanToShuffleIconConverter : IValueConverter
    {
        public static readonly BooleanToShuffleIconConverter Instance = new();

        private const string ShuffleActiveIcon = "ðŸ”€"; // U+1F500 Twisted Arrows Right and Left
        private const string ShuffleInactiveIcon = "â†”"; // U+2194 Left Right Arrow

        public object Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
        {
            // Add debug logging here
            Debug.WriteLine($"[Converter] BooleanToShuffleIconConverter Convert called. Value: {value}, TargetType: {targetType}");
            if (value is bool isShuffleEnabled)
            {
                Debug.WriteLine($"[Converter] isShuffleEnabled: {isShuffleEnabled}. Returning: {(isShuffleEnabled ? ShuffleActiveIcon : ShuffleInactiveIcon)}");
                return isShuffleEnabled ? ShuffleActiveIcon : ShuffleInactiveIcon;
            }
            Debug.WriteLine($"[Converter] Value is not bool ({value?.GetType().Name ?? "null"}). Returning: {ShuffleInactiveIcon}");
            return ShuffleInactiveIcon; // Default
        }

        public object ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
        {
            throw new NotSupportedException();
        }
    }
}
</file>

<file path="Source\Converters\NotNullToBooleanConverter.cs">
// Path: Source/Views/MainView.cs
using System;
using Avalonia.Controls;
using System.Globalization;
using Avalonia.Data.Converters;

namespace Sonorize.Converters;

public class NotNullToBooleanConverter : IValueConverter
{
    public static readonly NotNullToBooleanConverter Instance = new();

    public object Convert(object? value, Type targetType, object? parameter, System.Globalization.CultureInfo culture)
    {
        return value != null;
    }

    public object ConvertBack(object? value, Type targetType, object? parameter, System.Globalization.CultureInfo culture)
    {
        throw new NotSupportedException();
    }
}
</file>

<file path="Source\Models\AppSettings.cs">
using System.Collections.Generic;
using Sonorize.ViewModels; // Required for SongDisplayMode

namespace Sonorize.Models;

public class AppSettings
{
    public List<string> MusicDirectories { get; set; } = new List<string>();
    public string? PreferredThemeFileName { get; set; } // Stores the name of the theme file

    // Preferences for view modes, stored as strings for easy serialization
    public string LibraryViewModePreference { get; set; } = SongDisplayMode.Detailed.ToString();
    public string ArtistViewModePreference { get; set; } = SongDisplayMode.Detailed.ToString();
    public string AlbumViewModePreference { get; set; } = SongDisplayMode.Detailed.ToString();
}
</file>

<file path="Source\Models\LoopRegion.cs">
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace Sonorize.Models;

public class LoopRegion(TimeSpan start, TimeSpan end, string name = "Loop") : INotifyPropertyChanged
{
    private string _name = name; // Name field remains, but not prominently used in UI
    public string Name
    {
        get => _name;
        set => SetProperty(ref _name, value);
    }

    private TimeSpan _start = start;
    public TimeSpan Start
    {
        get => _start;
        set => SetProperty(ref _start, value);
    }

    private TimeSpan _end = end;
    public TimeSpan End
    {
        get => _end;
        set => SetProperty(ref _end, value);
    }

    // DisplayText no longer includes the name by default for main UI, focused on times
    public string DisplayText => $"({Start:mm\\:ss} - {End:mm\\:ss})";

    public event PropertyChangedEventHandler? PropertyChanged;
    protected bool SetProperty<T>(ref T field, T value, [CallerMemberName] string? propertyName = null)
    {
        if (EqualityComparer<T>.Default.Equals(field, value)) return false;
        field = value;
        OnPropertyChanged(propertyName);
        return true;
    }
    protected void OnPropertyChanged([CallerMemberName] string? propertyName = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
</file>

<file path="Source\Models\LoopStorageData.cs">
using System;

namespace Sonorize.Models;

public record LoopStorageData(TimeSpan Start, TimeSpan End, bool IsActive);
</file>

<file path="Source\Models\Song.cs">
using Avalonia.Media.Imaging;
using Sonorize.ViewModels; // For ViewModelBase
using System;
using System.ComponentModel;
using System.Diagnostics; // For INotifyPropertyChanged

namespace Sonorize.Models;

public class Song : ViewModelBase
{
    private string _filePath = string.Empty;
    public string FilePath { get => _filePath; set => SetProperty(ref _filePath, value); }

    private string _title = "Unknown Title";
    public string Title { get => _title; set => SetProperty(ref _title, value); }

    private string _artist = "Unknown Artist";
    public string Artist { get => _artist; set => SetProperty(ref _artist, value); }

    private string _album = "Unknown Album";
    public string Album { get => _album; set => SetProperty(ref _album, value); }

    private TimeSpan _duration;
    public TimeSpan Duration { get => _duration; set => SetProperty(ref _duration, value); }
    public string DurationString => $"{Duration:mm\\:ss}";

    private Bitmap? _thumbnail;
    public Bitmap? Thumbnail { get => _thumbnail; set => SetProperty(ref _thumbnail, value); }

    private LoopRegion? _savedLoop;
    public LoopRegion? SavedLoop
    {
        get => _savedLoop;
        set => SetProperty(ref _savedLoop, value);
    }

    private bool _isLoopActive;
    public bool IsLoopActive
    {
        get => _isLoopActive;
        set
        {
            // SetProperty handles OnPropertyChanged
            if (SetProperty(ref _isLoopActive, value))
            {
                // The ViewModel will observe this change and trigger persistence
                Debug.WriteLine($"[SongModel] {Title} - IsLoopActive set to: {value}");
            }
        }
    }
}
</file>

<file path="Source\Models\ThemeColors.cs">
using Avalonia.Media;
using System.Text.Json.Serialization;

namespace Sonorize.Models;

public class ThemeColors
{
    // --- Main UI Colors ---
    public string BackgroundColor { get; set; } = "#FF1E1E1E";
    public string SlightlyLighterBackground { get; set; } = "#FF2D2D30";
    public string ControlBackgroundColor { get; set; } = "#FF3C3C3C";
    public string TextColor { get; set; } = "#FFF1F1F1";
    public string SecondaryTextColor { get; set; } = "#FFAAAAAA";
    public string AccentColor { get; set; } = "#FF007ACC";
    public string AccentForeground { get; set; } = "#FFFFFFFF";

    // --- ListBox Specific Colors ---
    public string ListBoxBackground { get; set; } = "#FF2D2D30"; // Default: Same as SlightlyLighterBackground

    // --- Brush Properties ---
    [JsonIgnore] public IBrush B_BackgroundColor => SolidColorBrush.Parse(BackgroundColor);
    [JsonIgnore] public IBrush B_SlightlyLighterBackground => SolidColorBrush.Parse(SlightlyLighterBackground);
    [JsonIgnore] public IBrush B_ControlBackgroundColor => SolidColorBrush.Parse(ControlBackgroundColor);
    [JsonIgnore] public IBrush B_TextColor => SolidColorBrush.Parse(TextColor);
    [JsonIgnore] public IBrush B_SecondaryTextColor => SolidColorBrush.Parse(SecondaryTextColor);
    [JsonIgnore] public IBrush B_AccentColor => SolidColorBrush.Parse(AccentColor);
    [JsonIgnore] public IBrush B_AccentForeground => SolidColorBrush.Parse(AccentForeground);
    [JsonIgnore] public IBrush B_ListBoxBackground => SolidColorBrush.Parse(ListBoxBackground);

    public static ThemeColors CreateAmoledSpotifyTheme()
    {
        return new ThemeColors
        {
            BackgroundColor = "#FF000000",
            SlightlyLighterBackground = "#FF121212",
            ControlBackgroundColor = "#FF181818",
            TextColor = "#FFFFFFFF",
            SecondaryTextColor = "#FFB3B3B3",
            AccentColor = "#FF1DB954",      // Spotify Green
            AccentForeground = "#FF000000",  // Black text on green buttons
            ListBoxBackground = "#FF000000"   // <<< CRUCIAL FOR AMOLED LIST ITEMS (unselected)
        };
    }
}
</file>

<file path="Source\Services\LoopDataService.cs">
// Path: Source/Services/LoopDataService.cs
using Sonorize.Models;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text.Json;
using System.Diagnostics;

namespace Sonorize.Services;

public class LoopDataService
{
    private readonly string _loopDataFilePath;
    private Dictionary<string, LoopStorageData> _loopDataStore = new();
    private readonly object _lock = new object();

    public LoopDataService()
    {
        var appDataPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
        var sonorizeAppDataPath = Path.Combine(appDataPath, "Sonorize");
        Directory.CreateDirectory(sonorizeAppDataPath);
        _loopDataFilePath = Path.Combine(sonorizeAppDataPath, "loopdata.json");
        LoadLoopData();
        Debug.WriteLine($"[LoopDataService] Initialized. Data loaded from: {_loopDataFilePath}");
    }

    private void LoadLoopData()
    {
        lock (_lock)
        {
            try
            {
                if (File.Exists(_loopDataFilePath))
                {
                    var json = File.ReadAllText(_loopDataFilePath);
                    // Handle potential old format without IsActive gracefully
                    var tempStore = JsonSerializer.Deserialize<Dictionary<string, JsonElement>>(json);
                    _loopDataStore = new Dictionary<string, LoopStorageData>();
                    if (tempStore != null)
                    {
                        foreach (var kvp in tempStore)
                        {
                            try
                            {
                                // Try to deserialize to the new record type
                                _loopDataStore[kvp.Key] = kvp.Value.Deserialize<LoopStorageData>()!;
                            }
                            catch (JsonException) // If it fails, it might be the old format
                            {
                                try
                                {
                                    // Old format: record LoopStorageData(TimeSpan Start, TimeSpan End);
                                    var oldLoop = kvp.Value.Deserialize<OldLoopStorageDataTemp>();
                                    if (oldLoop != null)
                                    {
                                        _loopDataStore[kvp.Key] = new LoopStorageData(oldLoop.Start, oldLoop.End, false); // Default IsActive to false for old data
                                        Debug.WriteLine($"[LoopDataService] Migrated old loop format for {Path.GetFileName(kvp.Key)}");
                                    }
                                }
                                catch (Exception exMigrate)
                                {
                                    Debug.WriteLine($"[LoopDataService] Failed to migrate or deserialize loop for {Path.GetFileName(kvp.Key)}: {exMigrate.Message}");
                                }
                            }
                        }
                    }
                    Debug.WriteLine($"[LoopDataService] Successfully loaded/migrated {_loopDataStore.Count} loop entries.");
                }
                else
                {
                    _loopDataStore = new Dictionary<string, LoopStorageData>();
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[LoopDataService] Error loading loop data: {ex.Message}. Initializing with empty store.");
                _loopDataStore = new Dictionary<string, LoopStorageData>();
            }
        }
    }
    // Temporary record for migration from old format
    private record OldLoopStorageDataTemp(TimeSpan Start, TimeSpan End);


    private void SaveLoopData()
    {
        lock (_lock)
        {
            try
            {
                var options = new JsonSerializerOptions { WriteIndented = true };
                var json = JsonSerializer.Serialize(_loopDataStore, options);
                File.WriteAllText(_loopDataFilePath, json);
                Debug.WriteLine($"[LoopDataService] Successfully saved {_loopDataStore.Count} loop entries to {_loopDataFilePath}");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[LoopDataService] Error saving loop data: {ex.Message}");
            }
        }
    }

    public LoopStorageData? GetLoop(string filePath)
    {
        if (string.IsNullOrEmpty(filePath)) return null;
        lock (_lock)
        {
            _loopDataStore.TryGetValue(filePath, out var loopData);
            return loopData;
        }
    }

    // Modified to accept isActive
    public void SetLoop(string filePath, TimeSpan start, TimeSpan end, bool isActive)
    {
        if (string.IsNullOrEmpty(filePath)) return;
        var loopData = new LoopStorageData(start, end, isActive);
        lock (_lock)
        {
            _loopDataStore[filePath] = loopData;
        }
        Debug.WriteLine($"[LoopDataService] SetLoop for \"{Path.GetFileName(filePath)}\": Start={start}, End={end}, IsActive={isActive}. Triggering save.");
        SaveLoopData();
    }

    public void UpdateLoopActiveState(string filePath, bool isActive)
    {
        if (string.IsNullOrEmpty(filePath)) return;
        lock (_lock)
        {
            if (_loopDataStore.TryGetValue(filePath, out var existingLoop))
            {
                _loopDataStore[filePath] = existingLoop with { IsActive = isActive }; // Using record 'with' expression
                Debug.WriteLine($"[LoopDataService] UpdateLoopActiveState for \"{Path.GetFileName(filePath)}\" to IsActive={isActive}. Triggering save.");
                SaveLoopData();
            }
            else
            {
                Debug.WriteLine($"[LoopDataService] UpdateLoopActiveState: No loop definition found for \"{Path.GetFileName(filePath)}\" to update active state.");
            }
        }
    }


    public void ClearLoop(string filePath)
    {
        if (string.IsNullOrEmpty(filePath)) return;
        bool removed = false;
        lock (_lock)
        {
            if (_loopDataStore.ContainsKey(filePath))
            {
                removed = _loopDataStore.Remove(filePath);
            }
        }
        if (removed)
        {
            Debug.WriteLine($"[LoopDataService] ClearLoop for \"{Path.GetFileName(filePath)}\". Triggering save.");
            SaveLoopData();
        }
    }
}
</file>

<file path="Source\Services\MusicLibraryService.cs">
using Avalonia.Media.Imaging;
using Sonorize.Models;
using System;
using System.Collections.Generic;
using System.Globalization; // For CultureInfo
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Diagnostics;
using TagLib;
using Avalonia.Threading;
using Avalonia.Media; // For Brushes, Colors
using Avalonia; // For PixelSize, Vector, Rect, Size, Point
using Avalonia.Platform; // For RenderTargetBitmap

namespace Sonorize.Services;

public class MusicLibraryService
{
    private Bitmap? _defaultThumbnail;
    private readonly LoopDataService _loopDataService;

    public MusicLibraryService(LoopDataService loopDataService)
    {
        _loopDataService = loopDataService;
        Debug.WriteLine("[MusicLibService] Constructor called.");
        // Default thumbnail creation logic remains the same...
        if (_defaultThumbnail == null)
        {
            _defaultThumbnail = CreateDefaultMusicalNoteIcon();
            if (_defaultThumbnail == null)
            {
                Debug.WriteLine("[MusicLibService] CRITICAL: Failed to create default thumbnail in constructor.");
            }
            else
            {
                Debug.WriteLine("[MusicLibService] Default thumbnail created successfully in constructor.");
            }
        }
    }
    private Bitmap? CreateDefaultMusicalNoteIcon()
    {
        Debug.WriteLine("[ThumbGen] CreateDefaultMusicalNoteIcon called.");
        try
        {
            var pixelSize = new Avalonia.PixelSize(96, 96); // Increased size
            var dpi = new Avalonia.Vector(96, 96);

            using var renderTarget = new RenderTargetBitmap(pixelSize, dpi);
            using (DrawingContext context = renderTarget.CreateDrawingContext())
            {
                var backgroundBrush = new SolidColorBrush(Avalonia.Media.Colors.DimGray);
                var foregroundBrush = Avalonia.Media.Brushes.WhiteSmoke;

                var bounds = new Rect(new Size(pixelSize.Width, pixelSize.Height));
                context.FillRectangle(backgroundBrush, bounds);

                var formattedText = new FormattedText(
                    "â™«",
                    CultureInfo.CurrentCulture,
                    FlowDirection.LeftToRight,
                    Typeface.Default,
                    pixelSize.Width / 2, // Font size scaled with icon size
                    foregroundBrush);

                // Center the text
                var textOrigin = new Avalonia.Point(
                    (bounds.Width - formattedText.Width) / 2,
                    (bounds.Height - formattedText.Height) / 2);
                context.DrawText(formattedText, textOrigin);
            }

            // Save to a memory stream
            using var memoryStream = new MemoryStream();
            renderTarget.Save(memoryStream); // Default is PNG
            memoryStream.Seek(0, SeekOrigin.Begin);

            if (memoryStream.Length > 0)
            {
                var bitmap = new Bitmap(memoryStream);
                Debug.WriteLine($"[ThumbGen] Default musical note icon created successfully. Size: {bitmap.PixelSize}");
                return bitmap;
            }
            Debug.WriteLine("[ThumbGen] CRITICAL ERROR: MemoryStream empty for default icon, returning null.");
            return null;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[ThumbGen] CRITICAL EXCEPTION creating default icon: {ex.ToString()}, returning null.");
            return null;
        }
    }

    public Bitmap? GetDefaultThumbnail() => _defaultThumbnail;
    private Bitmap? LoadAlbumArt(string filePath)
    {
        try
        {
            using (var tagFile = TagLib.File.Create(filePath))
            {
                if (tagFile.Tag.Pictures.Length > 0)
                {
                    IPicture pic = tagFile.Tag.Pictures[0];
                    using (var ms = new MemoryStream(pic.Data.Data))
                    {
                        if (ms.Length > 0)
                        {
                            using (var originalBitmap = new Bitmap(ms))
                            {
                                // Modified: Resize to a larger thumbnail for better quality when scaled down
                                var targetSize = new PixelSize(128, 128); // Increased from 96x96
                                var scaledBitmap = originalBitmap.CreateScaledBitmap(targetSize, BitmapInterpolationMode.HighQuality);
                                Debug.WriteLine($"[AlbumArt] Loaded and scaled album art for {Path.GetFileName(filePath)} to {targetSize.Width}x{targetSize.Height}.");
                                return scaledBitmap;
                            }
                        }
                    }
                }
            }
        }
        catch (CorruptFileException) { Debug.WriteLine($"[AlbumArt] Corrupt file exception for {Path.GetFileName(filePath)}"); }
        catch (UnsupportedFormatException) { Debug.WriteLine($"[AlbumArt] Unsupported format exception for {Path.GetFileName(filePath)}"); }
        catch (Exception ex) { Debug.WriteLine($"[AlbumArt] Error loading album art for {Path.GetFileName(filePath)}: {ex.Message}"); }
        return null;
    }


    public async Task LoadMusicFromDirectoriesAsync(
        IEnumerable<string> directories,
        Action<Song> songAddedCallback,
        Action<string> statusUpdateCallback)
    {
        Debug.WriteLine("[MusicLibService] LoadMusicFromDirectoriesAsync called.");
        var supportedExtensions = new[] { ".mp3", ".wav", ".flac", ".m4a", ".ogg" }; // Common audio formats
        Bitmap? defaultIcon = GetDefaultThumbnail();
        int filesProcessed = 0;

        foreach (var dir in directories)
        {
            if (!Directory.Exists(dir))
            {
                Debug.WriteLine($"[LibScan] Directory not found: {dir}");
                await Dispatcher.UIThread.InvokeAsync(() => statusUpdateCallback($"Directory not found: {dir}"));
                continue;
            }
            await Dispatcher.UIThread.InvokeAsync(() => statusUpdateCallback($"Scanning: {Path.GetFileName(dir)}..."));

            List<string> filesInDir;
            try
            {
                filesInDir = Directory.EnumerateFiles(dir, "*.*", SearchOption.AllDirectories)
                                      .Where(f => supportedExtensions.Any(ext => f.EndsWith(ext, StringComparison.OrdinalIgnoreCase)))
                                      .ToList();
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[LibScan] Error enumerating files in {dir}: {ex.Message}");
                await Dispatcher.UIThread.InvokeAsync(() => statusUpdateCallback($"Error scanning {Path.GetFileName(dir)}"));
                continue;
            }

            foreach (var file in filesInDir)
            {
                Bitmap? thumbnail = LoadAlbumArt(file);
                var song = new Song
                {
                    FilePath = file,
                    Title = Path.GetFileNameWithoutExtension(file), // Default title
                    Artist = "Unknown Artist",       // Default artist
                    Album = "Unknown Album",         // Default album
                    Duration = TimeSpan.Zero,        // Default duration
                    Thumbnail = thumbnail ?? defaultIcon
                };

                try
                {
                    using (var tagFile = TagLib.File.Create(file))
                    {
                        if (!string.IsNullOrWhiteSpace(tagFile.Tag.Title)) song.Title = tagFile.Tag.Title;
                        if (tagFile.Tag.Performers.Length > 0 && !string.IsNullOrWhiteSpace(tagFile.Tag.Performers[0]))
                            song.Artist = tagFile.Tag.Performers[0];
                        else if (tagFile.Tag.AlbumArtists.Length > 0 && !string.IsNullOrWhiteSpace(tagFile.Tag.AlbumArtists[0]))
                            song.Artist = tagFile.Tag.AlbumArtists[0]; // Fallback to album artist
                        if (!string.IsNullOrWhiteSpace(tagFile.Tag.Album)) song.Album = tagFile.Tag.Album;
                        if (tagFile.Properties.Duration > TimeSpan.Zero) song.Duration = tagFile.Properties.Duration;
                    }
                }
                catch (Exception) { /* Silently ignore metadata read errors for now */ }

                var storedLoopData = _loopDataService.GetLoop(song.FilePath);
                if (storedLoopData != null)
                {
                    song.SavedLoop = new LoopRegion(storedLoopData.Start, storedLoopData.End);
                    song.IsLoopActive = storedLoopData.IsActive; // <-- SET IsLoopActive
                    Debug.WriteLine($"[MusicLibService] Loaded persistent loop for {Path.GetFileName(song.FilePath)}: {song.SavedLoop.Start} - {song.SavedLoop.End}, Active: {song.IsLoopActive}");
                }

                await Dispatcher.UIThread.InvokeAsync(() => songAddedCallback(song));
                filesProcessed++;
                if (filesProcessed % 20 == 0) // Update status periodically
                {
                    await Dispatcher.UIThread.InvokeAsync(() => statusUpdateCallback($"Loaded {filesProcessed} songs..."));
                }
            }
        }
        Debug.WriteLine($"[MusicLibService] Background file scanning complete. Processed {filesProcessed} songs.");
    }
}
</file>

<file path="Source\Services\PlaybackService.cs">
using Avalonia.Threading;
using NAudio.Wave;
using NAudio.Wave.SampleProviders;
using Sonorize.Models;
using Sonorize.ViewModels; // Required for PlaybackStateStatus enum
using System;
using System.Diagnostics;
using System.IO;
using System.Threading;
using SoundTouch.Net.NAudioSupport;
using Avalonia.Animation;

namespace Sonorize.Services;

// Keep enum here for completeness/clarity within the service context
public enum PlaybackStateStatus { Stopped, Playing, Paused }

public class PlaybackService : ViewModelBase, IDisposable
{
    private Song? _currentSong;
    public Song? CurrentSong
    {
        get => _currentSong;
        private set
        {
            if (SetProperty(ref _currentSong, value))
            {
                Debug.WriteLine($"[PlaybackService] CurrentSong property set to: {value?.Title ?? "null"}");
                OnPropertyChanged(nameof(HasCurrentSong));
                // When song changes, ensure state is stopped initially until Play() is called
                // CurrentPlaybackStatus = PlaybackStateStatus.Stopped; // Play() sets this correctly
                // IsPlaying = false; // Play() sets this correctly
                // CurrentPosition = TimeSpan.Zero; // InitializeNAudioPipeline sets this
                // CurrentSongDuration = TimeSpan.Zero; // InitializeNAudioPipeline sets this
                // The Play() method should handle the state transitions.
            }
        }
    }

    public bool HasCurrentSong => CurrentSong != null;

    private bool _isPlaying;
    public bool IsPlaying
    {
        get => _isPlaying;
        private set => SetProperty(ref _isPlaying, value);
    }

    private PlaybackStateStatus _currentPlaybackStatus = PlaybackStateStatus.Stopped;
    public PlaybackStateStatus CurrentPlaybackStatus
    {
        get => _currentPlaybackStatus;
        private set => SetProperty(ref _currentPlaybackStatus, value);
    }

    private TimeSpan _currentPosition;
    public TimeSpan CurrentPosition
    {
        get => _currentPosition;
        private set // Changed to private set
        {
            if (SetProperty(ref _currentPosition, value))
            {
                OnPropertyChanged(nameof(CurrentPositionSeconds));
            }
        }
    }
    public double CurrentPositionSeconds => CurrentPosition.TotalSeconds;

    private TimeSpan _currentSongDuration;
    public TimeSpan CurrentSongDuration
    {
        get => _currentSongDuration;
        private set
        {
            if (SetProperty(ref _currentSongDuration, value))
            {
                OnPropertyChanged(nameof(CurrentSongDurationSeconds));
            }
        }
    }
    public double CurrentSongDurationSeconds => CurrentSongDuration.TotalSeconds > 0 ? CurrentSongDuration.TotalSeconds : 1.0;

    private IWavePlayer? _waveOutDevice;
    private AudioFileReader? audioFileReader;
    private SmbPitchShiftingSampleProvider? pitchShifter;
    private Timer? uiUpdateTimer;
    private SoundTouchWaveProvider? soundTouch;
    private IWavePlayer? _waveOutDeviceInstanceForStopEventCheck; // Keep track of the instance to avoid handling events from old devices

    // Flag to signal if the stop was initiated by the public Stop() method.
    // This flag is ONLY set to true by public Stop() and reset to false in OnPlaybackStopped when the explicit stop is handled.
    private volatile bool _explicitStopRequested = false;


    private float _playbackRate = 1.0f;
    public float PlaybackRate
    {
        get => _playbackRate;
        set
        {
            if (Math.Abs(_playbackRate - value) > float.Epsilon)
            {
                _playbackRate = value;
                // Update the rate on the SoundTouch provider if it exists
                if (soundTouch != null) soundTouch.Tempo = _playbackRate;
                OnPropertyChanged();
            }
        }
    }

    private float _pitchSemitones = 0f;
    public float PitchSemitones
    {
        get => _pitchSemitones;
        set
        {
            if (Math.Abs(_pitchSemitones - value) > float.Epsilon)
            {
                _pitchSemitones = value;
                // Update the pitch factor on the pitch shifter provider if it exists
                if (pitchShifter != null) pitchShifter.PitchFactor = (float)Math.Pow(2, _pitchSemitones / 12.0);
                OnPropertyChanged();
            }
        }
    }

    // Event fired when playback reaches the end of the file naturally (not stopped or paused manually)
    public event EventHandler? PlaybackEndedNaturally;


    public PlaybackService()
    {
        Debug.WriteLine("[PlaybackService] Constructor called.");
        // Initialize timer but keep it stopped
        uiUpdateTimer = new Timer(UpdateUiCallback, null, Timeout.Infinite, Timeout.Infinite);
    }

    private void UpdateUiCallback(object? state)
    {
        // This callback runs on a ThreadPool thread, not the UI thread.
        // Marshal updates to the UI thread.

        // Check playback state *before* accessing audioFileReader position,
        // as accessing Position/CurrentTime might throw exceptions on some readers
        // if the device is stopped/disposed or the stream is finished.
        // Accessing _waveOutDevice?.PlaybackState is generally safer.
        // Also, check if audioFileReader and CurrentSong are still valid.
        if (_waveOutDevice?.PlaybackState == PlaybackState.Playing && audioFileReader != null && CurrentSong != null)
        {
            // Marshal to the UI thread
            Dispatcher.UIThread.InvokeAsync(() =>
            {
                // Double-check state after Dispatcher.UIThread.InvokeAsync due to potential delays
                // Ensure the audioFileReader is still valid before accessing CurrentTime
                if (_waveOutDevice?.PlaybackState != PlaybackState.Playing || audioFileReader == null || CurrentSong == null) return;

                TimeSpan currentAudioTime;
                try
                {
                    // Safely get position on the UI thread after marshaling
                    currentAudioTime = audioFileReader.CurrentTime;
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"[PlaybackService] Error getting CurrentTime in timer callback: {ex.Message}. Stopping timer.");
                    StopUiUpdateTimer(); // Stop the timer to prevent repeated errors
                    // PlaybackStopped event should handle final state if it fires due to this error.
                    return;
                }

                // Update the ViewModel property, which will notify UI bindings
                this.CurrentPosition = currentAudioTime; // Update CurrentPosition via its private setter

                // Note: Loop region handling is within the PlaybackService itself,
                // as it directly affects seeking logic during playback.
                if (CurrentSong.IsLoopActive && CurrentSong.SavedLoop != null)
                {
                    var loop = CurrentSong.SavedLoop;
                    // Ensure loop end is after loop start and valid within total time
                    if (loop.End > loop.Start && loop.End <= audioFileReader.TotalTime)
                    {
                        // Check if current position is at or past the loop end
                        // Using a small tolerance (e.g., 50ms) to trigger seek slightly before the exact end,
                        // but ensure it's not extremely close to the *total* song duration.
                        TimeSpan seekThreshold = loop.End - TimeSpan.FromMilliseconds(50);
                        if (currentAudioTime >= seekThreshold && currentAudioTime < audioFileReader.TotalTime - TimeSpan.FromMilliseconds(200))
                        {
                            Debug.WriteLine($"[PlaybackService] Loop active & end reached ({currentAudioTime:mm\\:ss\\.ff} >= {seekThreshold:mm\\:ss\\.ff}) within file ({audioFileReader.TotalTime:mm\\:ss\\.ff}). Seeking to loop start: {loop.Start:mm\\:ss\\.ff}");
                            Seek(loop.Start); // Perform the seek. Seek() handles its own logging and position update.
                            // After seeking, the timer will continue, reading the new position.
                        }
                        // If currentAudioTime is >= loop.End but also very close to audioFileReader.TotalTime,
                        // we let the natural end-of-file event trigger (PlaybackStopped).
                    }
                    else if (CurrentSong.IsLoopActive)
                    {
                        Debug.WriteLine($"[PlaybackService] Loop active but invalid region ({loop.Start:mm\\:ss\\.ff} - {loop.End:mm\\:ss\\.ff}). Loop will not function.");
                    }
                }
            });
        }
        else
        {
            // If playback state is no longer Playing, the timer should be stopped.
            // This check helps ensure the timer stops even if the PlaybackStopped event isn't handled for some reason,
            // or if the state was manually changed on the UI thread without a PlaybackStopped event (less likely).
            if (_waveOutDevice?.PlaybackState != PlaybackState.Playing)
            {
                Debug.WriteLine($"[PlaybackService] Timer callback found state is not Playing ({_waveOutDevice?.PlaybackState}). Stopping timer.");
                StopUiUpdateTimer();
            }
        }
    }

    /// <summary>
    /// Starts playback of the given song. Stops any currently playing song first.
    /// </summary>
    /// <param name="song">The song to play.</param>
    public void Play(Song song)
    {
        Debug.WriteLine($"[PlaybackService] Play requested for: {(song?.Title ?? "null song")}");
        // The _explicitStopRequested flag is ONLY set by public Stop().
        // Do NOT set _explicitStopRequested = false here.

        // If a song is currently playing/paused, initiate stop of the old one first.
        // This triggers OnPlaybackStopped for the old device, which cleans up.
        // If the device is already stopped or null, InitiateStop() does nothing.
        // CleanUpNAudioResources() below ensures a clean state regardless.
        if (_waveOutDevice != null && (_waveOutDevice.PlaybackState == PlaybackState.Playing || _waveOutDevice.PlaybackState == PlaybackState.Paused))
        {
            Debug.WriteLine("[PlaybackService] Play called while device active. Initiating stop of old playback.");
            InitiateStop(); // This triggers OnPlaybackStopped for the old device asynchronously
        }
        else if (_waveOutDevice != null && _waveOutDevice.PlaybackState == PlaybackState.Stopped)
        {
            // Device exists but is stopped. Its event handler should have run. Ensure clean state before Init.
            Debug.WriteLine("[PlaybackService] Play called while device stopped. Proceeding with Init.");
        }
        else // _waveOutDevice is null
        {
            Debug.WriteLine("[PlaybackService] Play called with no active device. Proceeding with Init.");
        }

        // Ensure cleanup happens before initializing the new pipeline, regardless of previous state.
        // This is called on the UI thread as Play() is called on the UI thread by MainVM.
        CleanUpNAudioResources(); // Dispose the old resources before creating new ones.


        if (song == null || string.IsNullOrEmpty(song.FilePath) || !File.Exists(song.FilePath))
        {
            Debug.WriteLine("[PlaybackService] Play called with null/invalid/missing file song. Cleaning up and stopping.");
            // Use the public Stop() for a full reset including nulling CurrentSong
            Stop(); // This will set _explicitStopRequested=true and call InitiateStop/OnPlaybackStopped path
            return;
        }

        // Set the new current song. This will notify UI and other VMs.
        // Set BEFORE initializing the pipeline, so Init can use CurrentSong properties if needed.
        CurrentSong = song;
        // Other state properties (IsPlaying, Status, Position, Duration) will be set by InitializeNAudioPipeline or Play().

        // Attempt to initialize the NAudio pipeline for the new song.
        bool pipelineInitialized = InitializeNAudioPipeline(song.FilePath);

        if (pipelineInitialized && _waveOutDevice != null && audioFileReader != null)
        {
            // If a loop is active for the new song, seek to the start of the loop before playing
            // Ensure loop start is valid and within total time
            if (CurrentSong.IsLoopActive && CurrentSong.SavedLoop != null && CurrentSong.SavedLoop.Start >= TimeSpan.Zero && CurrentSong.SavedLoop.Start < audioFileReader.TotalTime)
            {
                Debug.WriteLine($"[PlaybackService] New song has active loop ({CurrentSong.SavedLoop.Start:mm\\:ss\\.ff} - {CurrentSong.SavedLoop.End:mm\\:ss\\.ff}). Seeking to loop start: {CurrentSong.SavedLoop.Start:mm\\:ss\\.ff} before playing.");
                // Seek handles clamping and potential tolerance.
                Seek(CurrentSong.SavedLoop.Start);
                // Note: This seek is best-effort. Playback might start slightly before or after the exact time.
            }
            else if (CurrentSong.IsLoopActive && CurrentSong.SavedLoop != null)
            {
                Debug.WriteLine($"[PlaybackService] New song has active loop ({CurrentSong.SavedLoop.Start:mm\\:ss\\.ff} - {CurrentSong.SavedLoop.End:mm\\:ss\\.ff}), but loop start is invalid ({CurrentSong.SavedLoop.Start >= audioFileReader.TotalTime}). Starting from beginning.");
                // Position is already TimeSpan.Zero from InitializeNAudioPipeline. No seek needed.
            }
            else
            {
                Debug.WriteLine("[PlaybackService] New song has no active loop. Starting from beginning.");
                // Position is already TimeSpan.Zero from InitializeNAudioPipeline. No seek needed.
            }


            // Start the playback device
            _waveOutDevice.Play();
            // Update state properties to reflect playing status *after* successful Play() call
            IsPlaying = true;
            CurrentPlaybackStatus = PlaybackStateStatus.Playing;
            // Start the timer to update UI position
            StartUiUpdateTimer();
            Debug.WriteLine($"[PlaybackService] Playback started for: {CurrentSong.Title}. State: {CurrentPlaybackStatus}");

            // Reset the manual stop flag if it was true when Play() was called,
            // as a new track is now playing, regardless of a pending manual stop signal.
            // This handles the edge case where user clicked Stop then immediately Play.
            if (_explicitStopRequested)
            {
                _explicitStopRequested = false;
                Debug.WriteLine("[PlaybackService] _explicitStopRequested reset to false by Play() because new playback started.");
            }


        }
        else
        {
            Debug.WriteLine($"[PlaybackService] Pipeline init failed for {Path.GetFileName(song.FilePath)}. Cleaning up and stopping.");
            // If initialization failed, perform a full stop to reset all related state cleanly.
            Stop(); // Use the public Stop() for a full reset (sets _explicitStopRequested=true, initiates stop, OnPlaybackStopped handles nulling CurrentSong)
        }
    }

    /// <summary>
    /// Initializes the NAudio pipeline (AudioFileReader, SoundTouch, PitchShifter, WaveOutEvent).
    /// Cleans up existing resources first.
    /// </summary>
    /// <param name="filePath">Path to the audio file.</param>
    /// <returns>True if initialization was successful, false otherwise.</returns>
    private bool InitializeNAudioPipeline(string filePath)
    {
        Debug.WriteLine($"[PlaybackService] InitializeNAudioPipeline for: {Path.GetFileName(filePath)}");
        // Ensure any existing resources are cleaned up before creating new ones.
        // CleanUpNAudioResources() should dispose previous instances and nullify fields.
        // This is called by Play() before starting initialization.
        CleanUpNAudioResources(); // Explicit cleanup before new initialization

        try
        {
            // 1. Create AudioFileReader
            audioFileReader = new AudioFileReader(filePath);
            Debug.WriteLine($"[PlaybackService] Loaded AudioFileReader for {Path.GetFileName(filePath)}. Channels: {audioFileReader.WaveFormat.Channels}, SampleRate: {audioFileReader.WaveFormat.SampleRate}, Duration: {audioFileReader.TotalTime}");

            // 2. Convert to SampleProvider and Mono (SoundTouch works best with Mono float samples)
            ISampleProvider sourceSampleProvider = audioFileReader.ToSampleProvider();
            // Ensure conversion to mono if needed. NAudio's ToMono() handles this.
            ISampleProvider monoSampleProvider = sourceSampleProvider.ToMono();
            // Convert back to IWaveProvider for SoundTouch
            IWaveProvider monoWaveProviderForSoundTouch = new SampleToWaveProvider(monoSampleProvider);

            // 3. Add SoundTouch for tempo/rate control
            soundTouch = new SoundTouchWaveProvider(monoWaveProviderForSoundTouch)
            {
                Tempo = PlaybackRate, // Apply current tempo setting
                Rate = 1.0f, // Rate == 1.0 doesn't change playback speed, Tempo does
                Pitch = 1.0f // Pitch == 1.0 doesn't change pitch
            };
            Debug.WriteLine($"[PlaybackService] Added SoundTouch. Output format: {soundTouch.WaveFormat}");

            // 4. Convert SoundTouch output back to ISampleProvider for Pitch Shifting
            ISampleProvider soundTouchAsSampleProvider = soundTouch.ToSampleProvider();

            // 5. Add Pitch Shifting (SMB)
            pitchShifter = new SmbPitchShiftingSampleProvider(soundTouchAsSampleProvider)
            {
                // PitchFactor is calculated from PitchSemitones. Apply current setting.
                PitchFactor = (float)Math.Pow(2, PitchSemitones / 12.0)
            };
            Debug.WriteLine($"[PlaybackService] Added PitchShifter. Output format: {pitchShifter.WaveFormat}");


            // 6. Convert final ISampleProvider output to IWaveProvider for the output device
            IWaveProvider finalWaveProviderForDevice = pitchShifter.ToWaveProvider();
            Debug.WriteLine($"[PlaybackService] Final output format for device: {finalWaveProviderForDevice.WaveFormat}");


            // 7. Initialize the output device (WaveOutEvent is suitable for desktop)
            _waveOutDevice = new WaveOutEvent();
            // Store the instance reference BEFORE attaching the handler and BEFORE Init
            _waveOutDeviceInstanceForStopEventCheck = _waveOutDevice;
            // Attach the PlaybackStopped event handler
            _waveOutDevice.PlaybackStopped += OnPlaybackStopped;

            // Initialize the device with the final wave provider
            _waveOutDevice.Init(finalWaveProviderForDevice);

            // Set song duration and initial position. Update ViewModel properties.
            CurrentSongDuration = audioFileReader.TotalTime;
            this.CurrentPosition = TimeSpan.Zero; // Position starts at the beginning for a new song

            Debug.WriteLine($"[PlaybackService] NAudio pipeline initialization COMPLETE for: {Path.GetFileName(filePath)}.");
            return true;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[PlaybackService] CRITICAL ERROR during NAudio pipeline init for {Path.GetFileName(filePath)}: {ex.ToString()}");
            // Ensure resources are cleaned up if initialization failed at any step
            // No need to call CleanUpNAudioResources here, as Play() handles the full stop.
            // CleanUpNAudioResources(); // Should not be called here, Play() will call Stop()
            // Reset duration and position if init failed (already done by Stop() called in Play())
            // CurrentSongDuration = TimeSpan.Zero;
            // this.CurrentPosition = TimeSpan.Zero;
            // The caller (Play method) handles setting the global state to Stopped if Init fails.
            return false;
        }
    }

    /// <summary>
    /// Starts the timer used for periodically updating the UI position.
    /// </summary>
    private void StartUiUpdateTimer()
    {
        // Start or reset the timer to fire immediately and then every 100ms
        uiUpdateTimer?.Change(TimeSpan.Zero, TimeSpan.FromMilliseconds(100));
        Debug.WriteLine("[PlaybackService] UI Update Timer Started.");
    }

    /// <summary>
    /// Stops the timer used for periodically updating the UI position.
    /// </summary>
    private void StopUiUpdateTimer()
    {
        // Stop the timer by setting interval to Infinite
        uiUpdateTimer?.Change(Timeout.Infinite, Timeout.Infinite);
        Debug.WriteLine("[PlaybackService] UI Update Timer Stopped.");
    }

    /// <summary>
    /// Cleans up and disposes of NAudio playback resources.
    /// This should be called whenever playback stops or before initializing a new pipeline.
    /// Assumed to be called on the UI thread or a thread safe context.
    /// This method disposes the *current* service resources (_waveOutDevice, audioFileReader etc.)
    /// </summary>
    private void CleanUpNAudioResources()
    {
        Debug.WriteLine("[PlaybackService] CleanUpNAudioResources called.");
        // Ensure timer is stopped before disposing resources it might access.
        StopUiUpdateTimer();

        // Ensure we only detach the event from the *currently active* instance that we tracked, if it's not null.
        // Detach *before* disposing.
        if (_waveOutDevice != null && _waveOutDeviceInstanceForStopEventCheck == _waveOutDevice)
        {
            _waveOutDevice.PlaybackStopped -= OnPlaybackStopped; // Detach handler
            Debug.WriteLine("[PlaybackService] Detached PlaybackStopped handler.");
        }
        _waveOutDeviceInstanceForStopEventCheck = null; // Clear the tracked instance reference regardless

        // Dispose the wave output device if it exists and is not already disposed
        if (_waveOutDevice != null)
        {
            Debug.WriteLine($"[PlaybackService] Disposing WaveOutDevice (State: {_waveOutDevice.PlaybackState}).");
            // Stopping the device here is generally not needed if device.Stop() was called before cleanup,
            // but Dispose() implicitly stops if playing/paused.
            try { _waveOutDevice.Dispose(); } // Dispose the device
            catch (Exception ex) { Debug.WriteLine($"[PlaybackService] Error during _waveOutDevice.Dispose() in cleanup: {ex.Message}"); }
            _waveOutDevice = null; // Nullify the service reference
        }

        // Dispose the audio file reader if it exists
        if (audioFileReader != null)
        {
            Debug.WriteLine("[PlaybackService] Disposing AudioFileReader.");
            try { audioFileReader.Dispose(); }
            catch (Exception ex) { Debug.WriteLine($"[PlaybackService] Error during audioFileReader.Dispose() in cleanup: {ex.Message}"); }
            audioFileReader = null; // Nullify the service reference
        }

        // Nullify references to provider chain (they don't usually need explicit Dispose unless they hold significant unmanaged resources, which SoundTouchWaveProvider and SmbPitchShiftingSampleProvider don't typically)
        pitchShifter = null;
        soundTouch = null;

        Debug.WriteLine("[PlaybackService] NAudio resources cleaned up.");
    }


    /// <summary>
    /// Event handler for the PlaybackStopped event of the WaveOutEvent device.
    /// This method is responsible for determining why playback stopped (natural end, manual stop, error)
    /// and updating the service state accordingly, potentially raising the PlaybackEndedNaturally event.
    /// This handler is invoked on the UI thread due to Dispatcher.UIThread.InvokeAsync in the subscriber logic (if applicable, or explicitly marshaled).
    /// My PlaybackService.OnPlaybackStopped *is* marshaled via InvokeAsync in its implementation.
    /// </summary>
    /// <param name="sender">The source of the event (the WaveOutEvent instance).</param>
    /// <param name="e">The event arguments, including any exception if an occurred.</param>
    private void OnPlaybackStopped(object? sender, StoppedEventArgs e)
    {
        // This code runs on the UI thread because it's wrapped in Dispatcher.UIThread.InvokeAsync.

        // Check if the sender is the expected device instance to avoid handling events from old/disposed devices.
        // Note: _waveOutDeviceInstanceForStopEventCheck might be null here if CleanUpNAudioResources
        // was called by Play() on an already stopped device before this handler ran for the old device.
        // However, the sender is the actual instance that stopped. Checking sender reference against
        // the *service's current* _waveOutDevice is unreliable if Play() just started a new one.
        // The instance check should be against the *captured* instance reference from before cleanup.
        // This seems complex. Let's simplify and assume the handler only fires for the instance
        // that was active when Stop() or end-of-file occurred. CleanUpNAudioResources nullifies
        // the service field after disposing, so relying on the *captured* flags and state is better.


        // Capture flags and state *before* CleanUpNAudioResources potentially nullifies fields.
        // The _explicitStopRequested flag should reflect the intention *when the stop happened*.
        // Since Play() no longer sets _explicitStopRequested=false, this flag accurately reflects
        // whether public Stop() was called (true) or not (false).
        bool wasExplicitStop = _explicitStopRequested; // Capture state of flag

        // Attempt to get state information from the service fields *before* CleanUpResources disposes them.
        Song? songThatStopped = CurrentSong; // Capture song reference
        TimeSpan lastKnownPosition = TimeSpan.Zero;
        TimeSpan? songDuration = CurrentSongDuration.TotalSeconds > 0 ? (TimeSpan?)CurrentSongDuration : null;

        try
        {
            // Attempt to get the position from the reader before cleanup.
            // This might fail if resources were already disposed by a concurrent Play() call.
            if (audioFileReader != null)
            {
                lastKnownPosition = audioFileReader.CurrentTime;
            }
        }
        catch (Exception posEx)
        {
            Debug.WriteLine($"[PlaybackService] Error getting last known position before cleanup in OnPlaybackStopped: {posEx.Message}.");
            // lastKnownPosition remains TimeSpan.Zero on error.
        }

        // Safely format captured properties for logging
        TimeSpan? loopStart = songThatStopped?.SavedLoop?.Start;
        TimeSpan? loopEnd = songThatStopped?.SavedLoop?.End;
        string loopStartFormatted = loopStart.HasValue ? $"{loopStart.Value:mm\\:ss\\.ff}" : "N/A";
        string loopEndFormatted = loopEnd.HasValue ? $"{loopEnd.Value:mm\\:ss\\.ff}" : "N/A";
        string songDurationFormatted = songDuration.HasValue ? $"{songDuration.Value:mm\\:ss\\.ff}" : "N/A";

        Debug.WriteLine($"[PlaybackService] === OnPlaybackStopped START === (UI Thread)");
        Debug.WriteLine($"[PlaybackService] Event Sender Type: {sender?.GetType().Name ?? "null"}");
        Debug.WriteLine($"[PlaybackService] Current Service Device: {_waveOutDevice?.GetType().Name ?? "null"} (State: {_waveOutDevice?.PlaybackState})");
        Debug.WriteLine($"[PlaybackService] Exception: {e.Exception?.Message ?? "None"}");
        Debug.WriteLine($"[PlaybackService] _explicitStopRequested (captured state): {wasExplicitStop}");
        Debug.WriteLine($"[PlaybackService] Song that stopped (captured): {songThatStopped?.Title ?? "null"}"); // Log captured song
        Debug.WriteLine($"[PlaybackService] Current Pos Before Cleanup Attempt: {lastKnownPosition:mm\\:ss\\.ff}");
        Debug.WriteLine($"[PlaybackService] Song Duration (captured): {songDurationFormatted}");
        Debug.WriteLine($"[PlaybackService] Song LoopActive (captured): {songThatStopped?.IsLoopActive ?? false}, Loop: {loopStartFormatted} - {loopEndFormatted}");
        Debug.WriteLine($"[PlaybackService] === OnPlaybackStopped END initial checks ===");


        // Clean up resources associated with the service.
        // This disposes the *current* service resources (_waveOutDevice, audioFileReader etc)
        // It also nullifies the service fields and detaches the event handler from the instance it disposes.
        // This must happen on the UI thread as the handler is dispatched there.
        CleanUpNAudioResources(); // Disposes the sender device/reader and nullifies service fields

        // Stop the UI timer.
        StopUiUpdateTimer();

        // Update service state on the UI thread based on the reason for stopping.
        if (e.Exception != null)
        {
            Debug.WriteLine($"[PlaybackService] Playback stopped due to error: {e.Exception.Message}. Finalizing state to Stopped.");
            IsPlaying = false;
            CurrentPlaybackStatus = PlaybackStateStatus.Stopped;
            this.CurrentPosition = TimeSpan.Zero;
            CurrentSongDuration = TimeSpan.Zero; // Error means no valid duration
            CurrentSong = null; // On error, clear the song reference
            // Reset manual stop flag on error, as the explicit stop sequence is broken.
            _explicitStopRequested = false;
            Debug.WriteLine("[PlaybackService] _explicitStopRequested reset to false by error handler.");
            Debug.WriteLine("[PlaybackService] State set to Stopped by error handler.");
        }
        else // e.Exception == null (Clean stop)
        {
            // Determine if it was a natural end of file.
            // This is true if it's a clean stop, was NOT an explicit manual stop (_explicitStopRequested was false),
            // AND the position was near the end of the song that stopped.
            bool isNearEndOfFile = songDuration.HasValue && lastKnownPosition >= songDuration.Value - TimeSpan.FromMilliseconds(200);

            Debug.WriteLine($"[PlaybackService] Clean Stop. Was Explicit Stop (captured): {wasExplicitStop}. Is Near End of File: {isNearEndOfFile}.");

            if (wasExplicitStop) // Case 1: Manual Stop via public Stop()
            {
                Debug.WriteLine("[PlaybackService] Playback stopped by explicit user command (event). Finalizing state to Stopped.");
                IsPlaying = false;
                CurrentPlaybackStatus = PlaybackStateStatus.Stopped;
                this.CurrentPosition = TimeSpan.Zero;
                CurrentSongDuration = TimeSpan.Zero; // Manual stop clears duration/song
                CurrentSong = null; // This is the full stop state.
                // Reset the flag now that the explicit stop is fully handled.
                _explicitStopRequested = false;
                Debug.WriteLine("[PlaybackService] _explicitStopRequested reset to false after handling explicit stop.");
                Debug.WriteLine("[PlaybackService] State set to Stopped by explicit stop handler.");
            }
            else if (isNearEndOfFile) // Case 2: Natural End of File (and not an explicit stop)
            {
                Debug.WriteLine("[PlaybackService] Playback stopped naturally (event). Raising PlaybackEndedNaturally event.");
                // Natural end signals, and sets state to Stopped.
                // The MainVM handler will then call Play() or Stop(), which sets the next state (Playing or staying Stopped).
                // Set position to 0 for the NEXT song/loop start.
                this.CurrentPosition = TimeSpan.Zero;
                // State should reflect Stopped after ANY stop event.
                IsPlaying = false;
                CurrentPlaybackStatus = PlaybackStateStatus.Stopped;
                // Duration and Song reference remain for the event handler to use.

                PlaybackEndedNaturally?.Invoke(this, EventArgs.Empty);
                Debug.WriteLine("[PlaybackService] State set to Stopped by natural end handler, event raised.");
            }
            else
            {
                // Case 3: Clean stop that was not explicit and not near end. Implies interruption by Play().
                Debug.WriteLine("Playback stopped by interruption (likely Play called).");
                // Resources cleaned up. Service state (IsPlaying, CurrentPlaybackStatus, CurrentSong, Pos, Duration)
                // is handled by the NEW Play() call that caused this interruption.
                // Do NOT change service state here. It should reflect the *new* state.
                // Do NOT reset _explicitStopRequested (it should already be false).
                // Just log and exit. The new playback state is already being set by Play().
                Debug.WriteLine("[PlaybackService] Interruption stop handler finished. State managed by calling Play() method.");
            }
        }
        Debug.WriteLine("[PlaybackService] OnPlaybackStopped handler finishes.");
    }

    /// <summary>
    /// Pauses playback.
    /// </summary>
    public void Pause()
    {
        // Do NOT set _explicitStopRequested to true for a pause.
        if (IsPlaying && _waveOutDevice != null && _waveOutDevice.PlaybackState == PlaybackState.Playing)
        {
            Debug.WriteLine("[PlaybackService] Pause requested.");
            _waveOutDevice.Pause(); // Pause the device. PlaybackStopped is NOT usually fired on pause.
            IsPlaying = false; // Update state properties
            CurrentPlaybackStatus = PlaybackStateStatus.Paused;
            StopUiUpdateTimer(); // Stop the timer while paused
        }
        else
        {
            Debug.WriteLine($"[PlaybackService] Pause requested but not currently playing. State: {_waveOutDevice?.PlaybackState}. Doing nothing.");
        }
    }

    /// <summary>
    /// Resumes playback from a paused state or starts playback from the beginning if stopped.
    /// </summary>
    public void Resume()
    {
        Debug.WriteLine($"[PlaybackService] Resume requested. Current Status: {CurrentPlaybackStatus}, HasSong: {HasCurrentSong}");

        if (CurrentSong == null)
        {
            Debug.WriteLine("[PlaybackService] Resume requested but no CurrentSong is set. Cannot resume.");
            return;
        }

        // If currently paused, simply call Play() on the device.
        if (_waveOutDevice != null && _waveOutDevice.PlaybackState == PlaybackState.Paused && audioFileReader != null)
        {
            Debug.WriteLine("[PlaybackService] Resume requested from Paused state. Playing device.");
            _waveOutDevice.Play(); // Resume playback. PlaybackState changes to Playing.
            IsPlaying = true; // Update state properties
            CurrentPlaybackStatus = PlaybackStateStatus.Playing;
            StartUiUpdateTimer(); // Restart the timer
        }
        // If stopped, and there is a CurrentSong set (meaning it was stopped after playing, not initially idle),
        // we should re-initialize the pipeline and play from the last position or 0.
        // Calling Play(CurrentSong) achieves this as Play handles initialization from scratch.
        // If PlaybackStatus is Stopped but device is null/disposed, re-initialization is needed.
        else if (CurrentPlaybackStatus == PlaybackStateStatus.Stopped)
        {
            Debug.WriteLine("[PlaybackService] Resume requested from Stopped state. Re-playing current song.");
            // Calling Play(CurrentSong) will stop any existing playback (which there shouldn't be),
            // initialize a new pipeline, and start playback from 0 (or loop start).
            Play(CurrentSong);
        }
        else
        {
            Debug.WriteLine($"[PlaybackService] Resume requested but conditions not met. Device State: {_waveOutDevice?.PlaybackState ?? PlaybackState.Stopped}, AFR: {audioFileReader != null}, Current Playback Status: {CurrentPlaybackStatus}. Doing nothing.");
        }
    }

    /// <summary>
    /// Initiates the stopping process. Signals the device to stop.
    /// Cleanup and state updates happen in the PlaybackStopped event handler.
    /// </summary>
    private void InitiateStop() // Renamed from StopPlaybackInternal, removed bool parameter
    {
        Debug.WriteLine($"[PlaybackService] InitiateStop called. Current device state: {_waveOutDevice?.PlaybackState}. _explicitStopRequested = {_explicitStopRequested}");

        if (_waveOutDevice != null)
        {
            if (_waveOutDevice.PlaybackState != PlaybackState.Stopped)
            {
                Debug.WriteLine("[PlaybackService] Calling device.Stop() from InitiateStop.");
                try
                {
                    // This will trigger OnPlaybackStopped
                    _waveOutDevice.Stop();
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"[PlaybackService] Error calling _waveOutDevice.Stop() in InitiateStop: {ex.Message}. This might prevent OnPlaybackStopped from firing for this device. State might become inconsistent.");
                    // If Stop() fails, the event might not fire. The state might not be updated correctly.
                    // The Play() method's subsequent CleanUpNAudioResources might help recover,
                    // but the state could briefly show Playing when it shouldn't.
                }
            }
            else
            {
                // Device is already stopped. OnPlaybackStopped won't fire for this instance via Stop().
                Debug.WriteLine("[PlaybackService] InitiateStop: Device already stopped. No Stop() call needed. Cleanup will happen during new Init or via pending OnPlaybackStopped.");
            }
        }
        else
        {
            // No active device. Playback is already fully stopped.
            Debug.WriteLine("[PlaybackService] InitiateStop: No active device found. Already stopped.");
        }

        // The state reset (CurrentSong = null etc.) is handled by OnPlaybackStopped for explicit stops.
        // For interruptions (Play called), the new Play() call handles setting the state.
    }

    /// <summary>
    /// Public method to stop playback completely and reset the current song state.
    /// </summary>
    public void Stop()
    {
        Debug.WriteLine("[PlaybackService] Public Stop() called.");
        _explicitStopRequested = true; // Signal user stop intention
        InitiateStop(); // Trigger the stop process
        // State reset (CurrentSong = null etc.) is handled by OnPlaybackStopped if it sees _explicitStopRequested == true.
        // The flag will be reset to false in OnPlaybackStopped after handling.
    }

    /// <summary>
    /// Seeks to a specific position in the current song.
    /// Respects active loop regions by snapping the target position if needed.
    /// </summary>
    /// <param name="requestedPosition">The desired time position.</param>
    public void Seek(TimeSpan requestedPosition)
    {
        // Check if there's a song loaded, audio file reader is initialized, and device is not stopped.
        // We need audioFileReader to get TotalTime and set CurrentTime.
        // We need _waveOutDevice to be non-null and not Stopped to ensure the reader is in a state where seeking is valid.
        if (audioFileReader == null || CurrentSong == null || _waveOutDevice?.PlaybackState == PlaybackState.Stopped)
        {
            Debug.WriteLine($"[PlaybackService] Seek ignored: No active audio file reader, current song, or device is stopped. AFR: {audioFileReader != null}, Song: {CurrentSong != null}, Device State: {_waveOutDevice?.PlaybackState}");
            return;
        }

        TimeSpan targetPosition = requestedPosition;

        // Apply loop region constraints if an active loop is defined for the current song.
        // If seeking *into* an active loop from *outside* its start or after its end, snap to start.
        // If seeking *within* an active loop, allow it.
        if (CurrentSong.IsLoopActive && CurrentSong.SavedLoop != null)
        {
            var loop = CurrentSong.SavedLoop;
            // Ensure loop end is after loop start and valid within total time
            if (loop.End > loop.Start && loop.End <= audioFileReader.TotalTime)
            {
                // If the target position is outside the loop's bounds [loop.Start, loop.End),
                // snap the target position to the loop's start time.
                if (targetPosition < loop.Start || targetPosition >= loop.End)
                {
                    Debug.WriteLine($"[PlaybackService] Seek: Loop active, target {targetPosition:mm\\:ss\\.ff} is outside loop [{loop.Start:mm\\:ss\\.ff}-{loop.End:mm\\:ss\\.ff}). Snapping to loop start: {loop.Start:mm\\:ss\\.ff}.");
                    targetPosition = loop.Start;
                }
                // If targetPosition is within [loop.Start, loop.End), allow normal seek within the loop.
            }
            else if (CurrentSong.IsLoopActive)
            {
                Debug.WriteLine($"[PlaybackService] Seek: Loop active but invalid region ({loop.Start:mm\\:ss\\.ff} - {loop.End:mm\\:ss\\.ff}). Not applying loop seek constraints.");
            }
        }

        // Clamp targetPosition to a valid range within the audio file's total duration.
        // Seeking exactly to TotalTime can sometimes cause issues with readers.
        // Subtract a small margin (e.g., 100ms) from the total time to get the maximum seekable position.
        // Ensure the margin doesn't make the max seekable position negative for very short files.
        var totalMs = audioFileReader.TotalTime.TotalMilliseconds;
        var seekMarginMs = totalMs > 200 ? 100 : (totalMs > 0 ? Math.Min(totalMs / 2, 50) : 0); // Subtract 100ms if over 200ms, or a smaller amount for shorter files, min 0
        var maxSeekablePosition = TimeSpan.FromMilliseconds(totalMs - seekMarginMs);
        // Ensure max seekable position is not less than zero.
        if (maxSeekablePosition < TimeSpan.Zero) maxSeekablePosition = TimeSpan.Zero;

        // Apply clamping to the target position
        targetPosition = TimeSpan.FromSeconds(Math.Clamp(targetPosition.TotalSeconds, 0, maxSeekablePosition.TotalSeconds));

        // Add a small tolerance check to avoid seeking if the target is very close to the current position.
        // This can reduce unnecessary operations from minor slider fluctuations and potentially prevent tight seeking loops.
        // The tolerance should be larger for manual seeks (like slider) than for internal loops.
        // Let's use a slightly larger tolerance for general seeking.
        double positionToleranceSeconds = 0.3; // 300 milliseconds tolerance

        try
        {
            // Safely get current time for tolerance check. Ensure audioFileReader is not null after clamping.
            if (audioFileReader != null)
            {
                TimeSpan currentAudioTimeForToleranceCheck = audioFileReader.CurrentTime;

                if (Math.Abs(currentAudioTimeForToleranceCheck.TotalSeconds - targetPosition.TotalSeconds) < positionToleranceSeconds)
                {
                    Debug.WriteLine($"[PlaybackService] Seek target {targetPosition:mm\\:ss\\.ff} is very close to current position {currentAudioTimeForToleranceCheck:mm\\:ss\\.ff} (within {positionToleranceSeconds}s), ignoring seek.");
                    // We don't explicitly update this.CurrentPosition here; it will be updated by the timer callback if playing.
                    return; // Skip the seek if within tolerance
                }
            }
            else
            {
                Debug.WriteLine($"[PlaybackService] Seek: audioFileReader is null during tolerance check. Proceeding with seek attempt.");
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[PlaybackService] Error checking current position for seek tolerance: {ex.Message}. Proceeding with seek.");
            // Ignore error in tolerance check, continue with seek
        }


        // Safely get current time for logging before seek
        string currentAudioTimeFormatted = "N/A";
        try
        {
            if (audioFileReader != null)
            {
                currentAudioTimeFormatted = $"{audioFileReader.CurrentTime:mm\\:ss\\.ff}";
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[PlaybackService] Error formatting current position for log before seek: {ex.Message}");
        }

        Debug.WriteLine($"[PlaybackService] Seeking AudioFileReader to: {targetPosition:mm\\:ss\\.ff}. Current AFR Time before seek: {currentAudioTimeFormatted}");

        // Perform the actual seek operation on the AudioFileReader.
        try
        {
            // Ensure audioFileReader is still valid before setting position
            if (audioFileReader != null)
            {
                audioFileReader.CurrentTime = targetPosition; // Set the position
                // Read back the position immediately after setting to get the actual position the reader moved to.
                this.CurrentPosition = audioFileReader.CurrentTime; // Update ViewModel property
                Debug.WriteLine($"[PlaybackService] Seek executed. AFR Time after seek: {audioFileReader.CurrentTime:mm\\:ss\\.ff}. VM Position: {this.CurrentPosition:mm\\:ss\\.ff}");
            }
            else
            {
                Debug.WriteLine($"[PlaybackService] Seek failed: audioFileReader is null after checks.");
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[PlaybackService] CRITICAL Error during Seek to {targetPosition:mm\\:ss\\.ff}: {ex.Message}");
            // Update VM position to reflect the last known good position, or zero on error
            // If audioFileReader is still valid, try to read current position after failed seek attempt.
            if (audioFileReader != null)
            {
                try { this.CurrentPosition = audioFileReader.CurrentTime; }
                catch (Exception readEx) { Debug.WriteLine($"[PlaybackService] Error reading position after failed seek: {readEx.Message}"); }
            }
            else
            {
                // If audioFileReader is null, set position to 0
                this.CurrentPosition = TimeSpan.Zero;
            }
            // Set state to stopped? No, let the PlaybackStopped handler or Play() handle state transitions.
        }
    }

    /// <summary>
    /// Disposes of managed and unmanaged resources used by the playback service.
    /// This should be called when the service is no longer needed (e.g., application shutdown).
    /// </summary>
    public void Dispose()
    {
        Debug.WriteLine("[PlaybackService] Dispose() called.");

        // Ensure timer is stopped and disposed
        uiUpdateTimer?.Dispose();
        uiUpdateTimer = null;

        // Clean up NAudio resources. This includes stopping the device and disposing the reader/device.
        // This also detaches the PlaybackStopped event handler *from the instance being disposed*.
        CleanUpNAudioResources();

        // Ensure the explicit stop flag is false
        _explicitStopRequested = false;

        // Explicitly clear state properties for completeness, although the service object itself is being disposed.
        CurrentSong = null;
        CurrentSongDuration = TimeSpan.Zero;
        this.CurrentPosition = TimeSpan.Zero;
        IsPlaying = false;
        CurrentPlaybackStatus = PlaybackStateStatus.Stopped;

        // No other disposable resources managed directly by PlaybackService currently.

        // Suppress finalization as Dispose has cleaned up resources.
        GC.SuppressFinalize(this);
        Debug.WriteLine("[PlaybackService] Dispose() completed.");
    }

    // Finalizer (destructor) as a safeguard to ensure Dispose is called if the object is not explicitly disposed.
    // Useful for unmanaged resources like audio devices, though our CleanUpNAudioResources handles the key parts.
    // Finalizers are generally discouraged unless strictly necessary due to performance overhead and complexity.
    // Our App's OnFrameworkInitializationCompleted manages the lifetime, so Dispose should be called explicitly.
    // Let's keep the finalizer as a safeguard, but rely on explicit Dispose.
    ~PlaybackService()
    {
        Debug.WriteLine("[PlaybackService] Finalizer called for PlaybackService.");
        // Call the public Dispose method.
        Dispose(); // Call the public Dispose method to perform cleanup
        Debug.WriteLine("[PlaybackService] Finalizer completed for PlaybackService.");
    }
}
</file>

<file path="Source\Services\SettingsService.cs">
using Sonorize.Models;
using System;
using System.IO;
using System.Text.Json;

namespace Sonorize.Services;

public class SettingsService
{
    private readonly string _settingsFilePath;

    public SettingsService()
    {
        var appDataPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
        var sonorizeAppDataPath = Path.Combine(appDataPath, "Sonorize");
        Directory.CreateDirectory(sonorizeAppDataPath); // Ensure directory exists
        _settingsFilePath = Path.Combine(sonorizeAppDataPath, "settings.json");
    }

    public AppSettings LoadSettings()
    {
        try
        {
            if (File.Exists(_settingsFilePath))
            {
                var json = File.ReadAllText(_settingsFilePath);
                return JsonSerializer.Deserialize<AppSettings>(json) ?? new AppSettings();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading settings: {ex.Message}");
            // Fallback to default settings
        }
        return new AppSettings();
    }

    public void SaveSettings(AppSettings settings)
    {
        try
        {
            var json = JsonSerializer.Serialize(settings, new JsonSerializerOptions { WriteIndented = true });
            File.WriteAllText(_settingsFilePath, json);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error saving settings: {ex.Message}");
        }
    }
}
</file>

<file path="Source\Services\ThemeService.cs">
using Sonorize.Models;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Diagnostics;

namespace Sonorize.Services;

public class ThemeService
{
    private readonly string _themesDirectory;
    public ThemeColors CurrentTheme { get; private set; }

    public const string DefaultThemeFileName = "DefaultTheme.json"; // Made public const
    private const string AmoledSpotifyThemeFileName = "AmoledSpotify.json";


    public ThemeService(string? preferredThemeNameFromSettings)
    {
        var appDataPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
        var sonorizeAppDataPath = Path.Combine(appDataPath, "Sonorize");
        _themesDirectory = Path.Combine(sonorizeAppDataPath, "Themes");
        Directory.CreateDirectory(_themesDirectory);

        EnsureDefaultThemesExist();

        string themeToLoad = DefaultThemeFileName; // Default to this one first

        if (!string.IsNullOrEmpty(preferredThemeNameFromSettings))
        {
            // Check if preferred theme exists
            if (File.Exists(Path.Combine(_themesDirectory, preferredThemeNameFromSettings)))
            {
                themeToLoad = preferredThemeNameFromSettings;
            }
            else
            {
                Debug.WriteLine($"[ThemeService] Preferred theme '{preferredThemeNameFromSettings}' not found. Falling back to default.");
            }
        }

        CurrentTheme = LoadThemeFromFile(themeToLoad);
        if (CurrentTheme == null) // If chosen (or default) theme failed, use hardcoded
        {
            Debug.WriteLine($"[ThemeService] Theme '{themeToLoad}' failed to load. Using hardcoded fallback (standard dark).");
            CurrentTheme = new ThemeColors(); // Hardcoded fallback (standard dark)
        }
        Debug.WriteLine($"[ThemeService] Current theme loaded: {themeToLoad} (BG: {CurrentTheme.BackgroundColor}, Accent: {CurrentTheme.AccentColor})");
    }

    private void EnsureDefaultThemesExist()
    {
        string defaultThemePath = Path.Combine(_themesDirectory, DefaultThemeFileName);
        if (!File.Exists(defaultThemePath))
        {
            SaveThemeToFile(new ThemeColors(), DefaultThemeFileName);
        }

        string amoledSpotifyThemePath = Path.Combine(_themesDirectory, AmoledSpotifyThemeFileName);
        if (!File.Exists(amoledSpotifyThemePath))
        {
            SaveThemeToFile(ThemeColors.CreateAmoledSpotifyTheme(), AmoledSpotifyThemeFileName);
        }
    }

    public ThemeColors? LoadThemeFromFile(string themeFileName)
    {
        // ... (LoadThemeFromFile remains the same as previous correct version) ...
        string filePath = Path.Combine(_themesDirectory, themeFileName);
        Debug.WriteLine($"[ThemeService] Attempting to load theme from: {filePath}");
        if (File.Exists(filePath))
        {
            try
            {
                var json = File.ReadAllText(filePath);
                var theme = JsonSerializer.Deserialize<ThemeColors>(json);
                if (theme != null)
                {
                    Debug.WriteLine($"[ThemeService] Theme '{themeFileName}' loaded successfully.");
                    return theme;
                }
                Debug.WriteLine($"[ThemeService] Failed to deserialize theme '{themeFileName}'. Json content was: {json.Substring(0, Math.Min(json.Length, 200))}");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[ThemeService] Error loading theme '{themeFileName}': {ex.Message}");
            }
        }
        else
        {
            Debug.WriteLine($"[ThemeService] Theme file not found: {filePath}");
        }
        return null;
    }

    public void SaveThemeToFile(ThemeColors theme, string themeFileName)
    {
        // ... (SaveThemeToFile remains the same as previous correct version) ...
        string filePath = Path.Combine(_themesDirectory, themeFileName);
        try
        {
            var options = new JsonSerializerOptions { WriteIndented = true };
            var json = JsonSerializer.Serialize(theme, options);
            File.WriteAllText(filePath, json);
            Debug.WriteLine($"[ThemeService] Theme '{themeFileName}' saved to: {filePath}");
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[ThemeService] Error saving theme '{themeFileName}': {ex.Message}");
        }
    }

    public List<string> GetAvailableThemeFiles()
    {
        if (!Directory.Exists(_themesDirectory))
        {
            return new List<string>();
        }
        return Directory.GetFiles(_themesDirectory, "*.json")
                        .Select(Path.GetFileName)
                        .Where(f => f != null) // Path.GetFileName can return null
                        .ToList()!; // Non-null asserted as we filter nulls
    }
}
</file>

<file path="Source\Services\WaveFormService.cs">
using Avalonia;
using NAudio.Wave;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Diagnostics;
using System.IO; // Required for Path.GetFileName

namespace Sonorize.Services;

// Represents a simplified data point for the waveform
public record WaveformPoint(double X, double YPeak);

public class WaveformService
{
    // Cache for waveform data to avoid reprocessing
    private readonly Dictionary<string, List<WaveformPoint>> _waveformCache = new();

    public async Task<List<WaveformPoint>> GetWaveformAsync(string filePath, int targetPoints)
    {
        if (string.IsNullOrEmpty(filePath) || targetPoints <= 0)
        {
            Debug.WriteLine($"[WaveformService] Invalid input: filePath is null/empty or targetPoints <= 0. File: '{filePath}', Points: {targetPoints}");
            return new List<WaveformPoint>();
        }

        // For debugging, temporarily disable cache to ensure fresh generation
        // if (_waveformCache.ContainsKey(filePath)) _waveformCache.Remove(filePath);

        if (_waveformCache.TryGetValue(filePath, out var cachedData))
        {
            Debug.WriteLine($"[WaveformService] Returning cached waveform for \"{Path.GetFileName(filePath)}\". Points: {cachedData.Count}");
            return cachedData;
        }

        Debug.WriteLine($"[WaveformService] Generating waveform for \"{Path.GetFileName(filePath)}\". Target points: {targetPoints}.");
        List<WaveformPoint> points = new List<WaveformPoint>();

        try
        {
            await Task.Run(() =>
            {
                using (var reader = new AudioFileReader(filePath))
                {
                    Debug.WriteLine($"[WaveformServiceReader] File: \"{Path.GetFileName(filePath)}\", TotalTime: {reader.TotalTime}, Channels: {reader.WaveFormat.Channels}, SampleRate: {reader.WaveFormat.SampleRate}, BitsPerSample: {reader.WaveFormat.BitsPerSample}, Encoding: {reader.WaveFormat.Encoding}, BlockAlign: {reader.WaveFormat.BlockAlign}, Length (bytes): {reader.Length}");

                    if (reader.WaveFormat.BlockAlign == 0)
                    {
                        Debug.WriteLine($"[WaveformServiceReader] File \"{Path.GetFileName(filePath)}\" has BlockAlign = 0. Cannot calculate total sample frames.");
                        return;
                    }

                    long totalSampleFrames = reader.Length / reader.WaveFormat.BlockAlign;

                    if (totalSampleFrames == 0)
                    {
                        Debug.WriteLine($"[WaveformServiceReader] File \"{Path.GetFileName(filePath)}\" has 0 sample frames (Length: {reader.Length}, BlockAlign: {reader.WaveFormat.BlockAlign}). Cannot generate waveform.");
                        return;
                    }

                    var samplesPerFrameToProcessPerPoint = (int)Math.Max(1, totalSampleFrames / targetPoints);
                    var bufferSizeInSamples = samplesPerFrameToProcessPerPoint * reader.WaveFormat.Channels;

                    if (bufferSizeInSamples == 0)
                    {
                        Debug.WriteLine($"[WaveformServiceReader] Calculated bufferSizeInSamples is 0 for \"{Path.GetFileName(filePath)}\". TotalSampleFrames: {totalSampleFrames}, TargetPoints: {targetPoints}, Channels: {reader.WaveFormat.Channels}, SamplesPerFrameToProcessPerPoint: {samplesPerFrameToProcessPerPoint}. Cannot generate.");
                        return;
                    }

                    var buffer = new float[bufferSizeInSamples];
                    int samplesReadFromAudioFile;
                    double currentX = 0;
                    double xIncrement = 1.0 / targetPoints;
                    int pointsGeneratedCount = 0;

                    Debug.WriteLine($"[WaveformServiceReader] Processing \"{Path.GetFileName(filePath)}\": TotalSampleFrames: {totalSampleFrames}, TargetPoints: {targetPoints}, SamplesPerFrameToProcessPerPoint: {samplesPerFrameToProcessPerPoint}, BufferSizeInFloats: {bufferSizeInSamples}");

                    for (int i = 0; i < targetPoints; i++)
                    {
                        float maxPeakInChunk = 0f;

                        samplesReadFromAudioFile = reader.Read(buffer, 0, buffer.Length);

                        if (samplesReadFromAudioFile == 0)
                        {
                            Debug.WriteLine($"[WaveformServiceReader] Read 0 samples at waveform point index {i} (target: {targetPoints}) for \"{Path.GetFileName(filePath)}\". End of audio stream reached.");
                            break;
                        }

                        for (int n = 0; n < samplesReadFromAudioFile; n++)
                        {
                            maxPeakInChunk = Math.Max(maxPeakInChunk, Math.Abs(buffer[n]));
                        }

                        points.Add(new WaveformPoint(currentX, maxPeakInChunk));
                        pointsGeneratedCount++;

                        if (i < 5 || (i > 0 && i % (targetPoints / 10) == 0) || i == targetPoints - 1)
                        {
                            Debug.WriteLine($"[WaveformServiceReader] Point {i}: X={currentX:F3}, Calculated YPeak={maxPeakInChunk:F4}, SamplesInThisChunk={samplesReadFromAudioFile}");
                        }

                        currentX += xIncrement;
                        if (currentX > 1.0) currentX = 1.0;
                    }
                    Debug.WriteLine($"[WaveformServiceReader] Loop finished for \"{Path.GetFileName(filePath)}\". Total waveform points generated: {pointsGeneratedCount}. (Target was {targetPoints})");
                }
            });

            if (points.Any())
            {
                _waveformCache[filePath] = points;
                Debug.WriteLine($"[WaveformService] Waveform generated and cached for \"{Path.GetFileName(filePath)}\", {points.Count} points. First point YPeak: {points[0].YPeak:F4}. Approx mid point YPeak: {points[points.Count / 2].YPeak:F4}. Last point YPeak: {points.Last().YPeak:F4}");
            }
            else
            {
                Debug.WriteLine($"[WaveformService] No points generated for \"{Path.GetFileName(filePath)}\". It might be too short, silent, or an issue with reading audio data.");
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[WaveformService] CRITICAL Error generating waveform for \"{Path.GetFileName(filePath)}\": {ex.ToString()}");
            return new List<WaveformPoint>();
        }
        return points;
    }

    public void ClearCache()
    {
        _waveformCache.Clear();
        Debug.WriteLine("[WaveformService] Cache cleared.");
    }
}
</file>

<file path="Source\Utils\AlbumArtistTupleComparer.cs">
// Path: Source/Utils/AlbumArtistTupleComparer.cs (or a similar appropriate location)
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis; // For NotNullWhen attribute

namespace Sonorize.Utils; // Or your preferred namespace for utility classes

public class AlbumArtistTupleComparer : IEqualityComparer<(string Album, string Artist)>
{
    public bool Equals((string Album, string Artist) x, (string Album, string Artist) y)
    {
        return string.Equals(x.Album, y.Album, StringComparison.OrdinalIgnoreCase) &&
               string.Equals(x.Artist, y.Artist, StringComparison.OrdinalIgnoreCase);
    }

    public int GetHashCode([DisallowNull] (string Album, string Artist) obj)
    {
        // Combine hash codes in a way that's sensitive to order and case-insensitivity
        // For case-insensitivity in hash code, convert to a consistent case first
        int albumHashCode = obj.Album?.ToLowerInvariant().GetHashCode() ?? 0;
        int artistHashCode = obj.Artist?.ToLowerInvariant().GetHashCode() ?? 0;
        return HashCode.Combine(albumHashCode, artistHashCode);
    }

    // Static instance for convenience
    public static readonly AlbumArtistTupleComparer Instance = new AlbumArtistTupleComparer();
}
</file>

<file path="Source\ViewModels\AlbumViewModel.cs">
using Avalonia.Media.Imaging;
using System.Collections.Generic; // For List
// Removed System.Collections.ObjectModel as List is sufficient here and ViewModelBase handles INPC

namespace Sonorize.ViewModels;

public class AlbumViewModel : ViewModelBase
{
    public string? Title { get; set; }
    public string? Artist { get; set; }

    private List<Bitmap?> _songThumbnailsForGrid = new List<Bitmap?>(new Bitmap?[4]); // Ensures 4 elements, can be null
    public List<Bitmap?> SongThumbnailsForGrid
    {
        get => _songThumbnailsForGrid;
        // Setter might be used by LibraryVM during initialization
        set => SetProperty(ref _songThumbnailsForGrid, value);
    }

    private Bitmap? _representativeThumbnail;
    public Bitmap? RepresentativeThumbnail
    {
        get => _representativeThumbnail;
        set => SetProperty(ref _representativeThumbnail, value);
    }

    public string DisplayText => $"{Title} - {Artist}";
}
</file>

<file path="Source\ViewModels\ArtistViewModel.cs">
using Avalonia.Media.Imaging;

namespace Sonorize.ViewModels;

public class ArtistViewModel
{
    public string? Name { get; set; }
    public Bitmap? Thumbnail { get; set; }
    // You could add more properties later, like SongCount or AlbumCount
}
</file>

<file path="Source\ViewModels\LibraryViewModel.cs">
using Avalonia.Media.Imaging;
using Avalonia.Threading;
using Sonorize.Models;
using Sonorize.Services;
using Sonorize.Utils;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Input;

namespace Sonorize.ViewModels;

public enum SongDisplayMode
{
    Detailed,
    Compact,
    Grid
}

public class LibraryViewModel : ViewModelBase
{
    private readonly SettingsService _settingsService;
    private readonly MusicLibraryService _musicLibraryService;
    private readonly LoopDataService _loopDataService;

    private readonly ObservableCollection<Song> _allSongs = new();
    public ObservableCollection<Song> FilteredSongs { get; } = new();
    public ObservableCollection<ArtistViewModel> Artists { get; } = new();
    public ObservableCollection<AlbumViewModel> Albums { get; } = new();

    private string _searchQuery = string.Empty;
    public string SearchQuery { get => _searchQuery; set { if (SetProperty(ref _searchQuery, value)) ApplyFilter(); } }

    private Song? _selectedSongInternal;
    public Song? SelectedSong
    {
        get => _selectedSongInternal;
        set
        {
            if (SetProperty(ref _selectedSongInternal, value))
            {
                Debug.WriteLine($"[LibraryVM] SelectedSong changed to: {value?.Title ?? "null"}");
                // Raise CanExecuteChanged for navigation commands when selection changes
                RaiseNavigationCommandsCanExecuteChanged();
            }
        }
    }

    private ArtistViewModel? _selectedArtist;
    public ArtistViewModel? SelectedArtist
    {
        get => _selectedArtist;
        set
        {
            if (SetProperty(ref _selectedArtist, value))
            {
                if (value != null)
                {
                    OnArtistSelected(value);
                }
                else
                {
                    SearchQuery = string.Empty;
                    ApplyFilter();
                }
            }
        }
    }

    private AlbumViewModel? _selectedAlbum;
    public AlbumViewModel? SelectedAlbum
    {
        get => _selectedAlbum;
        set
        {
            if (SetProperty(ref _selectedAlbum, value))
            {
                if (value != null)
                {
                    OnAlbumSelected(value);
                }
                else
                {
                    SearchQuery = string.Empty;
                    ApplyFilter();
                }
            }
        }
    }

    private bool _isLoadingLibrary = false;
    public bool IsLoadingLibrary
    {
        get => _isLoadingLibrary;
        private set { if (SetProperty(ref _isLoadingLibrary, value)) RaiseLibraryCommandsCanExecuteChanged(); }
    }

    private string _libraryStatusText = "";
    public string LibraryStatusText { get => _libraryStatusText; private set => SetProperty(ref _libraryStatusText, value); }

    private SongDisplayMode _libraryViewMode;
    public SongDisplayMode LibraryViewMode
    {
        get => _libraryViewMode;
        set
        {
            if (SetProperty(ref _libraryViewMode, value))
            {
                var settings = _settingsService.LoadSettings();
                settings.LibraryViewModePreference = value.ToString();
                _settingsService.SaveSettings(settings);
            }
        }
    }

    private SongDisplayMode _artistViewMode;
    public SongDisplayMode ArtistViewMode
    {
        get => _artistViewMode;
        set
        {
            if (SetProperty(ref _artistViewMode, value))
            {
                var settings = _settingsService.LoadSettings();
                settings.ArtistViewModePreference = value.ToString();
                _settingsService.SaveSettings(settings);
            }
        }
    }

    private SongDisplayMode _albumViewMode;
    public SongDisplayMode AlbumViewMode
    {
        get => _albumViewMode;
        set
        {
            if (SetProperty(ref _albumViewMode, value))
            {
                var settings = _settingsService.LoadSettings();
                settings.AlbumViewModePreference = value.ToString();
                _settingsService.SaveSettings(settings);
            }
        }
    }

    public ICommand SetDisplayModeCommand { get; }

    // Navigation Commands
    public ICommand PreviousTrackCommand { get; }
    public ICommand NextTrackCommand { get; }


    public LibraryViewModel(SettingsService settingsService, MusicLibraryService musicLibraryService, LoopDataService loopDataService)
    {
        _settingsService = settingsService;
        _musicLibraryService = musicLibraryService;
        _loopDataService = loopDataService;

        // Load preferences
        var appSettings = _settingsService.LoadSettings();
        _libraryViewMode = Enum.TryParse<SongDisplayMode>(appSettings.LibraryViewModePreference, out var libMode) ? libMode : SongDisplayMode.Detailed;
        _artistViewMode = Enum.TryParse<SongDisplayMode>(appSettings.ArtistViewModePreference, out var artMode) ? artMode : SongDisplayMode.Detailed;
        _albumViewMode = Enum.TryParse<SongDisplayMode>(appSettings.AlbumViewModePreference, out var albMode) ? albMode : SongDisplayMode.Detailed;


        SetDisplayModeCommand = new RelayCommand(
            param =>
            {
                if (param is (string targetView, SongDisplayMode mode))
                {
                    switch (targetView)
                    {
                        // Setters will handle saving
                        case "Library": LibraryViewMode = mode; break;
                        case "Artists": ArtistViewMode = mode; break;
                        case "Albums": AlbumViewMode = mode; break;
                    }
                }
            },
            _ => true
        );

        // Initialize Navigation Commands
        PreviousTrackCommand = new RelayCommand(ExecutePreviousTrack, CanExecutePreviousTrack);
        NextTrackCommand = new RelayCommand(ExecuteNextTrack, CanExecuteNextTrack);

        // Subscribe to FilteredSongs changes to update navigation command states
        FilteredSongs.CollectionChanged += (sender, e) => RaiseNavigationCommandsCanExecuteChanged();

        UpdateStatusBarText();
    }

    private void ExecutePreviousTrack(object? parameter)
    {
        if (SelectedSong == null || !FilteredSongs.Any()) return;

        var currentIndex = FilteredSongs.IndexOf(SelectedSong);
        if (currentIndex > 0)
        {
            SelectedSong = FilteredSongs[currentIndex - 1];
            Debug.WriteLine($"[LibraryVM] Moved to previous track: {SelectedSong.Title}");
        }
        else
        {
            Debug.WriteLine("[LibraryVM] Already at the first track.");
            // Optionally loop to the last track: SelectedSong = FilteredSongs.Last();
        }
    }

    private bool CanExecutePreviousTrack(object? parameter)
    {
        if (SelectedSong == null || !FilteredSongs.Any()) return false;
        return FilteredSongs.IndexOf(SelectedSong) > 0;
    }

    private void ExecuteNextTrack(object? parameter)
    {
        if (SelectedSong == null || !FilteredSongs.Any()) return;

        var currentIndex = FilteredSongs.IndexOf(SelectedSong);
        if (currentIndex < FilteredSongs.Count - 1 && currentIndex != -1)
        {
            SelectedSong = FilteredSongs[currentIndex + 1];
            Debug.WriteLine($"[LibraryVM] Moved to next track: {SelectedSong.Title}");
        }
        else if (currentIndex != -1) // Already at the last track
        {
            Debug.WriteLine("[LibraryVM] Already at the last track.");
            // Optionally loop to the first track: SelectedSong = FilteredSongs.First();
        }
        else // Selected song not found in filtered list - should not happen if SelectedSong is non-null and FilteredSongs contains it
        {
            Debug.WriteLine("[LibraryVM] Selected song not found in filtered list.");
        }
    }

    private bool CanExecuteNextTrack(object? parameter)
    {
        if (SelectedSong == null || !FilteredSongs.Any()) return false;
        var currentIndex = FilteredSongs.IndexOf(SelectedSong);
        return currentIndex != -1 && currentIndex < FilteredSongs.Count - 1;
    }


    public async Task LoadLibraryAsync()
    {
        if (IsLoadingLibrary) return;

        IsLoadingLibrary = true;
        SearchQuery = string.Empty;

        await Dispatcher.UIThread.InvokeAsync(() => {
            SelectedSong = null;
            Artists.Clear();
            Albums.Clear();
            FilteredSongs.Clear();
            _allSongs.Clear();
            LibraryStatusText = "Preparing to load music...";
        });

        var settings = _settingsService.LoadSettings();
        if (!settings.MusicDirectories.Any())
        {
            await Dispatcher.UIThread.InvokeAsync(() => {
                LibraryStatusText = "No music directories configured.";
            });
        }
        else
        {
            try
            {
                await Task.Run(async () => {
                    await _musicLibraryService.LoadMusicFromDirectoriesAsync(
                        settings.MusicDirectories,
                        song => Dispatcher.UIThread.InvokeAsync(() => _allSongs.Add(song)),
                        s => Dispatcher.UIThread.InvokeAsync(() => LibraryStatusText = s));
                });

                await Dispatcher.UIThread.InvokeAsync(() => {
                    Artists.Clear();
                    var uniqueArtistNames = _allSongs
                        .Where(s => !string.IsNullOrWhiteSpace(s.Artist))
                        .Select(s => s.Artist!)
                        .Distinct(StringComparer.OrdinalIgnoreCase)
                        .OrderBy(a => a, StringComparer.OrdinalIgnoreCase)
                        .ToList();
                    Bitmap? defaultSongThumbnail = _musicLibraryService.GetDefaultThumbnail();
                    foreach (var artistName in uniqueArtistNames)
                    {
                        Bitmap? repThumb = _allSongs.FirstOrDefault(s => (s.Artist?.Equals(artistName, StringComparison.OrdinalIgnoreCase) ?? false) && s.Thumbnail != null)?.Thumbnail ?? defaultSongThumbnail;
                        Artists.Add(new ArtistViewModel { Name = artistName, Thumbnail = repThumb });
                    }
                    OnPropertyChanged(nameof(Artists));

                    Albums.Clear();
                    Func<Song, (string Album, string Artist)> keySelector = s => (s.Album?.Trim() ?? string.Empty, s.Artist?.Trim() ?? string.Empty);
                    var uniqueAlbumsData = _allSongs
                        .Where(s => !string.IsNullOrWhiteSpace(s.Album) && !string.IsNullOrWhiteSpace(s.Artist))
                        .GroupBy(keySelector, AlbumArtistTupleComparer.Instance)
                        .Select(g => new
                        {
                            AlbumTitle = g.Key.Item1,
                            ArtistName = g.Key.Item2,
                            SongsInAlbum = g.ToList()
                        })
                        .OrderBy(a => a.ArtistName, StringComparer.OrdinalIgnoreCase).ThenBy(a => a.AlbumTitle, StringComparer.OrdinalIgnoreCase)
                        .ToList();

                    foreach (var albumData in uniqueAlbumsData)
                    {
                        var albumVM = new AlbumViewModel
                        {
                            Title = albumData.AlbumTitle,
                            Artist = albumData.ArtistName
                        };

                        var songThumbnailsForGrid = new List<Bitmap?>(new Bitmap?[4]);
                        var distinctSongThumbs = albumData.SongsInAlbum
                                                     .Select(s => s.Thumbnail ?? defaultSongThumbnail)
                                                     .Distinct()
                                                     .Take(4)
                                                     .ToList();

                        for (int i = 0; i < distinctSongThumbs.Count; i++)
                        {
                            songThumbnailsForGrid[i] = distinctSongThumbs[i];
                        }
                        albumVM.SongThumbnailsForGrid = songThumbnailsForGrid;

                        albumVM.RepresentativeThumbnail = songThumbnailsForGrid[0] ?? defaultSongThumbnail;

                        Albums.Add(albumVM);
                    }
                    OnPropertyChanged(nameof(Albums));

                    ApplyFilter(); // This will populate FilteredSongs and trigger RaiseNavigationCommandsCanExecuteChanged

                    UpdateStatusBarText();
                });
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[LibraryVM] Error loading library: {ex}");
                await Dispatcher.UIThread.InvokeAsync(() => LibraryStatusText = "Error loading music library.");
            }
        }
        IsLoadingLibrary = false;
    }

    private void OnArtistSelected(ArtistViewModel artist)
    {
        if (artist?.Name == null) return;
        Debug.WriteLine($"[LibraryVM] Artist selected: {artist.Name}");
        SearchQuery = artist.Name;
        // ApplyFilter will be called by SearchQuery setter, which updates FilteredSongs
    }

    private void OnAlbumSelected(AlbumViewModel album)
    {
        if (album?.Title == null || album.Artist == null) return;
        Debug.WriteLine($"[LibraryVM] Album selected: {album.Title} by {album.Artist}");
        SearchQuery = string.Empty; // Clear search query when selecting album

        FilteredSongs.Clear();
        var songsInAlbum = _allSongs.Where(s =>
            s.Album.Equals(album.Title, StringComparison.OrdinalIgnoreCase) &&
            s.Artist.Equals(album.Artist, StringComparison.OrdinalIgnoreCase))
            .OrderBy(s => s.Title, StringComparer.OrdinalIgnoreCase);

        foreach (var song in songsInAlbum)
        {
            FilteredSongs.Add(song);
        }
        if (SelectedSong != null && !FilteredSongs.Contains(SelectedSong))
        {
            SelectedSong = null; // Clear selection if the previously selected song is not in this album
        }
        UpdateStatusBarText();
        RaiseNavigationCommandsCanExecuteChanged(); // FilteredSongs changed
    }

    private void ApplyFilter()
    {
        FilteredSongs.Clear();
        var songsToFilter = _allSongs.AsEnumerable();

        if (!string.IsNullOrWhiteSpace(SearchQuery))
        {
            var query = SearchQuery.ToLowerInvariant().Trim();
            songsToFilter = songsToFilter.Where(s =>
                (s.Title?.ToLowerInvariant().Contains(query) ?? false) ||
                (s.Artist?.ToLowerInvariant().Contains(query) ?? false) ||
                (s.Album?.ToLowerInvariant().Contains(query) ?? false));
        }

        songsToFilter = songsToFilter.OrderBy(s => s.Title, StringComparer.OrdinalIgnoreCase);

        foreach (var song in songsToFilter)
        {
            FilteredSongs.Add(song);
        }
        // If the currently selected song is no longer in the filtered list, clear selection.
        // This is important for playback state synchronization.
        if (SelectedSong != null && !FilteredSongs.Contains(SelectedSong))
        {
            Debug.WriteLine($"[LibraryVM] Selected song '{SelectedSong.Title}' is no longer in the filtered list. Clearing selection.");
            SelectedSong = null; // Clearing SelectedSong will trigger its PropertyChanged handler
        }
        else if (SelectedSong != null && FilteredSongs.Contains(SelectedSong))
        {
            // If the selected song is still in the list, its index might have changed.
            // Need to re-evaluate navigation commands.
            RaiseNavigationCommandsCanExecuteChanged();
        }
        // If SelectedSong is null, this filter application didn't select one,
        // and RaiseNavigationCommandsCanExecuteChanged is called because FilteredSongs changed.

        UpdateStatusBarText();
        // Navigation commands also depend on FilteredSongs changing
        RaiseNavigationCommandsCanExecuteChanged();
    }

    public void UpdateStatusBarText()
    {
        if (IsLoadingLibrary) return;

        string status;
        if (_allSongs.Count == 0)
        {
            var settings = _settingsService.LoadSettings();
            if (!settings.MusicDirectories.Any())
            {
                status = "Library empty. Add directories via File menu.";
            }
            else
            {
                status = "No songs found in configured directories.";
            }
        }
        else if (!string.IsNullOrWhiteSpace(SearchQuery) || SelectedAlbum != null || SelectedArtist != null)
        {
            status = $"{FilteredSongs.Count} of {_allSongs.Count} songs displayed.";
        }
        else
        {
            status = $"{_allSongs.Count} songs in library.";
        }
        LibraryStatusText = status;
    }


    public void RaiseLibraryCommandsCanExecuteChanged()
    {
        (SetDisplayModeCommand as RelayCommand)?.RaiseCanExecuteChanged();
        // Navigation commands are handled by RaiseNavigationCommandsCanExecuteChanged
    }

    public void RaiseNavigationCommandsCanExecuteChanged()
    {
        //Debug.WriteLine("[LibraryVM] Raising navigation command CanExecute changed.");
        (PreviousTrackCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (NextTrackCommand as RelayCommand)?.RaiseCanExecuteChanged();
    }
}
</file>

<file path="Source\ViewModels\LoopEditorViewModel.cs">
using Sonorize.Models;
using Sonorize.Services;
using System;
using System.Diagnostics;
using System.Windows.Input;
using Avalonia.Threading; // Required for Dispatcher

namespace Sonorize.ViewModels;

public class LoopEditorViewModel : ViewModelBase
{
    private readonly PlaybackService _playbackService;
    private readonly LoopDataService _loopDataService;
    private Song? _currentSongInternal; // Holds the Song instance from PlaybackService.CurrentSong

    private TimeSpan? _newLoopStartCandidate;
    public TimeSpan? NewLoopStartCandidate
    {
        get => _newLoopStartCandidate;
        set { SetProperty(ref _newLoopStartCandidate, value); OnPropertyChanged(nameof(CanSaveLoopRegion)); OnPropertyChanged(nameof(NewLoopStartCandidateDisplay)); }
    }

    private TimeSpan? _newLoopEndCandidate;
    public TimeSpan? NewLoopEndCandidate
    {
        get => _newLoopEndCandidate;
        set { SetProperty(ref _newLoopEndCandidate, value); OnPropertyChanged(nameof(CanSaveLoopRegion)); OnPropertyChanged(nameof(NewLoopEndCandidateDisplay)); }
    }

    public string NewLoopStartCandidateDisplay => _newLoopStartCandidate.HasValue ? $"{_newLoopStartCandidate.Value:mm\\:ss\\.ff}" : "Not set";
    public string NewLoopEndCandidateDisplay => _newLoopEndCandidate.HasValue ? $"{_newLoopEndCandidate.Value:mm\\:ss\\.ff}" : "Not set";

    private string _activeLoopDisplayText = "No loop defined.";
    public string ActiveLoopDisplayText { get => _activeLoopDisplayText; set => SetProperty(ref _activeLoopDisplayText, value); }

    private bool _isCurrentLoopActiveUiBinding;
    public bool IsCurrentLoopActiveUiBinding
    {
        get => _isCurrentLoopActiveUiBinding;
        set
        {
            // Only set if different to avoid unnecessary property changed events and potential recursion
            if (SetProperty(ref _isCurrentLoopActiveUiBinding, value))
            {
                if (_currentSongInternal != null && _currentSongInternal.SavedLoop != null)
                {
                    // Update the underlying model property. The model's PropertyChanged handler
                    // will trigger persistence logic in the main VM or here if needed.
                    _currentSongInternal.IsLoopActive = value;
                    Debug.WriteLine($"[LoopEdVM] UI binding set IsLoopActive on Song '{_currentSongInternal.Title}' to: {value}");
                }
                else if (_currentSongInternal != null && _currentSongInternal.SavedLoop == null && value == true)
                {
                    // Prevent activating loop if none is defined, revert UI state
                    _isCurrentLoopActiveUiBinding = false;
                    OnPropertyChanged(nameof(IsCurrentLoopActiveUiBinding)); // Notify UI to revert
                    Debug.WriteLine($"[LoopEdVM] Attempted to activate loop via UI, but no loop is defined for {_currentSongInternal.Title}.");
                }
                // If _currentSongInternal is null, setting _isCurrentLoopActiveUiBinding to false is handled by UpdateStateForCurrentSong(null)
            }
        }
    }


    public bool CanSaveLoopRegion => _currentSongInternal != null
                                     && NewLoopStartCandidate.HasValue
                                     && NewLoopEndCandidate.HasValue
                                     && NewLoopEndCandidate.Value > NewLoopStartCandidate.Value
                                     && _currentSongInternal.Duration.TotalSeconds > 0 // Need duration for comparison
                                     && NewLoopEndCandidate.Value <= _currentSongInternal.Duration
                                     && NewLoopStartCandidate.Value >= TimeSpan.Zero;

    public ICommand CaptureLoopStartCandidateCommand { get; }
    public ICommand CaptureLoopEndCandidateCommand { get; }
    public ICommand SaveLoopCommand { get; }
    public ICommand ClearLoopCommand { get; }
    public ICommand ToggleLoopActiveCommand { get; }
    public ICommand WaveformSeekCommand { get; }


    public LoopEditorViewModel(PlaybackService playbackService, LoopDataService loopDataService)
    {
        _playbackService = playbackService;
        _loopDataService = loopDataService;

        CaptureLoopStartCandidateCommand = new RelayCommand(
            _ => NewLoopStartCandidate = _playbackService.CurrentPosition,
            _ => _currentSongInternal != null && _playbackService.CurrentPlaybackStatus != PlaybackStateStatus.Stopped);

        CaptureLoopEndCandidateCommand = new RelayCommand(
            _ => NewLoopEndCandidate = _playbackService.CurrentPosition,
            _ => _currentSongInternal != null && _playbackService.CurrentPlaybackStatus != PlaybackStateStatus.Stopped);

        SaveLoopCommand = new RelayCommand(SaveLoopAction, _ => CanSaveLoopRegion);

        ClearLoopCommand = new RelayCommand(ClearSavedLoopAction, _ => _currentSongInternal?.SavedLoop != null);

        ToggleLoopActiveCommand = new RelayCommand(ToggleCurrentSongLoopActive, _ => _currentSongInternal?.SavedLoop != null);

        // WaveformSeekCommand is needed here as it interacts directly with the playback position based on a UI event
        WaveformSeekCommand = new RelayCommand(
            timeSpanObj => { if (timeSpanObj is TimeSpan ts && _currentSongInternal != null) _playbackService.Seek(ts); },
            _ => _currentSongInternal != null);


        // Listen to PlaybackService property changes relevant to loop editing state
        _playbackService.PropertyChanged += PlaybackService_PropertyChanged;

        // Initial state update
        UpdateStateForCurrentSong(_playbackService.CurrentSong);
    }

    private void PlaybackService_PropertyChanged(object? sender, System.ComponentModel.PropertyChangedEventArgs e)
    {
        Dispatcher.UIThread.InvokeAsync(() =>
        {
            switch (e.PropertyName)
            {
                case nameof(PlaybackService.CurrentSong):
                    Debug.WriteLine($"[LoopEdVM] PlaybackService.CurrentSong changed to: {_playbackService.CurrentSong?.Title ?? "null"}. Updating loop state.");
                    // Remove handler from old song
                    if (_currentSongInternal != null)
                    {
                        _currentSongInternal.PropertyChanged -= CurrentSong_PropertyChanged;
                    }
                    // Update internal song reference
                    _currentSongInternal = _playbackService.CurrentSong;
                    // Add handler to new song if not null
                    if (_currentSongInternal != null)
                    {
                        _currentSongInternal.PropertyChanged += CurrentSong_PropertyChanged;
                    }
                    UpdateStateForCurrentSong(_currentSongInternal);
                    break;
                case nameof(PlaybackService.CurrentPosition):
                case nameof(PlaybackService.CurrentSongDuration):
                    // These affect CanSaveLoopRegion and command CanExecute states
                    OnPropertyChanged(nameof(CanSaveLoopRegion));
                    RaiseLoopCommandCanExecuteChanged();
                    // Also need to update loop display text if CurrentSong or its Loop property isn't triggering it
                    UpdateActiveLoopDisplayText(); // Ensure text reflects active loop status
                    break;
                case nameof(PlaybackService.CurrentPlaybackStatus):
                    // Affects Capture command CanExecute
                    RaiseLoopCommandCanExecuteChanged();
                    break;
            }
        });
    }

    private void CurrentSong_PropertyChanged(object? sender, System.ComponentModel.PropertyChangedEventArgs e)
    {
        Dispatcher.UIThread.InvokeAsync(() =>
        {
            // Listen for changes on the *Song model itself* relevant to loop state
            if (sender is Song song && song == _currentSongInternal)
            {
                switch (e.PropertyName)
                {
                    case nameof(Song.SavedLoop):
                        Debug.WriteLine($"[LoopEdVM] CurrentSong.SavedLoop changed for {song.Title}. Updating loop state.");
                        UpdateStateForCurrentSong(song); // Fully refresh state based on the new loop
                        break;
                    case nameof(Song.IsLoopActive):
                        Debug.WriteLine($"[LoopEdVM] CurrentSong.IsLoopActive changed to {song.IsLoopActive} for {song.Title}. Updating UI binding and persisting.");
                        // Update the UI binding property if it's out of sync
                        if (_isCurrentLoopActiveUiBinding != song.IsLoopActive)
                        {
                            _isCurrentLoopActiveUiBinding = song.IsLoopActive;
                            OnPropertyChanged(nameof(IsCurrentLoopActiveUiBinding));
                        }
                        // Persist the active state change
                        if (song.SavedLoop != null)
                        {
                            _loopDataService.UpdateLoopActiveState(song.FilePath, song.IsLoopActive);
                        }
                        UpdateActiveLoopDisplayText(); // Update the display text
                        break;
                        // Add other relevant song properties if they affect loop state UI
                }
            }
        });
    }

    private void UpdateStateForCurrentSong(Song? song)
    {
        // This method syncs the LoopEditorViewModel's state with the current song's state
        Debug.WriteLine($"[LoopEdVM] UpdateStateForCurrentSong called for: {song?.Title ?? "null"}");
        if (song?.SavedLoop != null)
        {
            NewLoopStartCandidate = song.SavedLoop.Start;
            NewLoopEndCandidate = song.SavedLoop.End;
            IsCurrentLoopActiveUiBinding = song.IsLoopActive; // Sync UI binding
        }
        else
        {
            NewLoopStartCandidate = null;
            NewLoopEndCandidate = null;
            IsCurrentLoopActiveUiBinding = false; // Ensure binding is false when no loop
        }
        UpdateActiveLoopDisplayText();
        OnPropertyChanged(nameof(CanSaveLoopRegion));
        RaiseLoopCommandCanExecuteChanged();
    }

    private void ClearLoopCandidateInputs()
    {
        NewLoopStartCandidate = null;
        NewLoopEndCandidate = null;
        Debug.WriteLine("[LoopEdVM] Loop candidates cleared.");
    }

    private void SaveLoopAction(object? param)
    {
        var currentSong = _currentSongInternal;
        if (!CanSaveLoopRegion || currentSong == null || !NewLoopStartCandidate.HasValue || !NewLoopEndCandidate.HasValue)
        {
            Debug.WriteLine("[LoopEdVM] SaveLoopAction skipped: conditions not met.");
            return;
        }

        var newLoop = new LoopRegion(NewLoopStartCandidate.Value, NewLoopEndCandidate.Value, "User Loop");

        // Determine the desired active state for the new loop:
        // - If there was a loop before and it was active, the new one should also be active.
        // - If there was no loop before, setting a new one implies it should be active.
        // - If there was a loop before and it was *in*active, keep the new one inactive initially.
        bool shouldBeActive = (currentSong.SavedLoop != null && currentSong.IsLoopActive) || currentSong.SavedLoop == null;

        currentSong.SavedLoop = newLoop; // This might trigger Song's PropertyChanged -> LoopEditorViewModel.CurrentSong_PropertyChanged -> UpdateStateForCurrentSong

        // Set IsLoopActive *after* setting SavedLoop to potentially trigger the right logic flow
        // If the desired state is different from the current Song.IsLoopActive, set it.
        // If it's the same, explicitly trigger the persistence call as the Song.IsLoopActive setter might not fire PropertyChanged
        if (currentSong.IsLoopActive != shouldBeActive)
        {
            currentSong.IsLoopActive = shouldBeActive; // This should trigger persistence via CurrentSong_PropertyChanged
        }
        else
        {
            // State is the same, manually trigger persistence
            _loopDataService.SetLoop(currentSong.FilePath, newLoop.Start, newLoop.End, currentSong.IsLoopActive);
        }

        Debug.WriteLine($"[LoopEdVM] Loop saved for {currentSong.Title}. Start: {newLoop.Start}, End: {newLoop.End}, Active: {currentSong.IsLoopActive}");

        // Update UI state might be redundant if triggered by CurrentSong_PropertyChanged, but safe
        UpdateStateForCurrentSong(currentSong);
    }


    private void ClearSavedLoopAction(object? param)
    {
        var currentSong = _currentSongInternal;
        if (currentSong != null)
        {
            var filePath = currentSong.FilePath;
            Debug.WriteLine($"[LoopEdVM] Clearing loop for {currentSong.Title}.");
            currentSong.SavedLoop = null; // This might trigger Song's PropertyChanged
            currentSong.IsLoopActive = false; // This might trigger Song's PropertyChanged
            if (!string.IsNullOrEmpty(filePath))
            {
                _loopDataService.ClearLoop(filePath);
            }
        }
        ClearLoopCandidateInputs();
        UpdateStateForCurrentSong(currentSong); // Ensure UI syncs after clearing
    }

    private void ToggleCurrentSongLoopActive(object? parameter)
    {
        if (_currentSongInternal != null && _currentSongInternal.SavedLoop != null)
        {
            Debug.WriteLine($"[LoopEdVM] Toggling loop active state for {_currentSongInternal.Title}. Current: {_currentSongInternal.IsLoopActive}");
            // Toggling IsCurrentLoopActiveUiBinding will flow back through its setter
            IsCurrentLoopActiveUiBinding = !_isCurrentLoopActiveUiBinding;
        }
    }

    private void UpdateActiveLoopDisplayText()
    {
        var currentSong = _currentSongInternal;
        if (currentSong?.SavedLoop != null)
        {
            var loop = currentSong.SavedLoop;
            string activeStatus = currentSong.IsLoopActive ? " (Active)" : " (Inactive)";
            ActiveLoopDisplayText = $"Loop: {loop.Start:mm\\:ss\\.f} - {loop.End:mm\\:ss\\.f}{activeStatus}";
        }
        else
        {
            ActiveLoopDisplayText = "No loop defined.";
        }
    }

    public void RaiseLoopCommandCanExecuteChanged()
    {
        (CaptureLoopStartCandidateCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (CaptureLoopEndCandidateCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (SaveLoopCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (ClearLoopCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (ToggleLoopActiveCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (WaveformSeekCommand as RelayCommand)?.RaiseCanExecuteChanged();
    }
}
</file>

<file path="Source\ViewModels\MainWindowViewModel.cs">
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Input;
using Avalonia.Controls;
using Avalonia.Media.Imaging;
using Avalonia.Platform.Storage;
using Avalonia.Threading;
using Sonorize.Models;
using Sonorize.Services;
using Sonorize.Utils;
using System.IO; // Required for Path.GetFullPath, Directory.Exists
using System.Collections.Generic; // Required for List
using System.Security.Cryptography; // Required for shuffle randomization
using System.Runtime.InteropServices; // Required for Marshal.Copy

namespace Sonorize.ViewModels;

public class MainWindowViewModel : ViewModelBase
{
    private readonly SettingsService _settingsService;
    private readonly MusicLibraryService _musicLibraryService;
    private readonly WaveformService _waveformService;
    private readonly LoopDataService _loopDataService;

    // Expose the Services directly for child VMs or public properties
    public PlaybackService PlaybackService { get; }
    public ThemeColors CurrentTheme { get; }

    // Expose the child ViewModels
    public LibraryViewModel Library { get; set; }
    public LoopEditorViewModel LoopEditor { get; }
    public PlaybackViewModel Playback { get; } // Playback ViewModel

    private string _statusBarText = "Welcome to Sonorize!";
    public string StatusBarText { get => _statusBarText; set => SetProperty(ref _statusBarText, value); }

    // IsLoadingLibrary is a proxy to Library's state
    public bool IsLoadingLibrary { get => Library.IsLoadingLibrary; }

    private bool _isAdvancedPanelVisible;
    public bool IsAdvancedPanelVisible { get => _isAdvancedPanelVisible; set { if (SetProperty(ref _isAdvancedPanelVisible, value)) OnAdvancedPanelVisibleChanged(); } }

    // Top-level commands
    public ICommand LoadInitialDataCommand { get; }
    public ICommand OpenSettingsCommand { get; }
    public ICommand ExitCommand { get; }
    public ICommand AddDirectoryAndRefreshCommand { get; }
    public ICommand ToggleAdvancedPanelCommand { get; }

    private readonly Random _shuffleRandom = new Random(); // Simple Random instance for shuffle randomization

    public MainWindowViewModel(
        SettingsService settingsService,
        MusicLibraryService musicLibraryService,
        PlaybackService playbackService,
        ThemeColors theme,
        WaveformService waveformService,
        LoopDataService loopDataService)
    {
        _settingsService = settingsService;
        _musicLibraryService = musicLibraryService;
        PlaybackService = playbackService;
        CurrentTheme = theme;
        _waveformService = waveformService;
        _loopDataService = loopDataService;

        // Initialize child ViewModels, passing required dependencies
        Library = new LibraryViewModel(_settingsService, _musicLibraryService, _loopDataService);
        Playback = new PlaybackViewModel(PlaybackService, _waveformService); // Pass PlaybackService and WaveformService
        LoopEditor = new LoopEditorViewModel(PlaybackService, _loopDataService); // Pass PlaybackService and LoopDataService


        // Subscribe to child ViewModel property changes relevant to the parent VM
        Library.PropertyChanged += Library_PropertyChanged;
        Playback.PropertyChanged += Playback_PropertyChanged; // Listen to Playback VM changes

        // Subscribe to the new PlaybackEndedNaturally event
        PlaybackService.PlaybackEndedNaturally += PlaybackService_PlaybackEndedNaturally;

        LoadInitialDataCommand = new RelayCommand(async _ => await Library.LoadLibraryAsync(), _ => !Library.IsLoadingLibrary);
        OpenSettingsCommand = new RelayCommand(async owner => await OpenSettingsDialog(owner), _ => !Library.IsLoadingLibrary);
        ExitCommand = new RelayCommand(_ => Environment.Exit(0));
        AddDirectoryAndRefreshCommand = new RelayCommand(async owner => await AddMusicDirectoryAndRefresh(owner), _ => !Library.IsLoadingLibrary);

        // ToggleAdvancedPanelCommand depends on Playback.HasCurrentSong (derived from PlaybackService)
        ToggleAdvancedPanelCommand = new RelayCommand(
            _ => IsAdvancedPanelVisible = !IsAdvancedPanelVisible,
            _ => Playback.HasCurrentSong && !Library.IsLoadingLibrary);


        // Initial state update
        UpdateAllUIDependentStates();
    }

    // Handler for the new PlaybackEndedNaturally event
    private void PlaybackService_PlaybackEndedNaturally(object? sender, EventArgs e)
    {
        Debug.WriteLine("[MainVM] PlaybackService_PlaybackEndedNaturally event received.");
        // This handler is invoked on the UI thread via Dispatcher.UIThread.InvokeAsync within PlaybackService.OnPlaybackStopped.

        var currentSong = Library.SelectedSong; // Get the song that just ended
        var currentList = Library.FilteredSongs.ToList(); // Get a snapshot of the current list

        if (currentSong == null || !currentList.Any())
        {
            Debug.WriteLine("[MainVM] Playback ended naturally, but no song selected or library list is empty. Stopping playback.");
            PlaybackService.Stop(); // Ensure state is stopped if no song is loaded
            return;
        }

        // --- Logic for determining the next action based on RepeatMode and ShuffleEnabled ---

        var repeatMode = Playback.RepeatMode;
        var shuffleEnabled = Playback.ShuffleEnabled;

        if (repeatMode == RepeatMode.RepeatOne)
        {
            Debug.WriteLine($"[MainVM] Playback ended naturally. Repeat Mode is RepeatOne. Replaying: {currentSong.Title}");
            PlaybackService.Play(currentSong); // Directly tell the service to play the *same* song instance
            Debug.WriteLine("[MainVM] PlaybackService.Play called directly for RepeatOne.");
            return; // Handled
        }

        if (repeatMode == RepeatMode.None)
        {
            Debug.WriteLine("[MainVM] Playback ended naturally. Repeat Mode is None. Stopping playback.");
            PlaybackService.Stop(); // Explicitly stop playback
            return; // Handled
        }

        // If we reach here, RepeatMode is either PlayOnce or RepeatAll
        Song? nextSong = null;

        if (shuffleEnabled)
        {
            // Shuffle logic: Pick a random song (excluding current if possible)
            Debug.WriteLine("[MainVM] Playback ended naturally. Shuffle is Enabled.");
            if (currentList.Any())
            {
                var potentialNextSongs = currentList.Where(s => s != currentSong).ToList();
                if (potentialNextSongs.Any())
                {
                    var nextIndex = _shuffleRandom.Next(potentialNextSongs.Count);
                    nextSong = potentialNextSongs[nextIndex];
                    Debug.WriteLine($"[MainVM] Shuffle pick: {nextSong?.Title ?? "null"}");
                }
                else if (currentList.Count == 1)
                {
                    Debug.WriteLine($"[MainVM] Shuffle enabled, but only one song ({currentSong.Title}) in list. Cannot pick a different one.");
                    // In shuffle mode with only one song, ending means stopping unless RepeatOne was active (handled above).
                    nextSong = null; // Will fall through to stop logic
                }
                else
                {
                    Debug.WriteLine("[MainVM] Shuffle enabled, list issues preventing next song pick.");
                    nextSong = null; // Will fall through to stop logic
                }
            }
            else
            {
                Debug.WriteLine("[MainVM] Shuffle enabled, but list is empty.");
                nextSong = null; // Will fall through to stop logic
            }
        }
        else // Shuffle Disabled - Sequential or RepeatAll
        {
            Debug.WriteLine("[MainVM] Playback ended naturally. Shuffle is Disabled.");
            var currentIndex = currentList.IndexOf(currentSong);
            if (currentIndex != -1 && currentIndex < currentList.Count - 1)
            {
                nextSong = currentList[currentIndex + 1]; // Play the next song sequentially
                Debug.WriteLine($"[MainVM] Sequential next: {nextSong?.Title ?? "null"}");
            }
            else // Reached the end of the sequential list
            {
                Debug.WriteLine("[MainVM] End of sequential list reached.");
                // Check Repeat All *only* here
                if (repeatMode == RepeatMode.RepeatAll && currentList.Any())
                {
                    nextSong = currentList.First(); // Wrap around
                    Debug.WriteLine($"[MainVM] RepeatAll active, wrapping around to first: {nextSong.Title}");
                }
                else
                {
                    Debug.WriteLine($"[MainVM] RepeatMode is {repeatMode} (not RepeatAll), end of list reached. Stopping.");
                    nextSong = null; // Fall through to stop logic
                }
            }
        }

        // --- Trigger playback of the determined next song or stop if none ---
        if (nextSong != null)
        {
            // Setting Library.SelectedSong triggers the Library_PropertyChanged handler,
            // which then calls PlaybackService.Play(nextSong). This updates the UI selection.
            Debug.WriteLine($"[MainVM] Setting Library.SelectedSong to {nextSong.Title}.");
            Library.SelectedSong = nextSong;
        }
        else
        {
            // If no next song was determined (end of PlayOnce sequential, shuffle failed in single-item list, empty list)
            Debug.WriteLine("[MainVM] No next song determined. Calling PlaybackService.Stop().");
            PlaybackService.Stop(); // Explicitly stop playback
        }

        Debug.WriteLine("[MainVM] PlaybackService_PlaybackEndedNaturally handler completed.");
    }

    private void Library_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        Dispatcher.UIThread.InvokeAsync(() =>
        {
            switch (e.PropertyName)
            {
                case nameof(Library.SelectedSong):
                    Debug.WriteLine($"[MainVM_LibChanged] Library.SelectedSong changed to: {Library.SelectedSong?.Title ?? "null"}. Instance: {Library.SelectedSong?.GetHashCode() ?? 0}");
                    // When a song is selected in the Library (either manually or programmatically by navigation logic),
                    // tell the PlaybackService to play it.
                    // This is handled here for explicit selection by the user or navigation commands.
                    // RepeatOne is handled by calling PlaybackService.Play directly in the PlaybackEndedNaturally handler.
                    // This handler should only initiate playback when a *new* song is selected from the list by the user or sequence/shuffle logic.
                    // If PlaybackService.CurrentSong is null, this is the first song, or a stop occurred. Play the selected song.
                    // If PlaybackService.CurrentSong is not null, and it's different from Library.SelectedSong, a new song was selected. Play it.
                    // If PlaybackService.CurrentSong is not null, and it's the SAME as Library.SelectedSong, this selection change might be due to:
                    // 1. RepeatOne completion (handled by direct Play call in handler)
                    // 2. User clicking on the already selected song (no action needed, song is already playing)
                    // 3. PlaybackEndedNaturally handler reaching end without repeat/shuffle (should stop)
                    // 4. PlaybackService.Stop() setting CurrentSong = null then Library.SelectedSong = null (handled by Playback_PropertyChanged)

                    if (Library.SelectedSong != null && PlaybackService.CurrentSong != Library.SelectedSong)
                    {
                        Debug.WriteLine($"[MainVM_LibChanged] Library.SelectedSong changed to a *different* song ({Library.SelectedSong.Title}) than PlaybackService.CurrentSong ({PlaybackService.CurrentSong?.Title ?? "null"}). Calling PlaybackService.Play().");
                        PlaybackService.Play(Library.SelectedSong);
                    }
                    else if (Library.SelectedSong != null && PlaybackService.CurrentSong == Library.SelectedSong)
                    {
                        // Song instance is the same. This might be a user re-click or RepeatOne completing.
                        // RepeatOne case is handled by direct Play in PlaybackEndedNaturally. User re-click means it's already playing.
                        Debug.WriteLine($"[MainVM_LibChanged] Library.SelectedSong changed but is the SAME song instance as PlaybackService.CurrentSong ({Library.SelectedSong.Title}). Assuming RepeatOne handled it or user re-clicked already playing song. No Play call needed here.");
                    }
                    else if (Library.SelectedSong == null)
                    {
                        // If selection is cleared (e.g., by search filter or explicit stop), we don't start playback here.
                        Debug.WriteLine("[MainVM_LibChanged] Library.SelectedSong is null. No Play call needed.");
                    }


                    // Update commands that might depend on a song being selected/playing
                    RaiseAllCommandsCanExecuteChanged();
                    break;
                case nameof(Library.IsLoadingLibrary):
                    // Propagate the loading state change
                    OnPropertyChanged(nameof(IsLoadingLibrary));
                    // Update commands dependent on loading state
                    RaiseAllCommandsCanExecuteChanged();
                    UpdateStatusBarText(); // Status text includes loading info
                    break;
                case nameof(Library.LibraryStatusText):
                    UpdateStatusBarText(); // Library status affects overall status bar
                    break;
                    // Properties like Artists, Albums, FilteredSongs changing are handled by LibraryVM itself.
                    // When FilteredSongs changes, LibraryVM calls RaiseNavigationCommandsCanExecuteChanged internally.
            }
        });
    }

    private void Playback_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        Dispatcher.UIThread.InvokeAsync(() =>
        {
            // Listen for PlaybackViewModel changes that affect MainViewModel's state/UI
            switch (e.PropertyName)
            {
                case nameof(PlaybackViewModel.CurrentSong):
                    OnPropertyChanged(nameof(Playback.CurrentSong)); // Propagate the song itself
                    OnPropertyChanged(nameof(Playback.HasCurrentSong)); // Propagate derived property
                    // Commands that might depend on a song being loaded (like ToggleAdvancedPanelCommand)
                    RaiseAllCommandsCanExecuteChanged();

                    // If playback service reports no current song, ensure library selection is cleared
                    // Only clear selection if it matches the song that just became null in PlaybackService.
                    // This prevents clearing selection if the user has already selected a *new* song.
                    // However, relying on PlaybackService's CurrentSong becoming null is the most reliable way
                    // to know playback has stopped *without* a new song immediately starting (like in RepeatOne).
                    // Let's clear Library.SelectedSong if Playback.HasCurrentSong becomes false. This simplifies state.
                    if (!Playback.HasCurrentSong && Library.SelectedSong != null)
                    {
                        Debug.WriteLine("[MainVM_PlaybackChanged] PlaybackService has no current song. Clearing Library selection.");
                        Library.SelectedSong = null; // This will trigger Library_PropertyChanged (which correctly won't call Play)
                    }

                    // When a new song is set in PlaybackService (either by Play() or PlaybackEndedNaturally handler),
                    // trigger waveform loading if panel is visible.
                    // Check if the *new* CurrentSong is different from the *previous* one (handled by PS).
                    if (Playback.CurrentSong != null && IsAdvancedPanelVisible)
                    {
                        Debug.WriteLine("[MainVM_PlaybackChanged] Playback has current song, advanced panel is visible. Requesting waveform load.");
                        // Use await _ = to suppress the warning about calling async void, while ensuring the task runs.
                        _ = Playback.LoadWaveformForCurrentSongAsync(); // Delegate waveform load
                    }
                    // Note: Clearing waveform when song becomes null is handled inside PlaybackViewModel's PS handler

                    // Update status bar text whenever the current song changes
                    UpdateStatusBarText();

                    // Update time displays when song changes (delegated to PlaybackVM)
                    OnPropertyChanged(nameof(Playback.CurrentTimeDisplay)); // Propagate derived property
                    OnPropertyChanged(nameof(Playback.TotalTimeDisplay)); // Propagate derived property

                    // Commands in PlaybackVM (Play/Pause, Seek, Speed/Pitch, Mode toggles) are handled by PlaybackVM itself.
                    // Library navigation commands are handled by LibraryVM's SelectedSong/FilteredSongs change.
                    // ToggleAdvancedPanelCommand depends on Playback.HasCurrentSong, so need to raise.
                    RaiseAllCommandsCanExecuteChanged();

                    break;
                case nameof(PlaybackViewModel.CurrentPlaybackStatus):
                    OnPropertyChanged(nameof(Playback.CurrentPlaybackStatus)); // Propagate status
                    OnPropertyChanged(nameof(Playback.IsPlaying)); // Derived from status
                    UpdateStatusBarText(); // Playback status affects overall status bar
                    // Commands in PlaybackVM already listen to this. MainVM commands potentially affected? (currently none directly)
                    RaiseAllCommandsCanExecuteChanged();
                    break;
                case nameof(PlaybackViewModel.CurrentPosition):
                    OnPropertyChanged(nameof(Playback.CurrentPosition)); // Propagate position
                    OnPropertyChanged(nameof(Playback.CurrentPositionSeconds)); // Propagate derived property
                    OnPropertyChanged(nameof(Playback.CurrentTimeDisplay)); // Propagate current time display
                    // Loop editor and UI slider are bound directly to PlaybackVM properties.
                    // Commands in PlaybackVM already listen to this.
                    // Raising all commands here is usually not needed for position change.
                    break;
                case nameof(PlaybackViewModel.CurrentSongDuration):
                    OnPropertyChanged(nameof(Playback.CurrentSongDuration)); // Propagate duration
                    OnPropertyChanged(nameof(Playback.CurrentSongDurationSeconds));
                    OnPropertyChanged(nameof(Playback.TotalTimeDisplay)); // Propagate total time display
                                                                          // UI slider is bound directly.
                    RaiseAllCommandsCanExecuteChanged(); // PlaybackVM Seek command CanExecute depends on duration > 0
                    break;
                case nameof(PlaybackViewModel.IsWaveformLoading):
                    OnPropertyChanged(nameof(Playback.IsWaveformLoading)); // Propagate state
                    // Commands in PlaybackVM already listen to this.
                    // Raising all commands here is usually not needed unless a MainVM command directly depends on this.
                    break;
                case nameof(PlaybackViewModel.WaveformRenderData):
                    OnPropertyChanged(nameof(Playback.WaveformRenderData)); // Propagate data
                    // Waveform display is bound directly.
                    break;
                case nameof(PlaybackViewModel.ShuffleEnabled): // Modes changed
                case nameof(PlaybackViewModel.RepeatMode): // Modes changed
                                                           // These affect the PlaybackEndedNaturally logic in MainVM,
                                                           // but they also affect PlaybackVM commands and UI bindings.
                                                           // Raise PlaybackVM commands' CanExecute state.
                    Playback.RaisePlaybackCommandCanExecuteChanged();
                    // Raising all commands here is generally redundant unless a MainVM command directly depends on these modes.
                    // Update status bar to reflect mode changes
                    UpdateStatusBarText();
                    break;

                    // PlaybackSpeed, PlaybackPitch, derived display properties are handled within PlaybackVM.
                    // LoopEditor VM listens directly to PlaybackService for position/duration.
            }
        });
    }

    private void OnAdvancedPanelVisibleChanged()
    {
        (ToggleAdvancedPanelCommand as RelayCommand)?.RaiseCanExecuteChanged();
        // If Advanced Panel becomes visible, and a song is playing, load its waveform.
        // Access PlaybackVM properties directly
        if (IsAdvancedPanelVisible && Playback.HasCurrentSong && !Playback.WaveformRenderData.Any() && !Playback.IsWaveformLoading)
        {
            Debug.WriteLine("[MainVM] Advanced Panel visible, song is playing, waveform not loaded/loading. Requesting waveform load.");
            // Use await _ = to suppress the warning about calling async void, while ensuring the task runs.
            _ = Playback.LoadWaveformForCurrentSongAsync(); // Delegate waveform load
        }
        // Note: If it becomes hidden, we don't clear the waveform data automatically here.
        // Clearing upon song change/stop is handled by PlaybackViewModel's PS handler.
    }

    private void UpdateAllUIDependentStates()
    {
        // Update main VM properties that depend on child VM states
        OnPropertyChanged(nameof(IsLoadingLibrary)); // Depends on Library.IsLoadingLibrary
        OnPropertyChanged(nameof(Playback.CurrentSong)); // Ensure Playback's CurrentSong is reflected
        OnPropertyChanged(nameof(Playback.HasCurrentSong)); // Ensure Playback's HasCurrentSong is reflected
        OnPropertyChanged(nameof(IsAdvancedPanelVisible)); // Ensure panel visibility is reflected
        UpdateStatusBarText(); // Depends on Playback and Library status

        // Trigger commands CanExecute updates for all VMs
        RaiseAllCommandsCanExecuteChanged();
    }

    /// <summary>
    /// Raises CanExecuteChanged for commands owned by this ViewModel and tells child VMs to do the same.
    /// </summary>
    public void RaiseAllCommandsCanExecuteChanged()
    {
        // Raise CanExecuteChanged for commands owned by MainWindowViewModel
        (LoadInitialDataCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (OpenSettingsCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (ExitCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (AddDirectoryAndRefreshCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (ToggleAdvancedPanelCommand as RelayCommand)?.RaiseCanExecuteChanged();

        // Tell child VMs to raise their commands' CanExecuteChanged
        // This now includes the navigation commands within LibraryViewModel
        Library.RaiseLibraryCommandsCanExecuteChanged();
        Library.RaiseNavigationCommandsCanExecuteChanged(); // Explicitly call navigation commands
        Playback.RaisePlaybackCommandCanExecuteChanged();
        LoopEditor.RaiseLoopCommandCanExecuteChanged();
    }


    private void UpdateStatusBarText()
    {
        // Combine status from PlaybackViewModel and LibraryViewModel
        string status;
        if (Playback.HasCurrentSong)
        {
            string stateStr = Playback.CurrentPlaybackStatus switch { PlaybackStateStatus.Playing => "Playing", PlaybackStateStatus.Paused => "Paused", PlaybackStateStatus.Stopped => "Stopped", _ => "Idle" };
            // Access CurrentSong via Playback property
            status = $"{stateStr}: {Playback.CurrentSong?.Title ?? "Unknown Song"}";
            // Use LoopEditor's property for loop active state displayed in status bar
            // Access CurrentSong via Playback property
            if (LoopEditor.IsCurrentLoopActiveUiBinding && Playback.CurrentSong?.SavedLoop != null)
            {
                status += $" (Loop Active)";
            }

            // Add mode status
            string modeStatus = "";
            if (Playback.ShuffleEnabled)
            {
                modeStatus += " | Shuffle";
            }
            // Use RepeatMode property
            modeStatus += Playback.RepeatMode switch
            {
                RepeatMode.None => " | Do Nothing",
                RepeatMode.PlayOnce => " | Play Once",
                RepeatMode.RepeatOne => " | Repeat Song",
                RepeatMode.RepeatAll => " | Repeat All",
                _ => "" // Should not happen
            };


            if (!string.IsNullOrEmpty(modeStatus))
            {
                status += modeStatus;
            }
        }
        else
        {
            // No playback info, use library status
            status = Library.LibraryStatusText;
        }
        StatusBarText = status;
    }

    private async Task LoadMusicLibrary()
    {
        // Delegate the core loading logic to the LibraryViewModel
        await Library.LoadLibraryAsync();
        // The Library_PropertyChanged handler for IsLoadingLibrary will trigger status updates.
    }

    private async Task OpenSettingsDialog(object? ownerWindow)
    {
        if (ownerWindow is not Window owner || Library.IsLoadingLibrary) return;
        IsAdvancedPanelVisible = false; // Hide advanced panel when opening settings

        var currentSettingsBeforeDialog = _settingsService.LoadSettings();
        var settingsVM = new SettingsViewModel(_settingsService);
        var settingsDialog = new Sonorize.Views.SettingsWindow(CurrentTheme) { DataContext = settingsVM };

        await settingsDialog.ShowDialog(owner); // Show dialog modally

        // After the dialog is closed
        if (settingsVM.SettingsChanged)
        {
            Debug.WriteLine("[MainVM] Settings changed detected after dialog closed.");
            var newSettingsAfterDialog = _settingsService.LoadSettings();
            bool dirsActuallyChanged = !currentSettingsBeforeDialog.MusicDirectories.SequenceEqual(newSettingsAfterDialog.MusicDirectories);
            bool themeActuallyChanged = currentSettingsBeforeDialog.PreferredThemeFileName != newSettingsAfterDialog.PreferredThemeFileName;

            if (dirsActuallyChanged)
            {
                Debug.WriteLine("[MainVM] Music directories changed. Reloading library.");
                await Library.LoadLibraryAsync(); // Delegate library reload
                // Status bar update triggered by Library.IsLoadingLibrary change.
            }

            if (themeActuallyChanged)
            {
                Debug.WriteLine("[MainVM] Theme changed. Restart recommended.");
                // Update status bar to inform user about restart
                StatusBarText = "Theme changed. Please restart Sonorize for the changes to take full effect.";
            }
        }
        else
        {
            Debug.WriteLine("[MainVM] Settings dialog closed, no changes reported by SettingsViewModel.");
            // Ensure status bar reflects current state after dialog if no reload/theme change occurred
            UpdateStatusBarText(); // Revert status bar to normal if not loading
        }
    }

    private async Task AddMusicDirectoryAndRefresh(object? ownerWindow)
    {
        if (ownerWindow is not Window owner || Library.IsLoadingLibrary) return;
        IsAdvancedPanelVisible = false; // Hide advanced panel

        var result = await owner.StorageProvider.OpenFolderPickerAsync(new FolderPickerOpenOptions { Title = "Select Music Directory", AllowMultiple = false });

        if (result != null && result.Count > 0)
        {
            string? folderPath = null;
            try
            {
                // Using Path.GetFullPath is crucial for consistent path representation
                folderPath = Path.GetFullPath(result[0].Path.LocalPath);
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[MainVM] Error getting full path for selected directory: {ex.Message}");
                StatusBarText = "Error getting path for selected directory.";
                return;
            }

            if (!string.IsNullOrEmpty(folderPath) && Directory.Exists(folderPath))
            {
                var settings = _settingsService.LoadSettings();
                // Use a case-insensitive comparison for existing directories
                if (!settings.MusicDirectories.Any(d => string.Equals(d, folderPath, StringComparison.OrdinalIgnoreCase)))
                {
                    settings.MusicDirectories.Add(folderPath);
                    _settingsService.SaveSettings(settings);
                    Debug.WriteLine($"[MainVM] Added new directory: {folderPath}. Reloading library.");
                    await Library.LoadLibraryAsync(); // Delegate library reload
                    // Status bar update triggered by Library.IsLoadingLibrary change.
                }
                else
                {
                    Debug.WriteLine($"[MainVM] Directory already exists: {folderPath}");
                    StatusBarText = "Directory already in library.";
                }
            }
            else
            {
                Debug.WriteLine($"[MainVM] Selected directory path is invalid or does not exist: {folderPath}");
                StatusBarText = "Invalid directory selected.";
            }
        }
        else
        {
            Debug.WriteLine("[MainVM] Folder picker cancelled or returned no results.");
            // Optionally update status bar if folder picker was cancelled
            UpdateStatusBarText(); // Revert status bar to normal if not loading
        }
    }

    // Use a cryptographically secure random number generator for better shuffle randomness if needed
    // private int GetNextRandomIndex(int maxIndex)
    // {
    //     using (var rng = new RNGCryptoServiceProvider())
    //     {
    //         byte[] data = new byte[sizeof(uint)]; // Use uint size for randomness
    //         rng.GetBytes(data);
    //         uint randomValue = BitConverter.ToUInt32(data, 0);
    //         return (int)(randomValue % maxIndex);
    //     }
    // }
}
</file>

<file path="Source\ViewModels\PlaybackViewModel.cs">
using Avalonia.Threading;
using Sonorize.Models;
using Sonorize.Services; // This using directive makes PlaybackStateStatus from the Service available
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Input;

namespace Sonorize.ViewModels;

// Removed duplicate PlaybackStateStatus enum definition.
// The definition from Sonorize.Services is used via the using directive.


// Renamed enum for clarity based on standard playback controls
public enum RepeatMode { None, PlayOnce, RepeatOne, RepeatAll }


public class PlaybackViewModel : ViewModelBase
{
    public PlaybackService PlaybackService { get; } // Keep reference to the service
    private readonly WaveformService _waveformService; // Need waveform service here

    // Properties related to playback state, directly from service or derived
    // Public getter for PlaybackService.CurrentSong property
    public Song? CurrentSong => PlaybackService.CurrentSong;
    public bool HasCurrentSong => PlaybackService.CurrentSong != null;

    public TimeSpan CurrentPosition => PlaybackService.CurrentPosition;
    public double CurrentPositionSeconds
    {
        get => PlaybackService.CurrentPositionSeconds;
        set
        {
            // Check if the value actually changed and if a song is loaded
            // Use a small tolerance for double comparison
            if (PlaybackService.CurrentSong != null && Math.Abs(PlaybackService.CurrentPositionSeconds - value) > 0.01)
            {
                // Debug.WriteLine($"[PlaybackVM] CurrentPositionSeconds setter called with: {value}. Current PlaybackService PositionSeconds: {PlaybackService.CurrentPositionSeconds}. Seeking.");
                PlaybackService.Seek(TimeSpan.FromSeconds(value));
                // After PlaybackService.Seek, it will update its CurrentPosition,
                // which will fire PropertyChanged. This ViewModel's PlaybackService_PropertyChanged
                // handler will then update its own properties (including this one's getter value)
                // and notify the UI.
            }
            // If value is effectively the same, do nothing to prevent potential feedback loops or unnecessary seeks.
            // If no song is loaded, seeking is not possible/meaningful.
        }
    }

    public TimeSpan CurrentSongDuration => PlaybackService.CurrentSongDuration;
    public double CurrentSongDurationSeconds => PlaybackService.CurrentSongDurationSeconds;

    // Use PlaybackStateStatus from Sonorize.Services via the using directive
    public PlaybackStateStatus CurrentPlaybackStatus => PlaybackService.CurrentPlaybackStatus;
    public bool IsPlaying => PlaybackService.IsPlaying;

    // Properties for playback controls (Speed/Pitch)
    private double _playbackSpeed = 1.0;
    public double PlaybackSpeed { get => _playbackSpeed; set { value = Math.Clamp(value, 0.5, 2.0); if (SetProperty(ref _playbackSpeed, value)) { PlaybackService.PlaybackRate = (float)value; OnPropertyChanged(nameof(PlaybackSpeedDisplay)); } } }
    public string PlaybackSpeedDisplay => $"{PlaybackSpeed:F2}x";

    private double _playbackPitch = 0.0;
    public double PlaybackPitch { get => _playbackPitch; set { value = Math.Round(value * 2, MidpointRounding.AwayFromZero) / 2.0; value = Math.Clamp(value, -4.0, 4.0); if (SetProperty(ref _playbackPitch, value)) { PlaybackService.PitchSemitones = (float)_playbackPitch; OnPropertyChanged(nameof(PlaybackPitchDisplay)); } } }
    public string PlaybackPitchDisplay => $"{PlaybackPitch:+0.0;-0.0;0} st";

    // Properties for playback modes (Shuffle, Repeat)
    private bool _shuffleEnabled = false;
    public bool ShuffleEnabled
    {
        get => _shuffleEnabled;
        set
        {
            if (SetProperty(ref _shuffleEnabled, value))
            {
                Debug.WriteLine($"[PlaybackVM] ShuffleEnabled set to: {value}");
                // Saving preference could happen here
            }
        }
    }

    // Renamed property
    private RepeatMode _repeatMode = RepeatMode.PlayOnce; // Default to PlayOnce
    public RepeatMode RepeatMode
    {
        get => _repeatMode;
        set
        {
            if (SetProperty(ref _repeatMode, value))
            {
                Debug.WriteLine($"[PlaybackVM] RepeatMode set to: {value}");
                // Saving preference could happen here
                OnPropertyChanged(nameof(IsRepeatOne));
                OnPropertyChanged(nameof(IsRepeatAll));
                OnPropertyChanged(nameof(IsRepeatActive)); // Notify composite state change
            }
        }
    }

    // Helper properties for UI bindings (e.g., RadioButtons or toggling states) - Renamed
    public bool IsRepeatOne { get => RepeatMode == RepeatMode.RepeatOne; set { if (value) RepeatMode = RepeatMode.RepeatOne; } }
    public bool IsRepeatAll { get => RepeatMode == RepeatMode.RepeatAll; set { if (value) RepeatMode = RepeatMode.RepeatAll; } }
    // Helper for the ToggleButton IsChecked state (active if not None)
    public bool IsRepeatActive => RepeatMode != RepeatMode.None;


    // Commands for UI controls for modes
    public ICommand ToggleShuffleCommand { get; }
    // Renamed command to reflect cycling through repeat modes
    public ICommand CycleRepeatModeCommand { get; } // Cycles through None -> PlayOnce -> RepeatOne -> RepeatAll -> None


    // Waveform data
    public ObservableCollection<WaveformPoint> WaveformRenderData { get; } = new();
    private bool _isWaveformLoading = false;
    // Changed setter to private to enforce internal state management
    public bool IsWaveformLoading { get => _isWaveformLoading; private set => SetProperty(ref _isWaveformLoading, value); }

    // Derived properties for UI display (Split time display)
    public string CurrentTimeDisplay
    {
        get
        {
            if (PlaybackService.CurrentSong != null)
            {
                return $"{PlaybackService.CurrentPosition:mm\\:ss}";
            }
            return "--:--";
        }
    }

    public string TotalTimeDisplay
    {
        get
        {
            if (PlaybackService.CurrentSong != null && PlaybackService.CurrentSongDuration.TotalSeconds > 0)
            {
                return $"{PlaybackService.CurrentSongDuration:mm\\:ss}";
            }
            return "--:--";
        }
    }


    // Commands owned by PlaybackViewModel
    public ICommand PlayPauseResumeCommand { get; } // Renamed from simple Click handler
    public ICommand SeekCommand { get; } // Command for slider/waveform seeking


    public PlaybackViewModel(PlaybackService playbackService, WaveformService waveformService)
    {
        PlaybackService = playbackService;
        _waveformService = waveformService;

        // Initialize playback controls (Speed/Pitch)
        PlaybackSpeed = 1.0; // Sets service value and raises property changed
        PlaybackPitch = 0.0; // Sets service value and raises property changed

        // Initialize playback modes (Defaults)
        ShuffleEnabled = false;
        RepeatMode = RepeatMode.PlayOnce; // Default repeat mode


        // Initialize commands
        PlayPauseResumeCommand = new RelayCommand(
            _ => TogglePlayPauseResume(),
            _ => PlaybackService.CurrentSong != null && !IsWaveformLoading); // Can't control playback while waveform is loading

        SeekCommand = new RelayCommand(
            positionSecondsObj => {
                if (positionSecondsObj is double seconds && PlaybackService.CurrentSongDuration.TotalSeconds > 0)
                {
                    // This command is useful for explicit seek calls, although the slider two-way binding is primary.
                    PlaybackService.Seek(TimeSpan.FromSeconds(seconds));
                }
            },
             _ => PlaybackService.CurrentSong != null && PlaybackService.CurrentSongDuration.TotalSeconds > 0 && !IsWaveformLoading);

        ToggleShuffleCommand = new RelayCommand(
            _ => ShuffleEnabled = !ShuffleEnabled,
             _ => PlaybackService.CurrentSong != null // Can shuffle only if a song is loaded (implies a list exists)
        );

        // Renamed command handler call
        CycleRepeatModeCommand = new RelayCommand(
             _ => CycleRepeatMode(),
             _ => PlaybackService.CurrentSong != null // Can repeat only if a song is loaded
        );


        // Subscribe to PlaybackService property changes
        PlaybackService.PropertyChanged += PlaybackService_PropertyChanged;

        // Subscribe to PlaybackViewModel's own properties that affect command CanExecute
        // ShuffleEnabled, RepeatMode, IsWaveformLoading affect command states.
        // CurrentPosition, CurrentSongDuration affect seek command CanExecute (handled by PS_PropertyChanged)
        PropertyChanged += PlaybackViewModel_PropertyChanged;
    }

    private void TogglePlayPauseResume()
    {
        Debug.WriteLine($"[PlaybackVM] TogglePlayPauseResume called. Current state: {PlaybackService.CurrentPlaybackStatus}");
        if (PlaybackService.CurrentPlaybackStatus == PlaybackStateStatus.Playing)
        {
            PlaybackService.Pause();
        }
        else if (PlaybackService.CurrentPlaybackStatus == PlaybackStateStatus.Paused)
        {
            PlaybackService.Resume();
        }
        else if (PlaybackService.CurrentPlaybackStatus == PlaybackStateStatus.Stopped && PlaybackService.CurrentSong != null)
        {
            // If stopped but a song is loaded (e.g., after ending), resume playing
            PlaybackService.Resume(); // This calls Play(CurrentSong) internally
        }
        else if (PlaybackService.CurrentPlaybackStatus == PlaybackStateStatus.Stopped && PlaybackService.CurrentSong == null)
        {
            // If stopped and no song is loaded, cannot play/resume.
            Debug.WriteLine("[PlaybackVM] TogglePlayPauseResume called in Stopped state with no song. Doing nothing.");
        }
    }

    // Renamed handler and updated cycle logic
    private void CycleRepeatMode()
    {
        RepeatMode = RepeatMode switch
        {
            RepeatMode.None => RepeatMode.PlayOnce,
            RepeatMode.PlayOnce => RepeatMode.RepeatOne,
            RepeatMode.RepeatOne => RepeatMode.RepeatAll,
            RepeatMode.RepeatAll => RepeatMode.None,
            _ => RepeatMode.None // Should not happen
        };
        RaisePlaybackCommandCanExecuteChanged(); // Repeat commands affected
    }

    private void PlaybackService_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        Dispatcher.UIThread.InvokeAsync(() =>
        {
            // Propagate relevant PlaybackService changes to PlaybackViewModel properties
            switch (e.PropertyName)
            {
                case nameof(PlaybackService.CurrentSong):
                    OnPropertyChanged(nameof(CurrentSong)); // Propagate the song itself
                    OnPropertyChanged(nameof(HasCurrentSong));
                    // Duration, Position, State will also change, let's handle those explicitly or rely on other cases

                    // If the song becomes null (e.g., after Stop), clear waveform data and loading state
                    if (PlaybackService.CurrentSong == null)
                    {
                        Debug.WriteLine("[PlaybackVM] PlaybackService.CurrentSong is null. Clearing waveform data.");
                        WaveformRenderData.Clear(); OnPropertyChanged(nameof(WaveformRenderData));
                        IsWaveformLoading = false; // Internal setter is fine
                    }

                    // Update time displays when song changes
                    OnPropertyChanged(nameof(CurrentTimeDisplay));
                    OnPropertyChanged(nameof(TotalTimeDisplay));

                    // Commands that require a song to be loaded might be affected
                    RaisePlaybackCommandCanExecuteChanged();
                    break;
                case nameof(PlaybackService.CurrentPosition):
                    OnPropertyChanged(nameof(CurrentPosition));
                    OnPropertyChanged(nameof(CurrentPositionSeconds)); // This will reflect the change from PlaybackService
                    OnPropertyChanged(nameof(CurrentTimeDisplay)); // Update current time display
                    // Seek command might be affected (CanExecute depends on duration > 0, which changes less often)
                    // RaisePlaybackCommandCanExecuteChanged(); // Usually not needed for position change
                    break;
                case nameof(PlaybackService.CurrentSongDuration):
                    OnPropertyChanged(nameof(CurrentSongDuration));
                    OnPropertyChanged(nameof(CurrentSongDurationSeconds));
                    OnPropertyChanged(nameof(TotalTimeDisplay)); // Update total time display
                    RaisePlaybackCommandCanExecuteChanged(); // Seek command's CanExecute depends on duration > 0
                    break;
                case nameof(PlaybackService.CurrentPlaybackStatus):
                    OnPropertyChanged(nameof(CurrentPlaybackStatus));
                    OnPropertyChanged(nameof(IsPlaying)); // Derived from status
                    RaisePlaybackCommandCanExecuteChanged(); // Play/Pause/Resume command is affected
                    break;
                    // Speed and Pitch changes on the service are triggered by the VM setter,
                    // so no need to listen for them here.
            }
        });
    }

    private void PlaybackViewModel_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        // Listen to properties *on this ViewModel* that affect command CanExecute
        switch (e.PropertyName)
        {
            case nameof(IsWaveformLoading):
            case nameof(ShuffleEnabled): // Commands might be enabled/disabled based on modes
            case nameof(RepeatMode): // Commands might be enabled/disabled based on modes
                RaisePlaybackCommandCanExecuteChanged();
                // Also update the composite IsRepeatActive property
                OnPropertyChanged(nameof(IsRepeatActive));
                break;
            case nameof(HasCurrentSong):
                RaisePlaybackCommandCanExecuteChanged(); // ToggleShuffle and CycleRepeatMode depend on this
                break;
                // PlaybackSpeed, PlaybackPitch don't inherently affect command CanExecute
        }
    }


    /// <summary>
    /// Loads the waveform data for the currently playing song. Designed to be called by MainWindowViewModel.
    /// </summary>
    public async Task LoadWaveformForCurrentSongAsync()
    {
        var songToLoadWaveformFor = PlaybackService.CurrentSong;
        if (songToLoadWaveformFor == null || string.IsNullOrEmpty(songToLoadWaveformFor.FilePath))
        {
            Debug.WriteLine("[PlaybackVM] LoadWaveformForCurrentSongAsync skipped: No current song or invalid path.");
            // Clearing waveform data and setting loading state to false is handled by PlaybackService_PropertyChanged when CurrentSong becomes null
            return;
        }

        // Check if waveform is already loaded for this song OR currently loading
        // A simple check if there are any points is a rough indicator.
        // A more robust approach would be to store the file path associated with WaveformRenderData.
        // For simplicity, for now, if it has points OR is loading, assume it's for the current song.
        if (WaveformRenderData.Any() || IsWaveformLoading)
        {
            Debug.WriteLine($"[PlaybackVM] Waveform already loaded ({WaveformRenderData.Count} points) or loading ({IsWaveformLoading}) for {songToLoadWaveformFor.Title}. Skipping load.");
            return;
        }


        // Clear existing waveform data immediately to show loading state
        Debug.WriteLine($"[PlaybackVM] Clearing previous waveform data ({WaveformRenderData.Count} points).");
        WaveformRenderData.Clear(); OnPropertyChanged(nameof(WaveformRenderData));
        IsWaveformLoading = true; // Internal setter is fine here

        try
        {
            Debug.WriteLine($"[PlaybackVM] Requesting waveform for: {songToLoadWaveformFor.Title}");
            // Target points should probably be based on control width or a fixed resolution
            // For a fixed 80px height control, 1000 points is likely sufficient detail.
            var points = await _waveformService.GetWaveformAsync(songToLoadWaveformFor.FilePath, 1000);

            // Check if the song is still the same AFTER the async operation before updating the UI
            if (PlaybackService.CurrentSong == songToLoadWaveformFor)
            {
                Debug.WriteLine($"[PlaybackVM] Waveform loaded for: {songToLoadWaveformFor.Title}, {points.Count} points. Updating UI.");
                // Add points on the UI thread
                await Dispatcher.UIThread.InvokeAsync(() => {
                    foreach (var p in points) WaveformRenderData.Add(p);
                    OnPropertyChanged(nameof(WaveformRenderData)); // Notify UI
                });
                // _currentWaveformFilePath = songToLoadWaveformFor.FilePath; // Store the file path of the loaded waveform

            }
            else
            {
                // Song changed during waveform generation, discard the result for the old song.
                Debug.WriteLine($"[PlaybackVM] Waveform for {songToLoadWaveformFor.Title} loaded, but current song is now {PlaybackService.CurrentSong?.Title ?? "null"}. Discarding.");
                // No need to clear WaveformRenderData here; the handler for the new song or null song will handle it.
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[PlaybackVM] CRITICAL Error loading waveform for {songToLoadWaveformFor.Title}: {ex.Message}");
            await Dispatcher.UIThread.InvokeAsync(() => {
                WaveformRenderData.Clear(); OnPropertyChanged(nameof(WaveformRenderData));
                // Optionally set a status text indicating waveform load failed
            });
        }
        finally
        {
            await Dispatcher.UIThread.InvokeAsync(() => {
                IsWaveformLoading = false; // Internal setter is fine here
            });
        }
    }

    /// <summary>
    /// Raises CanExecuteChanged for commands owned by this ViewModel.
    /// </summary>
    public void RaisePlaybackCommandCanExecuteChanged()
    {
        //Debug.WriteLine("[PlaybackVM] Raising playback command CanExecute changed.");
        (PlayPauseResumeCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (SeekCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (ToggleShuffleCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (CycleRepeatModeCommand as RelayCommand)?.RaiseCanExecuteChanged(); // Renamed
    }
}
</file>

<file path="Source\ViewModels\RelayCommand.cs">
using System;
using System.Windows.Input;

namespace Sonorize.ViewModels;

public class RelayCommand : ICommand
{
    private readonly Action<object?> _execute;
    private readonly Predicate<object?>? _canExecute;
    private EventHandler? _canExecuteChanged;

    public event EventHandler? CanExecuteChanged
    {
        add
        {
            // Note: Avalonia doesn't have a global CommandManager.RequerySuggested like WPF.
            // For simplicity, this basic RelayCommand requires manual raising of CanExecuteChanged
            // or relies on UI controls that re-evaluate CanExecute on interactions.
            // For more robust scenarios, integrate with a mechanism that allows VMs to signal changes.
            _canExecuteChanged += value;
        }
        remove
        {
            _canExecuteChanged -= value;
        }
    }

    public void RaiseCanExecuteChanged()
    {
        _canExecuteChanged?.Invoke(this, EventArgs.Empty);
    }

    public RelayCommand(Action<object?> execute, Predicate<object?>? canExecute = null)
    {
        _execute = execute ?? throw new ArgumentNullException(nameof(execute));
        _canExecute = canExecute;
    }

    public RelayCommand(Action execute, Func<bool>? canExecute = null)
        : this(o => execute(), canExecute == null ? (Predicate<object?>?)null : o => canExecute())
    {
    }


    public bool CanExecute(object? parameter) => _canExecute == null || _canExecute(parameter);
    public void Execute(object? parameter) => _execute(parameter);
}
</file>

<file path="Source\ViewModels\SettingsViewModel.cs">
using Avalonia.Controls;
using Avalonia.Platform.Storage;
using Sonorize.Models;
using Sonorize.Services;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Diagnostics;
using System.Collections.Generic; // Required for List<string>

namespace Sonorize.ViewModels;

public class SettingsViewModel : ViewModelBase
{
    private readonly SettingsService _settingsService;
    private readonly ThemeService _themeService;

    public ObservableCollection<string> MusicDirectories { get; } = new();
    public List<string> InitialMusicDirectories { get; private set; } // To track changes

    private string? _selectedDirectory;
    public string? SelectedDirectory
    {
        get => _selectedDirectory;
        set => SetProperty(ref _selectedDirectory, value, nameof(CanRemoveDirectory));
    }

    public ObservableCollection<string> AvailableThemes { get; } = new();
    private string? _selectedThemeFile;
    public string? SelectedThemeFile
    {
        get => _selectedThemeFile;
        set
        {
            if (SetProperty(ref _selectedThemeFile, value))
            {
                SettingsChanged = true;
            }
        }
    }

    // This flag indicates if any setting that requires action (like reload or restart) has changed.
    public bool SettingsChanged { get; private set; } = false;

    public ICommand AddDirectoryCommand { get; }
    public ICommand RemoveDirectoryCommand { get; }
    public ICommand SaveAndCloseCommand { get; }

    public bool CanRemoveDirectory => SelectedDirectory != null;

    public SettingsViewModel(SettingsService settingsService)
    {
        _settingsService = settingsService;
        _themeService = new ThemeService(null); // Create a temporary instance to list files

        var settings = _settingsService.LoadSettings();
        InitialMusicDirectories = new List<string>(settings.MusicDirectories); // Store initial state

        foreach (var dir in settings.MusicDirectories)
        {
            MusicDirectories.Add(dir);
        }

        foreach (var themeFile in _themeService.GetAvailableThemeFiles())
        {
            AvailableThemes.Add(themeFile);
        }

        SelectedThemeFile = settings.PreferredThemeFileName ?? ThemeService.DefaultThemeFileName;
        if (!AvailableThemes.Contains(SelectedThemeFile) && AvailableThemes.Any())
        {
            SelectedThemeFile = AvailableThemes.First(); // Fallback if saved theme not found
        }

        // Reset SettingsChanged after initial load, as SelectedThemeFile property set might trigger it
        SettingsChanged = false;

        AddDirectoryCommand = new RelayCommand(async owner => await AddDirectory(owner as Window));
        RemoveDirectoryCommand = new RelayCommand(RemoveSelectedDirectory, _ => CanRemoveDirectory);
        SaveAndCloseCommand = new RelayCommand(SaveSettings);

        PropertyChanged += (s, e) => {
            if (e.PropertyName == nameof(SelectedDirectory))
            {
                (RemoveDirectoryCommand as RelayCommand)?.RaiseCanExecuteChanged();
            }
        };
        // Any change to MusicDirectories collection or SelectedThemeFile marks settings as changed.
        MusicDirectories.CollectionChanged += (s, e) => SettingsChanged = true;
    }

    private async Task AddDirectory(Window? owner)
    {
        if (owner == null) return;
        var dialog = new OpenFolderDialog() { Title = "Select Music Directory" };
        var result = await dialog.ShowAsync(owner);
        if (result != null && !string.IsNullOrEmpty(result))
        {
            if (!MusicDirectories.Contains(result))
            {
                MusicDirectories.Add(result);
                // SettingsChanged will be set by the CollectionChanged event handler
            }
        }
    }

    private void RemoveSelectedDirectory(object? parameter)
    {
        if (SelectedDirectory != null)
        {
            MusicDirectories.Remove(SelectedDirectory);
            SelectedDirectory = null;
            // SettingsChanged will be set by the CollectionChanged event handler
        }
    }

    private void SaveSettings(object? parameter)
    {
        var currentSettings = _settingsService.LoadSettings(); // Load current to preserve other settings if any

        // Check if directories actually changed before saving and marking
        bool dirsActuallyChanged = !InitialMusicDirectories.SequenceEqual(MusicDirectories);
        bool themeActuallyChanged = currentSettings.PreferredThemeFileName != SelectedThemeFile;

        if (dirsActuallyChanged)
        {
            currentSettings.MusicDirectories = MusicDirectories.ToList();
            Debug.WriteLine($"[SettingsVM] Saved directories count: {currentSettings.MusicDirectories.Count}");
        }

        if (themeActuallyChanged)
        {
            currentSettings.PreferredThemeFileName = SelectedThemeFile;
            Debug.WriteLine($"[SettingsVM] Saved theme: {SelectedThemeFile}");
        }

        if (dirsActuallyChanged || themeActuallyChanged)
        {
            _settingsService.SaveSettings(currentSettings);
            SettingsChanged = true; // Ensure this is true if anything was actually saved
                                    // Update InitialMusicDirectories to reflect the saved state for subsequent checks if dialog is reopened
            if (dirsActuallyChanged) InitialMusicDirectories = new List<string>(currentSettings.MusicDirectories);
        }
        else
        {
            SettingsChanged = false; // No actual changes were made that need saving.
        }
    }
}
</file>

<file path="Source\ViewModels\ViewModelBase.cs">
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace Sonorize.ViewModels;

public class ViewModelBase : INotifyPropertyChanged
{
    public event PropertyChangedEventHandler? PropertyChanged;

    protected bool SetProperty<T>(ref T field, T value, [CallerMemberName] string? propertyName = null)
    {
        if (EqualityComparer<T>.Default.Equals(field, value))
        {
            return false;
        }

        field = value;
        OnPropertyChanged(propertyName);
        return true;
    }

    protected void OnPropertyChanged([CallerMemberName] string? propertyName = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
</file>

<file path="Source\Views\BrushExtensions.cs">
// Path: Source/Views/MainView.cs
using System;
using Avalonia.Media;

namespace Sonorize.Views;

public static class BrushExtensions
{
    public static IBrush Multiply(this IBrush brush, double factor)
    {
        if (brush is ISolidColorBrush solidBrush)
        {
            var c = solidBrush.Color;
            return new SolidColorBrush(Color.FromArgb(c.A, (byte)Math.Clamp(c.R * factor, 0, 255), (byte)Math.Clamp(c.G * factor, 0, 255), (byte)Math.Clamp(c.B * factor, 0, 255)));
        }
        return brush;
    }
}
</file>

<file path="Source\Views\MainWindow.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Controls.Primitives; // For Thumb, ToggleButton
using Avalonia.Controls.Templates;
using Avalonia.Data;
using Avalonia.Layout;
using Avalonia.Media;
// Removed: using Avalonia.Media.Imaging; 
// Removed: using Avalonia.Styling;
// Removed: using Sonorize.Controls;
// Removed: using Sonorize.Converters;
using Sonorize.Models;
// Removed: using Sonorize.Services;
using Sonorize.ViewModels;
using Sonorize.Views.MainWindowControls;
using System; // For EventArgs
using System.ComponentModel; // For PropertyChangedEventArgs
using System.Diagnostics; // For Debug
using Avalonia.Threading; // Required for Dispatcher

namespace Sonorize.Views;
public class MainWindow : Window
{
    private readonly ThemeColors _theme;
    private ListBox _songListBox;
    private ListBox _artistsListBox;
    private ListBox _albumsListBox;
    private LibraryViewModel? _currentLibraryVM;
    private readonly SharedViewTemplates _sharedViewTemplates;
    private readonly MainTabViewControls _mainTabViewControls;


    public MainWindow(ThemeColors theme)
    {
        _theme = theme;
        _sharedViewTemplates = new SharedViewTemplates(_theme);
        _mainTabViewControls = new MainTabViewControls(_theme, _sharedViewTemplates);

        Title = "Sonorize";
        Width = 950;
        Height = 750;
        MinWidth = 700;
        MinHeight = 500;
        WindowStartupLocation = WindowStartupLocation.CenterScreen;
        Background = _theme.B_BackgroundColor;

        var mainGrid = new Grid
        {
            RowDefinitions =
            [
                new(GridLength.Auto),
                new(GridLength.Auto),
                new(GridLength.Star),
                new(GridLength.Auto),
                new(GridLength.Auto),
                new(GridLength.Auto)
            ]
        };

        var menu = MainMenu.Create(_theme, this);
        Grid.SetRow(menu, 0);
        mainGrid.Children.Add(menu);

        var searchBarPanel = SearchBarPanel.Create(_theme);
        Grid.SetRow(searchBarPanel, 1);
        mainGrid.Children.Add(searchBarPanel);

        var tabControl = _mainTabViewControls.CreateMainTabView(out _songListBox, out _artistsListBox, out _albumsListBox);
        Grid.SetRow(tabControl, 2);
        mainGrid.Children.Add(tabControl);

        var advancedPlaybackPanel = AdvancedPlaybackPanelControls.Create(_theme);
        advancedPlaybackPanel.Bind(Visual.IsVisibleProperty, new Binding("IsAdvancedPanelVisible"));
        Grid.SetRow(advancedPlaybackPanel, 3);
        mainGrid.Children.Add(advancedPlaybackPanel);

        var mainPlaybackControls = MainPlaybackControlsPanel.Create(_theme);
        Grid.SetRow(mainPlaybackControls, 4);
        mainGrid.Children.Add(mainPlaybackControls);

        var statusBar = CreateStatusBar();
        Grid.SetRow(statusBar, 5);
        mainGrid.Children.Add(statusBar);

        Content = mainGrid;

        this.DataContextChanged += MainWindow_DataContextChanged;
    }

    private void MainWindow_DataContextChanged(object? sender, EventArgs e)
    {
        if (_currentLibraryVM != null)
        {
            _currentLibraryVM.PropertyChanged -= LibraryViewModel_PropertyChanged;
            _currentLibraryVM = null;
        }

        if (DataContext is MainWindowViewModel vm && vm.Library != null)
        {
            _currentLibraryVM = vm.Library;
            _currentLibraryVM.PropertyChanged += LibraryViewModel_PropertyChanged;

            // Apply initial display modes for each list
            ApplyListViewDisplayMode(_songListBox, _currentLibraryVM.LibraryViewMode, _sharedViewTemplates.DetailedSongTemplate, _sharedViewTemplates.CompactSongTemplate, _sharedViewTemplates.GridSongTemplate);
            ApplyListViewDisplayMode(_artistsListBox, _currentLibraryVM.ArtistViewMode, _sharedViewTemplates.DetailedArtistTemplate, _sharedViewTemplates.CompactArtistTemplate, _sharedViewTemplates.GridArtistTemplate);
            ApplyListViewDisplayMode(_albumsListBox, _currentLibraryVM.AlbumViewMode, _sharedViewTemplates.DetailedAlbumTemplate, _sharedViewTemplates.CompactAlbumTemplate, _sharedViewTemplates.GridAlbumTemplate);
        }
    }

    private void LibraryViewModel_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (sender is LibraryViewModel lvm)
        {
            if (e.PropertyName == nameof(LibraryViewModel.LibraryViewMode))
            {
                Dispatcher.UIThread.InvokeAsync(() => ApplyListViewDisplayMode(_songListBox, lvm.LibraryViewMode, _sharedViewTemplates.DetailedSongTemplate, _sharedViewTemplates.CompactSongTemplate, _sharedViewTemplates.GridSongTemplate));
            }
            else if (e.PropertyName == nameof(LibraryViewModel.ArtistViewMode))
            {
                Dispatcher.UIThread.InvokeAsync(() => ApplyListViewDisplayMode(_artistsListBox, lvm.ArtistViewMode, _sharedViewTemplates.DetailedArtistTemplate, _sharedViewTemplates.CompactArtistTemplate, _sharedViewTemplates.GridArtistTemplate));
            }
            else if (e.PropertyName == nameof(LibraryViewModel.AlbumViewMode))
            {
                Dispatcher.UIThread.InvokeAsync(() => ApplyListViewDisplayMode(_albumsListBox, lvm.AlbumViewMode, _sharedViewTemplates.DetailedAlbumTemplate, _sharedViewTemplates.CompactAlbumTemplate, _sharedViewTemplates.GridAlbumTemplate));
            }
        }
    }

    // Renamed for clarity
    private void ApplyListViewDisplayMode(ListBox listBox, SongDisplayMode mode, IDataTemplate detailedTemplate, IDataTemplate compactTemplate, IDataTemplate gridTemplate)
    {
        if (listBox == null)
        {
            Debug.WriteLine($"[MainWindow] ApplyListViewDisplayMode called but ListBox target is null. Mode: {mode}");
            return;
        }
        _mainTabViewControls.UpdateListViewMode(mode, listBox, detailedTemplate, compactTemplate, gridTemplate);
    }

    private Border CreateStatusBar()
    {
        var statusBar = new Border { Background = _theme.B_SlightlyLighterBackground, Padding = new Thickness(10, 4), Height = 26 };
        var statusBarText = new TextBlock { Foreground = _theme.B_SecondaryTextColor, VerticalAlignment = VerticalAlignment.Center, FontSize = 11 };
        statusBarText.Bind(TextBlock.TextProperty, new Binding("StatusBarText"));
        statusBar.Child = statusBarText;
        return statusBar;
    }

    protected override void OnClosed(EventArgs e)
    {
        if (_currentLibraryVM != null)
        {
            _currentLibraryVM.PropertyChanged -= LibraryViewModel_PropertyChanged;
        }
        base.OnClosed(e);
    }
}
</file>

<file path="Source\Views\SettingsWindow.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Layout;
using Avalonia.Media;
using Avalonia.Data;
using Sonorize.Models;
using Sonorize.ViewModels;

namespace Sonorize.Views;

public class SettingsWindow : Window
{
    private readonly ThemeColors _theme; // Current theme for styling THIS window

    public SettingsWindow(ThemeColors currentDisplayTheme)
    {
        _theme = currentDisplayTheme;

        // ... (Window properties and color definitions using _theme remain the same) ...
        Title = "Sonorize Settings"; Width = 500; Height = 450; // Increased height for theme selector
        CanResize = false; WindowStartupLocation = WindowStartupLocation.CenterOwner; Icon = null;
        Background = _theme.B_SlightlyLighterBackground;

        var mainPanel = new DockPanel { Margin = new Thickness(15) };

        // --- Header for Directories ---
        var dirHeaderBlock = new TextBlock
        {
            Text = "Music Directories",
            FontSize = 18,
            FontWeight = FontWeight.SemiBold,
            Foreground = _theme.B_TextColor,
            Margin = new Thickness(0, 0, 0, 10)
        };
        // DockPanel.SetDock(dirHeaderBlock, Dock.Top); // We'll use a StackPanel for sections

        // --- Music Directories Section ---
        var directoriesPanel = new DockPanel();
        var dirManagementButtons = new StackPanel { Orientation = Orientation.Vertical, Spacing = 5, Margin = new Thickness(0, 0, 10, 0) };
        DockPanel.SetDock(dirManagementButtons, Dock.Right);
        var addButton = new Button { Content = "Add", Background = _theme.B_ControlBackgroundColor, Foreground = _theme.B_TextColor, HorizontalAlignment = HorizontalAlignment.Stretch };
        addButton.Bind(Button.CommandProperty, new Binding("AddDirectoryCommand")); addButton.CommandParameter = this;
        var removeButton = new Button { Content = "Remove", Background = _theme.B_ControlBackgroundColor, Foreground = _theme.B_TextColor, HorizontalAlignment = HorizontalAlignment.Stretch };
        removeButton.Bind(Button.CommandProperty, new Binding("RemoveDirectoryCommand")); removeButton.Bind(Button.IsEnabledProperty, new Binding("CanRemoveDirectory"));
        dirManagementButtons.Children.Add(addButton); dirManagementButtons.Children.Add(removeButton);
        var directoryListBox = new ListBox { Background = _theme.B_ControlBackgroundColor, BorderThickness = new Thickness(1), BorderBrush = _theme.B_SecondaryTextColor, Foreground = _theme.B_TextColor, Height = 150 }; // Set a height
        directoryListBox.Bind(ItemsControl.ItemsSourceProperty, new Binding("MusicDirectories")); directoryListBox.Bind(ListBox.SelectedItemProperty, new Binding("SelectedDirectory", BindingMode.TwoWay));
        directoriesPanel.Children.Add(dirManagementButtons); directoriesPanel.Children.Add(directoryListBox);

        // --- Theme Selection Section ---
        var themeHeaderBlock = new TextBlock
        {
            Text = "Application Theme",
            FontSize = 16,
            FontWeight = FontWeight.SemiBold,
            Foreground = _theme.B_TextColor,
            Margin = new Thickness(0, 15, 0, 5) // Margin top for separation
        };

        var themeComboBox = new ComboBox
        {
            HorizontalAlignment = HorizontalAlignment.Stretch,
            Background = _theme.B_ControlBackgroundColor,
            Foreground = _theme.B_TextColor,
            BorderBrush = _theme.B_SecondaryTextColor
        };
        themeComboBox.Bind(ItemsControl.ItemsSourceProperty, new Binding("AvailableThemes"));
        themeComboBox.Bind(ComboBox.SelectedItemProperty, new Binding("SelectedThemeFile", BindingMode.TwoWay));

        var themeRestartNotice = new TextBlock
        {
            Text = "A restart is required for theme changes to take full effect.",
            FontSize = 10,
            Foreground = _theme.B_SecondaryTextColor,
            FontStyle = FontStyle.Italic,
            Margin = new Thickness(0, 5, 0, 0),
            TextWrapping = TextWrapping.Wrap
        };

        // --- Layout using a main StackPanel for sections ---
        var sectionsStackPanel = new StackPanel { Orientation = Orientation.Vertical, Spacing = 5 };
        sectionsStackPanel.Children.Add(dirHeaderBlock);
        sectionsStackPanel.Children.Add(directoriesPanel);
        sectionsStackPanel.Children.Add(themeHeaderBlock);
        sectionsStackPanel.Children.Add(themeComboBox);
        sectionsStackPanel.Children.Add(themeRestartNotice);

        // --- Buttons Panel (Bottom) ---
        var buttonsPanel = new StackPanel { Orientation = Orientation.Horizontal, HorizontalAlignment = HorizontalAlignment.Right, Spacing = 10, Margin = new Thickness(0, 20, 0, 0) };
        var saveButton = new Button { Content = "Save & Close", Background = _theme.B_AccentColor, Foreground = _theme.B_AccentForeground, Padding = new Thickness(15, 8), CornerRadius = new CornerRadius(3) };
        saveButton.Click += (s, e) => { if (DataContext is SettingsViewModel vm) { vm.SaveAndCloseCommand.Execute(null); } Close(); };
        var cancelButton = new Button { Content = "Cancel", Background = _theme.B_ControlBackgroundColor, Foreground = _theme.B_TextColor, Padding = new Thickness(15, 8), CornerRadius = new CornerRadius(3) };
        cancelButton.Click += (s, e) => Close();
        buttonsPanel.Children.Add(saveButton); buttonsPanel.Children.Add(cancelButton);

        // Main panel structure
        DockPanel.SetDock(buttonsPanel, Dock.Bottom);
        mainPanel.Children.Add(buttonsPanel);
        mainPanel.Children.Add(sectionsStackPanel); // This will fill the center

        Content = mainPanel;
    }
}
</file>

<file path="Source\Views\MainWindowControls\AdvancedPlaybackPanelControls.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Controls.Primitives; // For Thumb
using Avalonia.Data;
using Avalonia.Layout;
using Avalonia.Media;
using Avalonia.Styling;
using Sonorize.Controls;
using Sonorize.Converters;
using Sonorize.Models; // For ThemeColors
using Sonorize.ViewModels; // For MainWindowViewModel, LoopEditorViewModel

namespace Sonorize.Views.MainWindowControls;

public static class AdvancedPlaybackPanelControls
{
    public static Border Create(ThemeColors theme)
    {
        var panelRoot = new Border
        {
            Background = theme.B_SlightlyLighterBackground,
            Padding = new Thickness(10),
            BorderBrush = theme.B_AccentColor,
            BorderThickness = new Thickness(0, 1, 0, 1),
            MinHeight = 180,
            ClipToBounds = true
        };
        var mainStack = new StackPanel { Spacing = 10 };

        // Speed and Pitch Controls
        var speedPitchGrid = new Grid { ColumnDefinitions = new ColumnDefinitions("Auto,*,Auto,15,Auto,*,Auto"), Margin = new Thickness(0, 0, 0, 5) };
        var speedLabel = new TextBlock { Text = "Tempo:", VerticalAlignment = VerticalAlignment.Center, Foreground = theme.B_TextColor, Margin = new Thickness(0, 0, 5, 0) };
        var speedSlider = new Slider { Minimum = 0.5, Maximum = 2.0, SmallChange = 0.05, LargeChange = 0.25, TickFrequency = 0.25, Foreground = theme.B_AccentColor, Background = theme.B_SecondaryTextColor };
        speedSlider.Styles.Add(new Style(s => s.Is<Thumb>()) { Setters = { new Setter(TemplatedControl.BackgroundProperty, theme.B_AccentColor) } });
        speedSlider.Bind(Slider.ValueProperty, new Binding("Playback.PlaybackSpeed", BindingMode.TwoWay));
        var speedDisplay = new TextBlock { VerticalAlignment = VerticalAlignment.Center, Margin = new Thickness(5, 0), Foreground = theme.B_TextColor, MinWidth = 35, HorizontalAlignment = HorizontalAlignment.Right };
        speedDisplay.Bind(TextBlock.TextProperty, new Binding("Playback.PlaybackSpeedDisplay"));

        var pitchLabel = new TextBlock { Text = "Pitch:", VerticalAlignment = VerticalAlignment.Center, Foreground = theme.B_TextColor, Margin = new Thickness(0, 0, 5, 0) };
        var pitchSlider = new Slider { Minimum = -4, Maximum = 4, SmallChange = 0.1, LargeChange = 0.5, TickFrequency = 0.5, Foreground = theme.B_AccentColor, Background = theme.B_SecondaryTextColor };
        pitchSlider.Styles.Add(new Style(s => s.Is<Thumb>()) { Setters = { new Setter(TemplatedControl.BackgroundProperty, theme.B_AccentColor) } });
        pitchSlider.Bind(Slider.ValueProperty, new Binding("Playback.PlaybackPitch", BindingMode.TwoWay));
        var pitchDisplay = new TextBlock { VerticalAlignment = VerticalAlignment.Center, Margin = new Thickness(5, 0), Foreground = theme.B_TextColor, MinWidth = 45, HorizontalAlignment = HorizontalAlignment.Right };
        pitchDisplay.Bind(TextBlock.TextProperty, new Binding("Playback.PlaybackPitchDisplay"));

        Grid.SetColumn(speedLabel, 0); Grid.SetColumn(speedSlider, 1); Grid.SetColumn(speedDisplay, 2);
        Grid.SetColumn(pitchLabel, 4); Grid.SetColumn(pitchSlider, 5); Grid.SetColumn(pitchDisplay, 6);
        speedPitchGrid.Children.Add(speedLabel); speedPitchGrid.Children.Add(speedSlider); speedPitchGrid.Children.Add(speedDisplay);
        speedPitchGrid.Children.Add(pitchLabel); speedPitchGrid.Children.Add(pitchSlider); speedPitchGrid.Children.Add(pitchDisplay);
        mainStack.Children.Add(speedPitchGrid);

        // Waveform Display
        Color accentColorForLoopRegion = (theme.B_AccentColor as ISolidColorBrush)?.Color ?? Colors.Orange;
        var waveformDisplay = new WaveformDisplayControl
        {
            Height = 80,
            MinHeight = 60,
            Background = theme.B_ControlBackgroundColor,
            WaveformBrush = theme.B_AccentColor,
            PositionMarkerBrush = Brushes.OrangeRed,
            LoopRegionBrush = new SolidColorBrush(accentColorForLoopRegion, 0.3)
        };
        waveformDisplay.Bind(WaveformDisplayControl.WaveformPointsProperty, new Binding("Playback.WaveformRenderData"));
        waveformDisplay.Bind(WaveformDisplayControl.CurrentPositionProperty, new Binding("Playback.CurrentPosition"));
        waveformDisplay.Bind(WaveformDisplayControl.DurationProperty, new Binding("Playback.CurrentSongDuration"));
        waveformDisplay.Bind(WaveformDisplayControl.ActiveLoopProperty, new Binding("Playback.PlaybackService.CurrentSong.SavedLoop"));
        waveformDisplay.SeekRequested += (s, time) =>
        {
            if (s is Control { DataContext: MainWindowViewModel mainWindowVM })
            {
                mainWindowVM.LoopEditor.WaveformSeekCommand.Execute(time);
            }
        };

        var waveformLoadingIndicator = new ProgressBar { IsIndeterminate = true, Height = 5, Margin = new Thickness(0, -5, 0, 0), Foreground = theme.B_AccentColor, Background = Brushes.Transparent };
        waveformLoadingIndicator.Bind(Visual.IsVisibleProperty, new Binding("Playback.IsWaveformLoading"));
        var waveformContainer = new Panel();
        waveformContainer.Children.Add(waveformDisplay); waveformContainer.Children.Add(waveformLoadingIndicator);
        mainStack.Children.Add(waveformContainer);

        // Loop Controls
        var loopControlsOuterPanel = new StackPanel { Orientation = Orientation.Vertical, Spacing = 5, Margin = new Thickness(0, 10, 0, 0) };
        var loopDefinitionLabel = new TextBlock { Text = "Define Loop:", FontSize = 12, FontWeight = FontWeight.SemiBold, Foreground = theme.B_TextColor };
        var loopActionsPanel = new StackPanel { Orientation = Orientation.Horizontal, Spacing = 8, VerticalAlignment = VerticalAlignment.Center };

        var setStartBtn = new Button { Content = "A", FontSize = 12, Padding = new Thickness(10, 5), MinWidth = 40, Background = theme.B_ControlBackgroundColor, Foreground = theme.B_TextColor };
        setStartBtn.Bind(Button.CommandProperty, new Binding("LoopEditor.CaptureLoopStartCandidateCommand"));
        var startDisp = new TextBlock { FontSize = 11, Margin = new Thickness(3, 0), VerticalAlignment = VerticalAlignment.Center, Foreground = theme.B_SecondaryTextColor, MinWidth = 60 };
        startDisp.Bind(TextBlock.TextProperty, new Binding("LoopEditor.NewLoopStartCandidateDisplay"));

        var setEndBtn = new Button { Content = "B", FontSize = 12, Padding = new Thickness(10, 5), MinWidth = 40, Background = theme.B_ControlBackgroundColor, Foreground = theme.B_TextColor };
        setEndBtn.Bind(Button.CommandProperty, new Binding("LoopEditor.CaptureLoopEndCandidateCommand"));
        var endDisp = new TextBlock { FontSize = 11, Margin = new Thickness(3, 0), VerticalAlignment = VerticalAlignment.Center, Foreground = theme.B_SecondaryTextColor, MinWidth = 60 };
        endDisp.Bind(TextBlock.TextProperty, new Binding("LoopEditor.NewLoopEndCandidateDisplay"));

        var saveLoopBtn = new Button { Content = "Save Loop", FontSize = 11, Padding = new Thickness(10, 5), Background = theme.B_AccentColor, Foreground = theme.B_AccentForeground };
        saveLoopBtn.Bind(Button.CommandProperty, new Binding("LoopEditor.SaveLoopCommand"));
        saveLoopBtn.Bind(Button.IsEnabledProperty, new Binding("LoopEditor.CanSaveLoopRegion"));

        var clearLoopBtn = new Button { Content = "Clear Loop", FontSize = 11, Padding = new Thickness(10, 5), Background = theme.B_ControlBackgroundColor, Foreground = theme.B_TextColor };
        clearLoopBtn.Bind(Button.CommandProperty, new Binding("LoopEditor.ClearLoopCommand"));
        var clearLoopBinding = new Binding("PlaybackService.CurrentSong.SavedLoop") { Converter = NotNullToBooleanConverter.Instance };
        clearLoopBtn.Bind(Button.IsEnabledProperty, clearLoopBinding);

        loopActionsPanel.Children.Add(setStartBtn); loopActionsPanel.Children.Add(startDisp);
        loopActionsPanel.Children.Add(setEndBtn); loopActionsPanel.Children.Add(endDisp);
        loopActionsPanel.Children.Add(saveLoopBtn); loopActionsPanel.Children.Add(clearLoopBtn);

        var loopActiveTogglePanel = new StackPanel { Orientation = Orientation.Horizontal, Margin = new Thickness(0, 8, 0, 0), Spacing = 8, VerticalAlignment = VerticalAlignment.Center };
        var loopActiveCheckBox = new CheckBox { Content = "Activate Loop", Foreground = theme.B_TextColor, VerticalAlignment = VerticalAlignment.Center };
        loopActiveCheckBox.Bind(ToggleButton.IsCheckedProperty, new Binding("LoopEditor.IsCurrentLoopActiveUiBinding", BindingMode.TwoWay));
        var loopActiveCheckBoxIsEnabledBinding = new Binding("PlaybackService.CurrentSong.SavedLoop") { Converter = NotNullToBooleanConverter.Instance };
        loopActiveCheckBox.Bind(Control.IsEnabledProperty, loopActiveCheckBoxIsEnabledBinding); // Corrected: Control.IsEnabledProperty
        loopActiveTogglePanel.Children.Add(loopActiveCheckBox);

        loopControlsOuterPanel.Children.Add(loopDefinitionLabel);
        loopControlsOuterPanel.Children.Add(loopActionsPanel);
        loopControlsOuterPanel.Children.Add(loopActiveTogglePanel);
        mainStack.Children.Add(loopControlsOuterPanel);

        panelRoot.Child = mainStack;
        return panelRoot;
    }
}
</file>

<file path="Source\Views\MainWindowControls\MainMenu.cs">
using Avalonia.Controls;
using Avalonia.Data;
using Sonorize.Models; // For ThemeColors
using Sonorize.ViewModels; // For SongDisplayMode enum

namespace Sonorize.Views.MainWindowControls;

public static class MainMenu
{
    public static Menu Create(ThemeColors theme, Window ownerWindow)
    {
        var menu = new Menu
        {
            Background = theme.B_SlightlyLighterBackground,
            Foreground = theme.B_TextColor
        };

        // File Menu
        var fileMenuItem = new MenuItem { Header = "_File", Foreground = theme.B_TextColor };
        var addDirectoryMenuItem = new MenuItem { Header = "_Add Music Directory...", Foreground = theme.B_TextColor };
        addDirectoryMenuItem.Bind(MenuItem.CommandProperty, new Binding("AddDirectoryAndRefreshCommand"));
        addDirectoryMenuItem.CommandParameter = ownerWindow;

        var settingsMenuItem = new MenuItem { Header = "_Settings...", Foreground = theme.B_TextColor };
        settingsMenuItem.Bind(MenuItem.CommandProperty, new Binding("OpenSettingsCommand"));
        settingsMenuItem.CommandParameter = ownerWindow;

        var exitMenuItem = new MenuItem { Header = "E_xit", Foreground = theme.B_TextColor };
        exitMenuItem.Bind(MenuItem.CommandProperty, new Binding("ExitCommand"));

        fileMenuItem.Items.Add(addDirectoryMenuItem);
        fileMenuItem.Items.Add(settingsMenuItem);
        fileMenuItem.Items.Add(new Separator());
        fileMenuItem.Items.Add(exitMenuItem);

        // View Menu
        var viewMenuItem = new MenuItem { Header = "_View", Foreground = theme.B_TextColor };

        // Library View SubMenu
        var libraryViewSubMenu = new MenuItem { Header = "Library View", Foreground = theme.B_TextColor };
        var libDetailed = new MenuItem { Header = "Detailed", Foreground = theme.B_TextColor };
        libDetailed.Bind(MenuItem.CommandProperty, new Binding("Library.SetDisplayModeCommand"));
        libDetailed.CommandParameter = ("Library", SongDisplayMode.Detailed);
        var libCompact = new MenuItem { Header = "Compact", Foreground = theme.B_TextColor };
        libCompact.Bind(MenuItem.CommandProperty, new Binding("Library.SetDisplayModeCommand"));
        libCompact.CommandParameter = ("Library", SongDisplayMode.Compact);
        var libGrid = new MenuItem { Header = "Grid", Foreground = theme.B_TextColor };
        libGrid.Bind(MenuItem.CommandProperty, new Binding("Library.SetDisplayModeCommand"));
        libGrid.CommandParameter = ("Library", SongDisplayMode.Grid);
        libraryViewSubMenu.Items.Add(libDetailed);
        libraryViewSubMenu.Items.Add(libCompact);
        libraryViewSubMenu.Items.Add(libGrid);

        // Artists View SubMenu
        var artistsViewSubMenu = new MenuItem { Header = "Artists View", Foreground = theme.B_TextColor };
        var artDetailed = new MenuItem { Header = "Detailed", Foreground = theme.B_TextColor };
        artDetailed.Bind(MenuItem.CommandProperty, new Binding("Library.SetDisplayModeCommand"));
        artDetailed.CommandParameter = ("Artists", SongDisplayMode.Detailed);
        var artCompact = new MenuItem { Header = "Compact", Foreground = theme.B_TextColor };
        artCompact.Bind(MenuItem.CommandProperty, new Binding("Library.SetDisplayModeCommand"));
        artCompact.CommandParameter = ("Artists", SongDisplayMode.Compact);
        var artGrid = new MenuItem { Header = "Grid", Foreground = theme.B_TextColor };
        artGrid.Bind(MenuItem.CommandProperty, new Binding("Library.SetDisplayModeCommand"));
        artGrid.CommandParameter = ("Artists", SongDisplayMode.Grid);
        artistsViewSubMenu.Items.Add(artDetailed);
        artistsViewSubMenu.Items.Add(artCompact);
        artistsViewSubMenu.Items.Add(artGrid);

        // Albums View SubMenu
        var albumsViewSubMenu = new MenuItem { Header = "Albums View", Foreground = theme.B_TextColor };
        var albDetailed = new MenuItem { Header = "Detailed", Foreground = theme.B_TextColor };
        albDetailed.Bind(MenuItem.CommandProperty, new Binding("Library.SetDisplayModeCommand"));
        albDetailed.CommandParameter = ("Albums", SongDisplayMode.Detailed);
        var albCompact = new MenuItem { Header = "Compact", Foreground = theme.B_TextColor };
        albCompact.Bind(MenuItem.CommandProperty, new Binding("Library.SetDisplayModeCommand"));
        albCompact.CommandParameter = ("Albums", SongDisplayMode.Compact);
        var albGrid = new MenuItem { Header = "Grid", Foreground = theme.B_TextColor };
        albGrid.Bind(MenuItem.CommandProperty, new Binding("Library.SetDisplayModeCommand"));
        albGrid.CommandParameter = ("Albums", SongDisplayMode.Grid);
        albumsViewSubMenu.Items.Add(albDetailed);
        albumsViewSubMenu.Items.Add(albCompact);
        albumsViewSubMenu.Items.Add(albGrid);

        viewMenuItem.Items.Add(libraryViewSubMenu);
        viewMenuItem.Items.Add(artistsViewSubMenu);
        viewMenuItem.Items.Add(albumsViewSubMenu);

        menu.Items.Add(fileMenuItem);
        menu.Items.Add(viewMenuItem);
        return menu;
    }
}
</file>

<file path="Source\Views\MainWindowControls\MainPlaybackControlsPanel.cs">
using Avalonia;
using Avalonia.Controls.Primitives;
using Avalonia.Controls;
using Avalonia.Data;
using Avalonia.Layout;
using Avalonia.Media;
using Avalonia.Styling;
using Avalonia;
using Avalonia.Data.Converters; // Added required using directive for FuncValueConverter
using Avalonia.Controls.Templates; // Required for FuncDataTemplate

using Sonorize.Converters;
using Sonorize.Models;
using Sonorize.Views.MainWindowControls;
using Avalonia.Media.Imaging; // Required for BitmapInterpolationMode
using Sonorize.ViewModels; // Required for RepeatMode enum
using System; // Required for Func
using System.Diagnostics; // Added for Debug

namespace Sonorize.Views.MainWindowControls;

public static class MainPlaybackControlsPanel
{
    public static Grid Create(ThemeColors theme) // Root is a Grid
    {
        // Previous Button
        var previousButton = new Button
        {
            Content = "<",
            Background = theme.B_SlightlyLighterBackground,
            Foreground = theme.B_TextColor,
            BorderBrush = theme.B_ControlBackgroundColor,
            BorderThickness = new Thickness(1),
            Width = 32,
            Height = 32,
            CornerRadius = new CornerRadius(16),
            Padding = new Thickness(0),
            FontSize = 16,
            HorizontalContentAlignment = HorizontalAlignment.Center,
            VerticalContentAlignment = VerticalAlignment.Center
        };
        // Bind to Library.PreviousTrackCommand
        previousButton.Bind(Button.CommandProperty, new Binding("Library.PreviousTrackCommand"));
        // IsEnabled is controlled by the command's CanExecute

        var mainPlayPauseButton = new Button
        {
            Background = theme.B_SlightlyLighterBackground,
            Foreground = theme.B_TextColor,
            BorderBrush = theme.B_AccentColor,
            BorderThickness = new Thickness(1),
            Width = 38,
            Height = 38,
            CornerRadius = new CornerRadius(19),
            Padding = new Thickness(0),
            FontSize = 18,
            HorizontalAlignment = HorizontalAlignment.Center,
            VerticalContentAlignment = VerticalAlignment.Center,
            HorizontalContentAlignment = HorizontalAlignment.Center
        };
        mainPlayPauseButton.Bind(Button.CommandProperty, new Binding("Playback.PlayPauseResumeCommand"));
        mainPlayPauseButton.Bind(Button.ContentProperty, new Binding("Playback.IsPlaying") { Converter = BooleanToPlayPauseIconConverter.Instance });

        var nextButton = new Button
        {
            Content = ">",
            Background = theme.B_SlightlyLighterBackground,
            Foreground = theme.B_TextColor,
            BorderBrush = theme.B_ControlBackgroundColor,
            BorderThickness = new Thickness(1),
            Width = 32,
            Height = 32,
            CornerRadius = new CornerRadius(16),
            Padding = new Thickness(0),
            FontSize = 16,
            HorizontalContentAlignment = HorizontalAlignment.Center,
            VerticalContentAlignment = VerticalAlignment.Center
        };
        // Bind to Library.NextTrackCommand
        nextButton.Bind(Button.CommandProperty, new Binding("Library.NextTrackCommand"));
        // IsEnabled is controlled by the command's CanExecute


        // --- Shuffle and Loop/Repeat Buttons ---

        var shuffleButton = new ToggleButton
        {
            // Content is bound via converter directly
            Foreground = theme.B_SecondaryTextColor, // Default color (off) - This will be overridden by the style
            Background = Brushes.Transparent,
            BorderBrush = theme.B_ControlBackgroundColor, // Default border color (off) - This will be overridden by the style
            BorderThickness = new Thickness(1),
            CornerRadius = new CornerRadius(4), // Add some rounded corners
            Padding = new Thickness(5),
            VerticalAlignment = VerticalAlignment.Center,
            HorizontalAlignment = HorizontalAlignment.Center, // Center the button horizontally
            VerticalContentAlignment = VerticalAlignment.Center, // Center content vertically
            HorizontalContentAlignment = HorizontalAlignment.Center, // Center content horizontally
            FontSize = 18, // Set font size directly on button
            FontFamily = "Segoe UI Symbol, Arial", // Set font family directly on button
            ContentTemplate = null, // No explicit template needed for simple string content
            Width = 32, // Fixed width for icon
            Height = 32 // Fixed height for icon
        };
        // Bind IsChecked to Playback.ShuffleEnabled (TwoWay) - This is essential for the toggle state
        // This binding, when checked/unchecked by user click, will trigger the ShuffleEnabled setter in the VM.
        shuffleButton.Bind(ToggleButton.IsCheckedProperty, new Binding("Playback.ShuffleEnabled", BindingMode.TwoWay));
        // Bind Content directly using the converter based on the *ViewModel's* ShuffleEnabled state
        shuffleButton.Bind(ContentControl.ContentProperty, new Binding("Playback.ShuffleEnabled") { Converter = BooleanToShuffleIconConverter.Instance });

        // REMOVED: Explicit Button.Command binding. The TwoWay IsChecked binding handles the toggle.
        // shuffleButton.Bind(Button.CommandProperty, new Binding("Playback.ToggleShuffleCommand"));

        Debug.WriteLine($"[View] Shuffle Button Content Bound Directly to Playback.ShuffleEnabled with BooleanToShuffleIconConverter. Command binding removed.");


        // Change Foreground color based on IsChecked state (using the FuncValueConverter)
        shuffleButton[!ToggleButton.ForegroundProperty] = new Binding("IsChecked")
        {
            Source = shuffleButton,
            Converter = new FuncValueConverter<bool, IBrush>(isChecked => isChecked ? theme.B_AccentColor : theme.B_SecondaryTextColor)
        };
        // Change BorderBrush color based on IsChecked state for a stronger visual cue (using the FuncValueConverter)
        shuffleButton[!ToggleButton.BorderBrushProperty] = new Binding("IsChecked")
        {
            Source = shuffleButton,
            Converter = new FuncValueConverter<bool, IBrush>(isChecked => isChecked ? theme.B_AccentColor : theme.B_ControlBackgroundColor)
        };
        // Ensure button is enabled only when a song is loaded
        shuffleButton.Bind(Control.IsEnabledProperty, new Binding("Playback.HasCurrentSong"));


        var repeatModeButton = new ToggleButton // Renamed from loopButton
        {
            // Content is bound via converter directly
            Foreground = theme.B_SecondaryTextColor, // Default color (off) - Will be overridden by style
            Background = Brushes.Transparent,
            BorderBrush = theme.B_ControlBackgroundColor, // Default border color (off) - Will be overridden by style
            BorderThickness = new Thickness(1),
            CornerRadius = new CornerRadius(4), // Add some rounded corners
            Padding = new Thickness(5),
            VerticalAlignment = VerticalAlignment.Center,
            HorizontalAlignment = HorizontalAlignment.Center, // Center the button horizontally
            VerticalContentAlignment = VerticalAlignment.Center, // Center content vertically
            HorizontalContentAlignment = HorizontalAlignment.Center, // Center content horizontally
            FontSize = 18, // Use larger font size for icons
            FontFamily = "Segoe UI Symbol, Arial", // Explicitly set font family for symbols
            ContentTemplate = null, // No explicit template needed for simple string content
            Width = 32, // Fixed width for icon
            Height = 32 // Fixed height for icon
        };
        // Bind Content to Playback.RepeatMode (using a converter to show state) - Renamed
        repeatModeButton.Bind(ToggleButton.ContentProperty, new Binding("Playback.RepeatMode")
        {
            Converter = new FuncValueConverter<RepeatMode, string>(mode => mode switch
            {
                RepeatMode.None => "â€•", // Horizontal Bar: Do Nothing / Stop
                RepeatMode.PlayOnce => "â‚", // Subscript 1: Play list once
                RepeatMode.RepeatOne => "ðŸ”‚", // Repeat One Button: Repeat current song
                RepeatMode.RepeatAll => "ðŸ”", // Repeat Button: Repeat all songs
                _ => "?" // Fallback icon
            })
        });
        // Change foreground color based on RepeatMode state (if not None - i.e. any repeat/cycle is active)
        repeatModeButton[!ToggleButton.ForegroundProperty] = new Binding("Playback.RepeatMode")
        {
            // Accent color for PlayOnce, RepeatOne, RepeatAll. Secondary for None.
            Converter = new FuncValueConverter<RepeatMode, IBrush>(mode => mode != RepeatMode.None ? theme.B_AccentColor : theme.B_SecondaryTextColor)
        };
        // Change BorderBrush color based on RepeatMode state (if not None - i.e. any repeat/cycle is active)
        repeatModeButton[!ToggleButton.BorderBrushProperty] = new Binding("Playback.RepeatMode")
        {
            // Accent color for PlayOnce, RepeatOne, RepeatAll. ControlBackground for None.
            Converter = new FuncValueConverter<RepeatMode, IBrush>(mode => mode != RepeatMode.None ? theme.B_AccentColor : theme.B_ControlBackgroundColor)
        };
        // Bind IsChecked to Playback.IsRepeatActive (ViewModel calculates this based on RepeatMode != None)
        repeatModeButton.Bind(ToggleButton.IsCheckedProperty, new Binding("Playback.IsRepeatActive"));
        // Bind Command to Playback.CycleRepeatModeCommand
        repeatModeButton.Bind(Button.CommandProperty, new Binding("Playback.CycleRepeatModeCommand"));
        // Ensure button is enabled only when a song is loaded
        repeatModeButton.Bind(Control.IsEnabledProperty, new Binding("Playback.HasCurrentSong"));


        // --- Combined Playback Controls Panel (Shuffle + Nav Buttons + Loop) ---
        // This stack panel holds the core playback buttons including the mode toggles
        var combinedPlaybackButtonControlsPanel = new StackPanel
        {
            Orientation = Orientation.Horizontal,
            Spacing = 10, // Space between buttons
            HorizontalAlignment = HorizontalAlignment.Center, // Center buttons within this stack panel
            VerticalAlignment = VerticalAlignment.Center,
            Margin = new Thickness(0)
        };

        // Add the buttons in the desired order (Shuffle - Previous - Play/Pause - Next - Repeat Mode)
        combinedPlaybackButtonControlsPanel.Children.Add(shuffleButton);
        combinedPlaybackButtonControlsPanel.Children.Add(previousButton);
        combinedPlaybackButtonControlsPanel.Children.Add(mainPlayPauseButton);
        combinedPlaybackButtonControlsPanel.Children.Add(nextButton);
        combinedPlaybackButtonControlsPanel.Children.Add(repeatModeButton); // Added the renamed repeat button


        var toggleAdvPanelButton = new Button
        {
            Content = "+",
            Background = theme.B_SlightlyLighterBackground,
            Foreground = theme.B_TextColor, // Default color
            BorderBrush = theme.B_ControlBackgroundColor, // Default border color
            BorderThickness = new Thickness(1),
            CornerRadius = new CornerRadius(3),
            Padding = new Thickness(8, 4),
            MinWidth = 30, // Give it a minimum size to occupy space
            FontWeight = FontWeight.Bold,
            Width = 32, // Fixed width for consistency
            Height = 32 // Fixed height for consistency
        };
        // Change BorderBrush color based on IsAdvancedPanelVisible
        toggleAdvPanelButton[!Button.BorderBrushProperty] = new Binding("IsAdvancedPanelVisible")
        {
            Converter = new FuncValueConverter<bool, IBrush>(isVisible => isVisible ? theme.B_AccentColor : theme.B_ControlBackgroundColor)
        };
        toggleAdvPanelButton[!Button.ForegroundProperty] = new Binding("IsAdvancedPanelVisible")
        {
            Converter = new FuncValueConverter<bool, IBrush>(isVisible => isVisible ? theme.B_AccentColor : theme.B_TextColor)
        };
        toggleAdvPanelButton.Bind(Button.CommandProperty, new Binding("ToggleAdvancedPanelCommand"));
        toggleAdvPanelButton.Bind(Control.IsEnabledProperty, new Binding("Playback.HasCurrentSong"));


        var rightControlsPanel = new StackPanel // Holds toggle button
        {
            Orientation = Orientation.Horizontal,
            Spacing = 5,
            VerticalAlignment = VerticalAlignment.Center,
            HorizontalAlignment = HorizontalAlignment.Right, // Align to the right within its grid cell
            Margin = new Thickness(0, 0, 10, 0) // Margin from the right edge of the grid cell
            // MinWidth/Width could be added here if needed to reserve space even when invisible
        };
        rightControlsPanel.Children.Add(toggleAdvPanelButton);

        // TextBlock for Current Time
        var currentTimeTextBlock = new TextBlock
        {
            Foreground = theme.B_SecondaryTextColor, // Use secondary color
            FontSize = 11,
            VerticalAlignment = VerticalAlignment.Center,
            Margin = new Thickness(0, 0, 5, 0), // Margin to the right of the text
            MinWidth = 40, // Ensure enough space for MM:SS
            HorizontalAlignment = HorizontalAlignment.Left // Explicitly left align within its grid cell
        };
        currentTimeTextBlock.Bind(TextBlock.TextProperty, new Binding("Playback.CurrentTimeDisplay"));
        currentTimeTextBlock.Bind(Visual.IsVisibleProperty, new Binding("Playback.HasCurrentSong"));

        // TextBlock for Total Time
        var totalTimeTextBlock = new TextBlock
        {
            Foreground = theme.B_SecondaryTextColor, // Use secondary color
            FontSize = 11,
            VerticalAlignment = VerticalAlignment.Center,
            Margin = new Thickness(5, 0, 0, 0), // Margin to the left of the text
            MinWidth = 40, // Ensure enough space for MM:SS
            HorizontalAlignment = HorizontalAlignment.Right // Explicitly right align within its grid cell
        };
        totalTimeTextBlock.Bind(TextBlock.TextProperty, new Binding("Playback.TotalTimeDisplay"));
        totalTimeTextBlock.Bind(Visual.IsVisibleProperty, new Binding("Playback.HasCurrentSong"));


        var mainPlaybackSlider = new Slider
        {
            Name = "MainPlaybackSliderInstance",
            Minimum = 0,
            VerticalAlignment = VerticalAlignment.Center,
            Background = theme.B_SecondaryTextColor,
            Foreground = theme.B_AccentColor,
            HorizontalAlignment = HorizontalAlignment.Stretch // Allow slider to fill the available space in its column
        };
        mainPlaybackSlider.Styles.Add(new Style(s => s.Is<Thumb>())
        {
            Setters =
            {
                new Setter(Thumb.WidthProperty, 0.0),
                new Setter(Thumb.HeightProperty, 0.0),
                new Setter(Thumb.OpacityProperty, 0.0) // Hide the thumb visually
            }
        });
        mainPlaybackSlider.Bind(Slider.MaximumProperty, new Binding("Playback.CurrentSongDurationSeconds"));
        mainPlaybackSlider.Bind(Slider.ValueProperty, new Binding("Playback.CurrentPositionSeconds", BindingMode.TwoWay));
        mainPlaybackSlider.Bind(Control.IsEnabledProperty, new Binding("Playback.HasCurrentSong"));


        // Use a Grid to place time text blocks next to the slider
        var timeSliderGrid = new Grid
        {
            // Three columns: Auto (CurrentTime), * (Slider), Auto (TotalTime)
            ColumnDefinitions = new ColumnDefinitions("Auto,*,Auto"),
            VerticalAlignment = VerticalAlignment.Center,
            Height = 30, // Fixed height
            MinWidth = 500, // Ensure minimum width for layout stability
            HorizontalAlignment = HorizontalAlignment.Stretch // Stretch to fill the center container
        };

        // Place controls in the grid columns
        Grid.SetColumn(currentTimeTextBlock, 0);
        Grid.SetColumn(mainPlaybackSlider, 1);
        Grid.SetColumn(totalTimeTextBlock, 2);

        timeSliderGrid.Children.Add(currentTimeTextBlock);
        timeSliderGrid.Children.Add(mainPlaybackSlider);
        timeSliderGrid.Children.Add(totalTimeTextBlock);


        // --- Center Playback Controls Stack (Combined Buttons Panel + Slider) ---
        // This stack panel contains the combined button panel (including mode toggles) and the time/slider grid.
        var centerPlaybackControlsStack = new StackPanel
        {
            Orientation = Orientation.Vertical,
            Margin = new Thickness(0, 5, 0, 0),
            Spacing = 8, // Space between the button row and the slider row
            HorizontalAlignment = HorizontalAlignment.Center, // Center this stack panel within its parent grid cell
            VerticalAlignment = VerticalAlignment.Center
        };
        // Add the combined button panel (now includes shuffle/loop, prev/play/next)
        centerPlaybackControlsStack.Children.Add(combinedPlaybackButtonControlsPanel);
        centerPlaybackControlsStack.Children.Add(timeSliderGrid);


        // --- Currently Playing Song Info Panel (Bottom Left) ---
        var songInfoPanel = new StackPanel
        {
            Orientation = Orientation.Horizontal,
            VerticalAlignment = VerticalAlignment.Center, // Center vertically in its grid cell
            HorizontalAlignment = HorizontalAlignment.Left, // Align to the left edge of its grid cell
            Margin = new Thickness(10, 0, 0, 0), // Margin from the left edge of the grid cell
            Spacing = 8,
            // Add MaxWidth to prevent text pushing content, trimming is handled by TextBlock MaxWidth/TextTrimming
            // We rely on the root Grid column definition to prevent pushing the center.
        };
        songInfoPanel.Bind(Visual.IsVisibleProperty, new Binding("Playback.HasCurrentSong")); // Only visible when a song is loaded

        // MODIFIED: Increased thumbnail size from 48x48 to 64x64
        var thumbnailImage = new Image
        {
            Width = 64, // Increased size
            Height = 64, // Increased size
            Source = null, // Will be bound
            Stretch = Stretch.UniformToFill,
            VerticalAlignment = VerticalAlignment.Center
        };
        RenderOptions.SetBitmapInterpolationMode(thumbnailImage, BitmapInterpolationMode.HighQuality);
        thumbnailImage.Bind(Image.SourceProperty, new Binding("Playback.CurrentSong.Thumbnail"));

        var textStack = new StackPanel
        {
            Orientation = Orientation.Vertical,
            VerticalAlignment = VerticalAlignment.Center,
            Spacing = 1
        };

        var titleTextBlock = new TextBlock
        {
            Text = "Unknown Title", // Default, will be bound
            FontSize = 14,
            FontWeight = FontWeight.SemiBold,
            Foreground = theme.B_TextColor,
            TextTrimming = TextTrimming.CharacterEllipsis, // Crucial for preventing overflow
            VerticalAlignment = VerticalAlignment.Center,
            MaxWidth = 200 // Limit width of the text itself
        };
        titleTextBlock.Bind(TextBlock.TextProperty, new Binding("Playback.CurrentSong.Title"));

        var artistTextBlock = new TextBlock
        {
            Text = "Unknown Artist", // Default, will be bound
            FontSize = 11,
            Foreground = theme.B_SecondaryTextColor,
            TextTrimming = TextTrimming.CharacterEllipsis, // Crucial for preventing overflow
            VerticalAlignment = VerticalAlignment.Center,
            MaxWidth = 200 // Limit width of the text itself
        };
        artistTextBlock.Bind(TextBlock.TextProperty, new Binding("Playback.CurrentSong.Artist"));

        textStack.Children.Add(titleTextBlock);
        textStack.Children.Add(artistTextBlock);

        songInfoPanel.Children.Add(thumbnailImage);
        songInfoPanel.Children.Add(textStack);


        // --- Main Grid Layout (Restored Single Column Centering) ---
        // Use a single star (*) column. All children are placed in this column.
        // Their HorizontalAlignment determines their position within the column.
        // The centerPlaybackControlsStack has HorizontalAlignment.Center, ensuring it's centered
        // regardless of the width of the left (songInfoPanel) or right (rightControlsPanel) elements.
        var outerGrid = new Grid // This is the root panel
        {
            Background = theme.B_BackgroundColor,
            Margin = new Thickness(0, 5, 0, 5), // Vertical margin for the whole control
            HorizontalAlignment = HorizontalAlignment.Stretch,
            RowDefinitions = new RowDefinitions("Auto"), // Single row, height is Auto based on content
            ColumnDefinitions = new ColumnDefinitions("*") // Single column spanning the width
        };

        // Place all panels in the single column (column 0).
        // Their HorizontalAlignment will handle horizontal positioning.
        Grid.SetColumn(songInfoPanel, 0);
        Grid.SetColumn(centerPlaybackControlsStack, 0);
        Grid.SetColumn(rightControlsPanel, 0);

        // Add children in any order; their position is determined by grid layout and alignment.
        outerGrid.Children.Add(songInfoPanel);
        outerGrid.Children.Add(centerPlaybackControlsStack);
        outerGrid.Children.Add(rightControlsPanel);

        return outerGrid;
    }
}
</file>

<file path="Source\Views\MainWindowControls\MainTabViewControls.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Controls.Primitives;
using Avalonia.Controls.Templates;
using Avalonia.Data;
using Avalonia.Layout;
using Avalonia.Media;
using Avalonia.Media.Imaging;
using Avalonia.Styling;
using Sonorize.Models;
using Sonorize.ViewModels;
using System.Diagnostics;

namespace Sonorize.Views.MainWindowControls
{
    public class MainTabViewControls
    {
        private readonly ThemeColors _theme;
        private readonly SharedViewTemplates _sharedViewTemplates; // Changed from SongListTemplates
        private ListBox? _songListBoxInstance;
        private ListBox? _artistsListBoxInstance; // Added
        private ListBox? _albumsListBoxInstance;  // Added

        public MainTabViewControls(ThemeColors theme, SharedViewTemplates sharedViewTemplates) // Changed parameter type
        {
            _theme = theme;
            _sharedViewTemplates = sharedViewTemplates;
        }

        public TabControl CreateMainTabView(out ListBox songListBox, out ListBox artistsListBox, out ListBox albumsListBox) // Added out params
        {
            var tabControl = new TabControl
            {
                Background = _theme.B_BackgroundColor,
                Margin = new Thickness(10, 5, 10, 5),
                BorderThickness = new Thickness(0),
                Padding = new Thickness(0)
            };
            tabControl.Bind(TabControl.SelectedIndexProperty, new Binding("ActiveTabIndex", BindingMode.TwoWay));

            var tabItemStyle = new Style(s => s.Is<TabItem>());
            tabItemStyle.Setters.Add(new Setter(TabItem.BackgroundProperty, _theme.B_BackgroundColor));
            tabItemStyle.Setters.Add(new Setter(TabItem.ForegroundProperty, _theme.B_SecondaryTextColor));
            tabItemStyle.Setters.Add(new Setter(TabItem.PaddingProperty, new Thickness(12, 7)));
            tabItemStyle.Setters.Add(new Setter(TabItem.FontSizeProperty, 13.0));
            tabItemStyle.Setters.Add(new Setter(TabItem.FontWeightProperty, FontWeight.SemiBold));
            tabItemStyle.Setters.Add(new Setter(TabItem.BorderThicknessProperty, new Thickness(0)));
            tabItemStyle.Setters.Add(new Setter(TabItem.BorderBrushProperty, Brushes.Transparent));

            var selectedTabItemStyle = new Style(s => s.Is<TabItem>().Class(":selected"));
            selectedTabItemStyle.Setters.Add(new Setter(TabItem.BackgroundProperty, _theme.B_BackgroundColor));
            selectedTabItemStyle.Setters.Add(new Setter(TabItem.ForegroundProperty, _theme.B_TextColor));

            var pointerOverTabItemStyle = new Style(s => s.Is<TabItem>().Class(":pointerover").Not(x => x.Class(":selected")));
            pointerOverTabItemStyle.Setters.Add(new Setter(TabItem.BackgroundProperty, _theme.B_SlightlyLighterBackground));
            pointerOverTabItemStyle.Setters.Add(new Setter(TabItem.ForegroundProperty, _theme.B_TextColor));

            tabControl.Styles.Add(tabItemStyle);
            tabControl.Styles.Add(selectedTabItemStyle);
            tabControl.Styles.Add(pointerOverTabItemStyle);

            var libraryTab = new TabItem
            {
                Header = "LIBRARY",
                Content = CreateSongListScrollViewer()
            };

            var artistsTab = new TabItem
            {
                Header = "ARTISTS",
                Content = CreateArtistsListScrollViewer()
            };

            var albumsTab = new TabItem
            {
                Header = "ALBUMS",
                Content = CreateAlbumsListScrollViewer()
            };

            tabControl.Items.Add(libraryTab);
            tabControl.Items.Add(artistsTab);
            tabControl.Items.Add(albumsTab);

            songListBox = _songListBoxInstance!;
            artistsListBox = _artistsListBoxInstance!; // Assign out param
            albumsListBox = _albumsListBoxInstance!;   // Assign out param
            return tabControl;
        }

        private ScrollViewer CreateSongListScrollViewer()
        {
            _songListBoxInstance = new ListBox
            {
                Background = _theme.B_ListBoxBackground,
                BorderThickness = new Thickness(0),
                Margin = new Thickness(10),
                Name = "SongListBox"
            };

            // Common ListBoxItem styles
            ApplyListBoxItemStyles(_songListBoxInstance);

            _songListBoxInstance.Bind(ItemsControl.ItemsSourceProperty, new Binding("Library.FilteredSongs"));
            _songListBoxInstance.Bind(ListBox.SelectedItemProperty, new Binding("Library.SelectedSong", BindingMode.TwoWay));

            _songListBoxInstance.ItemTemplate = _sharedViewTemplates.DetailedSongTemplate;
            _songListBoxInstance.ItemsPanel = _sharedViewTemplates.StackPanelItemsPanelTemplate;

            return new ScrollViewer { Content = _songListBoxInstance, Padding = new Thickness(0, 0, 0, 5), HorizontalScrollBarVisibility = ScrollBarVisibility.Disabled };
        }

        private ScrollViewer CreateArtistsListScrollViewer()
        {
            _artistsListBoxInstance = new ListBox
            {
                Background = _theme.B_ListBoxBackground,
                BorderThickness = new Thickness(0),
                Margin = new Thickness(10),
                Name = "ArtistsListBox"
            };
            ApplyListBoxItemStyles(_artistsListBoxInstance);

            _artistsListBoxInstance.Bind(ItemsControl.ItemsSourceProperty, new Binding("Library.Artists"));
            _artistsListBoxInstance.Bind(ListBox.SelectedItemProperty, new Binding("Library.SelectedArtist", BindingMode.TwoWay));

            _artistsListBoxInstance.ItemTemplate = _sharedViewTemplates.DetailedArtistTemplate;
            _artistsListBoxInstance.ItemsPanel = _sharedViewTemplates.StackPanelItemsPanelTemplate;

            return new ScrollViewer { Content = _artistsListBoxInstance, Padding = new Thickness(0, 0, 0, 5), HorizontalScrollBarVisibility = ScrollBarVisibility.Disabled };
        }

        private ScrollViewer CreateAlbumsListScrollViewer()
        {
            _albumsListBoxInstance = new ListBox
            {
                Background = _theme.B_ListBoxBackground,
                BorderThickness = new Thickness(0),
                Margin = new Thickness(10),
                Name = "AlbumsListBox"
            };
            ApplyListBoxItemStyles(_albumsListBoxInstance);

            _albumsListBoxInstance.Bind(ItemsControl.ItemsSourceProperty, new Binding("Library.Albums"));
            _albumsListBoxInstance.Bind(ListBox.SelectedItemProperty, new Binding("Library.SelectedAlbum", BindingMode.TwoWay));

            _albumsListBoxInstance.ItemTemplate = _sharedViewTemplates.DetailedAlbumTemplate;
            _albumsListBoxInstance.ItemsPanel = _sharedViewTemplates.StackPanelItemsPanelTemplate;

            return new ScrollViewer { Content = _albumsListBoxInstance, Padding = new Thickness(0, 0, 0, 5), HorizontalScrollBarVisibility = ScrollBarVisibility.Disabled };
        }

        private void ApplyListBoxItemStyles(ListBox listBox)
        {
            listBox.Styles.Add(new Style(s => s.Is<ListBoxItem>())
            {
                Setters = {
                    new Setter(TemplatedControl.BackgroundProperty, _theme.B_ListBoxBackground),
                    new Setter(TextBlock.ForegroundProperty, _theme.B_TextColor),
                    new Setter(ListBoxItem.PaddingProperty, new Thickness(3)) // Default padding, templates can override
                }
            });
            listBox.Styles.Add(new Style(s => s.Is<ListBoxItem>().Class(":pointerover").Not(xx => xx.Class(":selected")))
            { Setters = { new Setter(TemplatedControl.BackgroundProperty, _theme.B_ControlBackgroundColor) } });
            listBox.Styles.Add(new Style(s => s.Is<ListBoxItem>().Class(":selected"))
            {
                Setters = {
                    new Setter(TemplatedControl.BackgroundProperty, _theme.B_AccentColor),
                    new Setter(TextBlock.ForegroundProperty, _theme.B_AccentForeground)
                }
            });
            listBox.Styles.Add(new Style(s => s.Is<ListBoxItem>().Class(":selected").Class(":pointerover"))
            {
                Setters = {
                    new Setter(TemplatedControl.BackgroundProperty, _theme.B_AccentColor), // Keep accent when selected and hovered
                    new Setter(TextBlock.ForegroundProperty, _theme.B_AccentForeground)
                }
            });
        }

        // Renamed and generalized
        public void UpdateListViewMode(SongDisplayMode mode, ListBox listBox, IDataTemplate detailedTemplate, IDataTemplate compactTemplate, IDataTemplate gridTemplate)
        {
            if (listBox == null)
            {
                Debug.WriteLine($"[MainTabViewControls] UpdateListViewMode called but target ListBox is null.");
                return;
            }

            Debug.WriteLine($"[MainTabViewControls] Applying display mode: {mode} to ListBox: {listBox.Name}");
            var scrollViewer = listBox.Parent as ScrollViewer;

            switch (mode)
            {
                case SongDisplayMode.Detailed:
                    listBox.ItemTemplate = detailedTemplate;
                    listBox.ItemsPanel = _sharedViewTemplates.StackPanelItemsPanelTemplate;
                    if (scrollViewer != null) scrollViewer.HorizontalScrollBarVisibility = ScrollBarVisibility.Disabled;
                    break;
                case SongDisplayMode.Compact:
                    listBox.ItemTemplate = compactTemplate;
                    listBox.ItemsPanel = _sharedViewTemplates.StackPanelItemsPanelTemplate;
                    if (scrollViewer != null) scrollViewer.HorizontalScrollBarVisibility = ScrollBarVisibility.Disabled;
                    break;
                case SongDisplayMode.Grid:
                    listBox.ItemTemplate = gridTemplate;
                    listBox.ItemsPanel = _sharedViewTemplates.WrapPanelItemsPanelTemplate;
                    if (scrollViewer != null) scrollViewer.HorizontalScrollBarVisibility = ScrollBarVisibility.Disabled;
                    break;
            }
        }
    }
}
</file>

<file path="Source\Views\MainWindowControls\SearchBarPanels.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Data;
using Avalonia.Styling;
using Sonorize.Models; // For ThemeColors
using Sonorize.ViewModels; // Required for Binding

namespace Sonorize.Views.MainWindowControls;

public static class SearchBarPanel
{
    public static Panel Create(ThemeColors theme)
    {
        var searchBox = new TextBox
        {
            Watermark = "Search songs by title, artist, or album...",
            Margin = new Thickness(10, 5, 10, 5),
            Padding = new Thickness(10, 7),
            Background = theme.B_SlightlyLighterBackground,
            Foreground = theme.B_TextColor,
            BorderBrush = theme.B_ControlBackgroundColor,
            BorderThickness = new Thickness(1),
            CornerRadius = new CornerRadius(4),
            FontSize = 14
        };
        // Bind to Library.SearchQuery
        searchBox.Bind(TextBox.TextProperty, new Binding("Library.SearchQuery", BindingMode.TwoWay));

        searchBox.Styles.Add(new Style(s => s.Is<TextBox>().Class(":focus"))
        {
            Setters = { new Setter(TextBox.BorderBrushProperty, theme.B_AccentColor) }
        });

        var panel = new Panel
        {
            Children = { searchBox },
            Margin = new Thickness(0, 5, 0, 0)
        };
        return panel;
    }
}
</file>

<file path="Source\Views\MainWindowControls\SharedViewTemplates.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Controls.Templates;
using Avalonia.Layout;
using Avalonia.Media;
using Avalonia.Media.Imaging;
using Sonorize.Models; // For Song, ArtistViewModel, AlbumViewModel, ThemeColors
using Sonorize.ViewModels; // For SongDisplayMode (though not directly used here, context is relevant)

namespace Sonorize.Views.MainWindowControls
{
    public class SharedViewTemplates
    {
        private readonly ThemeColors _theme;

        // Song Templates
        public FuncDataTemplate<Song> DetailedSongTemplate { get; private set; }
        public FuncDataTemplate<Song> CompactSongTemplate { get; private set; }
        public FuncDataTemplate<Song> GridSongTemplate { get; private set; }

        // Artist Templates
        public FuncDataTemplate<ArtistViewModel> DetailedArtistTemplate { get; private set; }
        public FuncDataTemplate<ArtistViewModel> CompactArtistTemplate { get; private set; }
        public FuncDataTemplate<ArtistViewModel> GridArtistTemplate { get; private set; }

        // Album Templates
        public FuncDataTemplate<AlbumViewModel> DetailedAlbumTemplate { get; private set; }
        public FuncDataTemplate<AlbumViewModel> CompactAlbumTemplate { get; private set; }
        public FuncDataTemplate<AlbumViewModel> GridAlbumTemplate { get; private set; }


        // Panel Templates (reusable)
        public ITemplate<Panel?> StackPanelItemsPanelTemplate { get; private set; }
        public ITemplate<Panel?> WrapPanelItemsPanelTemplate { get; private set; }

        public SharedViewTemplates(ThemeColors theme)
        {
            _theme = theme;
            InitializeSongTemplates();
            InitializeArtistTemplates();
            InitializeAlbumTemplates();
            InitializePanelTemplates();
        }

        private void InitializeSongTemplates()
        {
            // Detailed Song Template
            DetailedSongTemplate = new FuncDataTemplate<Song>((song, nameScope) => {
                var image = new Image { Width = 32, Height = 32, Margin = new Thickness(5, 0, 5, 0), Source = song.Thumbnail, Stretch = Stretch.UniformToFill };
                RenderOptions.SetBitmapInterpolationMode(image, BitmapInterpolationMode.HighQuality);
                var titleBlock = new TextBlock { Text = song.Title, FontSize = 14, FontWeight = FontWeight.Normal, VerticalAlignment = VerticalAlignment.Center, Margin = new Thickness(0, 0, 0, 1) };
                var artistBlock = new TextBlock { Text = song.Artist, FontSize = 11, VerticalAlignment = VerticalAlignment.Center, Foreground = _theme.B_SecondaryTextColor };
                var durationBlock = new TextBlock { Text = song.DurationString, FontSize = 11, HorizontalAlignment = HorizontalAlignment.Right, VerticalAlignment = VerticalAlignment.Center, Foreground = _theme.B_SecondaryTextColor };
                var textStack = new StackPanel { Orientation = Orientation.Vertical, VerticalAlignment = VerticalAlignment.Center, Margin = new Thickness(8, 0, 0, 0), Children = { titleBlock, artistBlock } };
                var itemGrid = new Grid { ColumnDefinitions = new ColumnDefinitions("Auto,*,Auto"), VerticalAlignment = VerticalAlignment.Center, Children = { image, textStack, durationBlock } };
                Grid.SetColumn(image, 0); Grid.SetColumn(textStack, 1); Grid.SetColumn(durationBlock, 2);
                return new Border { Padding = new Thickness(10, 6, 10, 6), MinHeight = 44, Background = Brushes.Transparent, Child = itemGrid };
            }, supportsRecycling: true);

            // Compact Song Template
            CompactSongTemplate = new FuncDataTemplate<Song>((song, nameScope) => {
                var titleBlock = new TextBlock { Text = song.Title, FontSize = 12, FontWeight = FontWeight.Normal, VerticalAlignment = VerticalAlignment.Center, TextTrimming = TextTrimming.CharacterEllipsis };
                var artistBlock = new TextBlock { Text = $" - {song.Artist}", FontSize = 11, VerticalAlignment = VerticalAlignment.Center, Foreground = _theme.B_SecondaryTextColor, TextTrimming = TextTrimming.CharacterEllipsis, Margin = new Thickness(5, 0, 0, 0) };
                var titleArtistPanel = new StackPanel { Orientation = Orientation.Horizontal, VerticalAlignment = VerticalAlignment.Center, Children = { titleBlock, artistBlock } };
                var durationBlock = new TextBlock { Text = song.DurationString, FontSize = 11, HorizontalAlignment = HorizontalAlignment.Right, VerticalAlignment = VerticalAlignment.Center, Foreground = _theme.B_SecondaryTextColor, Margin = new Thickness(5, 0, 0, 0) };
                var itemGrid = new Grid { ColumnDefinitions = new ColumnDefinitions("*,Auto"), VerticalAlignment = VerticalAlignment.Center };
                itemGrid.Children.Add(titleArtistPanel); itemGrid.Children.Add(durationBlock);
                Grid.SetColumn(titleArtistPanel, 0); Grid.SetColumn(durationBlock, 1);
                return new Border { Padding = new Thickness(10, 4, 10, 4), MinHeight = 30, Background = Brushes.Transparent, Child = itemGrid };
            }, supportsRecycling: true);

            // Grid Song Template
            GridSongTemplate = new FuncDataTemplate<Song>((song, nameScope) => {
                var image = new Image { Width = 80, Height = 80, Source = song.Thumbnail, Stretch = Stretch.UniformToFill, HorizontalAlignment = HorizontalAlignment.Center };
                RenderOptions.SetBitmapInterpolationMode(image, BitmapInterpolationMode.HighQuality);
                var titleBlock = new TextBlock { Text = song.Title, FontSize = 12, FontWeight = FontWeight.SemiBold, TextWrapping = TextWrapping.Wrap, MaxHeight = 30, TextAlignment = TextAlignment.Center, HorizontalAlignment = HorizontalAlignment.Center, Margin = new Thickness(0, 3, 0, 0) };
                var artistBlock = new TextBlock { Text = song.Artist, FontSize = 10, Foreground = _theme.B_SecondaryTextColor, TextWrapping = TextWrapping.Wrap, MaxHeight = 15, TextAlignment = TextAlignment.Center, HorizontalAlignment = HorizontalAlignment.Center, Margin = new Thickness(0, 1, 0, 0) };
                var contentStack = new StackPanel { Orientation = Orientation.Vertical, HorizontalAlignment = HorizontalAlignment.Center, Spacing = 2, Children = { image, titleBlock, artistBlock } };
                return new Border { Width = 120, Height = 150, Background = Brushes.Transparent, Padding = new Thickness(5), Child = contentStack, HorizontalAlignment = HorizontalAlignment.Center, VerticalAlignment = VerticalAlignment.Center };
            }, supportsRecycling: true);
        }

        private void InitializeArtistTemplates()
        {
            DetailedArtistTemplate = new FuncDataTemplate<ArtistViewModel>((artistVM, nameScope) =>
            {
                var image = new Image { Width = 32, Height = 32, Margin = new Thickness(5, 0, 10, 0), Source = artistVM.Thumbnail, Stretch = Stretch.UniformToFill };
                RenderOptions.SetBitmapInterpolationMode(image, BitmapInterpolationMode.HighQuality);
                var artistNameBlock = new TextBlock { Text = artistVM.Name, FontSize = 14, VerticalAlignment = VerticalAlignment.Center };
                var itemGrid = new Grid { ColumnDefinitions = new ColumnDefinitions("Auto,*"), VerticalAlignment = VerticalAlignment.Center };
                itemGrid.Children.Add(image); itemGrid.Children.Add(artistNameBlock);
                Grid.SetColumn(image, 0); Grid.SetColumn(artistNameBlock, 1);
                return new Border { Padding = new Thickness(10, 8), MinHeight = 44, Background = Brushes.Transparent, Child = itemGrid };
            }, supportsRecycling: true);

            CompactArtistTemplate = new FuncDataTemplate<ArtistViewModel>((artistVM, nameScope) =>
            {
                var artistNameBlock = new TextBlock { Text = artistVM.Name, FontSize = 12, VerticalAlignment = VerticalAlignment.Center, TextTrimming = TextTrimming.CharacterEllipsis };
                return new Border { Padding = new Thickness(10, 4, 10, 4), MinHeight = 30, Background = Brushes.Transparent, Child = artistNameBlock };
            }, supportsRecycling: true);

            GridArtistTemplate = new FuncDataTemplate<ArtistViewModel>((artistVM, nameScope) =>
            {
                var image = new Image { Width = 80, Height = 80, Source = artistVM.Thumbnail, Stretch = Stretch.UniformToFill, HorizontalAlignment = HorizontalAlignment.Center };
                RenderOptions.SetBitmapInterpolationMode(image, BitmapInterpolationMode.HighQuality);
                var artistNameBlock = new TextBlock { Text = artistVM.Name, FontSize = 12, FontWeight = FontWeight.SemiBold, TextWrapping = TextWrapping.Wrap, MaxHeight = 30, TextAlignment = TextAlignment.Center, HorizontalAlignment = HorizontalAlignment.Center, Margin = new Thickness(0, 3, 0, 0) };
                var contentStack = new StackPanel { Orientation = Orientation.Vertical, HorizontalAlignment = HorizontalAlignment.Center, Spacing = 2, Children = { image, artistNameBlock } };
                return new Border { Width = 120, Height = 130, Background = Brushes.Transparent, Padding = new Thickness(5), Child = contentStack, HorizontalAlignment = HorizontalAlignment.Center, VerticalAlignment = VerticalAlignment.Center };
            }, supportsRecycling: true);
        }

        private void InitializeAlbumTemplates()
        {
            DetailedAlbumTemplate = new FuncDataTemplate<AlbumViewModel>((albumVM, nameScope) =>
            {
                var itemGrid = new Grid
                {
                    ColumnDefinitions = new ColumnDefinitions("Auto,*"),
                    VerticalAlignment = VerticalAlignment.Center
                };

                var imageGrid = new Grid
                {
                    Width = 58,
                    Height = 58,
                    Margin = new Thickness(5, 0, 10, 0),
                    ColumnDefinitions = new ColumnDefinitions("*,*"),
                    RowDefinitions = new RowDefinitions("*,*")
                };

                for (int i = 0; i < 4; i++)
                {
                    var img = new Image
                    {
                        Width = 28,
                        Height = 28,
                        Stretch = Stretch.UniformToFill
                    };

                    if (albumVM.SongThumbnailsForGrid != null && i < albumVM.SongThumbnailsForGrid.Count)
                    {
                        img.Source = albumVM.SongThumbnailsForGrid[i];
                    }

                    RenderOptions.SetBitmapInterpolationMode(img, BitmapInterpolationMode.HighQuality);
                    Grid.SetRow(img, i / 2);
                    Grid.SetColumn(img, i % 2);
                    imageGrid.Children.Add(img);
                }

                Grid.SetColumn(imageGrid, 0);
                itemGrid.Children.Add(imageGrid);

                var albumTitleBlock = new TextBlock { Text = albumVM.Title, FontSize = 14, FontWeight = FontWeight.Normal, VerticalAlignment = VerticalAlignment.Center };
                var albumArtistBlock = new TextBlock { Text = albumVM.Artist, FontSize = 11, Foreground = _theme.B_SecondaryTextColor, VerticalAlignment = VerticalAlignment.Center };
                var textStack = new StackPanel { Orientation = Orientation.Vertical, VerticalAlignment = VerticalAlignment.Center, Children = { albumTitleBlock, albumArtistBlock } };

                Grid.SetColumn(textStack, 1);
                itemGrid.Children.Add(textStack);

                return new Border { Padding = new Thickness(10, 6), MinHeight = 68, Background = Brushes.Transparent, Child = itemGrid };
            }, supportsRecycling: true);

            CompactAlbumTemplate = new FuncDataTemplate<AlbumViewModel>((albumVM, nameScope) =>
            {
                var albumTitleBlock = new TextBlock { Text = albumVM.Title, FontSize = 12, VerticalAlignment = VerticalAlignment.Center, TextTrimming = TextTrimming.CharacterEllipsis };
                var albumArtistBlock = new TextBlock { Text = $" - {albumVM.Artist}", FontSize = 11, Foreground = _theme.B_SecondaryTextColor, VerticalAlignment = VerticalAlignment.Center, TextTrimming = TextTrimming.CharacterEllipsis, Margin = new Thickness(5, 0, 0, 0) };
                var panel = new StackPanel { Orientation = Orientation.Horizontal, VerticalAlignment = VerticalAlignment.Center, Children = { albumTitleBlock, albumArtistBlock } };
                return new Border { Padding = new Thickness(10, 4, 10, 4), MinHeight = 30, Background = Brushes.Transparent, Child = panel };
            }, supportsRecycling: true);

            GridAlbumTemplate = new FuncDataTemplate<AlbumViewModel>((albumVM, nameScope) =>
            {
                var contentStack = new StackPanel
                {
                    Orientation = Orientation.Vertical,
                    HorizontalAlignment = HorizontalAlignment.Center,
                    Spacing = 3
                };

                // Decide whether to show 2x2 grid or single large image
                bool show2x2Grid = albumVM.SongThumbnailsForGrid != null &&
                                   albumVM.SongThumbnailsForGrid.Count > 1 &&
                                   albumVM.SongThumbnailsForGrid[1] != null;

                if (show2x2Grid)
                {
                    var imageGrid = new Grid
                    {
                        Width = 84,
                        Height = 84,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        ColumnDefinitions = new ColumnDefinitions("*,*"),
                        RowDefinitions = new RowDefinitions("*,*")
                    };

                    for (int i = 0; i < 4; i++)
                    {
                        var img = new Image
                        {
                            Width = 40,
                            Height = 40,
                            Stretch = Stretch.UniformToFill
                        };
                        if (i < albumVM.SongThumbnailsForGrid!.Count) // Null check for SongThumbnailsForGrid done above
                        {
                            img.Source = albumVM.SongThumbnailsForGrid[i];
                        }
                        RenderOptions.SetBitmapInterpolationMode(img, BitmapInterpolationMode.HighQuality);
                        Grid.SetRow(img, i / 2);
                        Grid.SetColumn(img, i % 2);
                        imageGrid.Children.Add(img);
                    }
                    contentStack.Children.Add(imageGrid);
                }
                else // Show single representative thumbnail
                {
                    var singleImage = new Image
                    {
                        Width = 80,
                        Height = 80, // Size for single large image
                        Source = albumVM.RepresentativeThumbnail,
                        Stretch = Stretch.UniformToFill,
                        HorizontalAlignment = HorizontalAlignment.Center
                    };
                    RenderOptions.SetBitmapInterpolationMode(singleImage, BitmapInterpolationMode.HighQuality);
                    contentStack.Children.Add(singleImage);
                }

                var albumTitleBlock = new TextBlock
                {
                    Text = albumVM.Title,
                    FontSize = 12,
                    FontWeight = FontWeight.SemiBold,
                    TextWrapping = TextWrapping.Wrap,
                    MaxHeight = 30,
                    TextAlignment = TextAlignment.Center,
                    HorizontalAlignment = HorizontalAlignment.Center,
                    Margin = new Thickness(0, 2, 0, 0)
                };
                contentStack.Children.Add(albumTitleBlock);

                var albumArtistBlock = new TextBlock
                {
                    Text = albumVM.Artist,
                    FontSize = 10,
                    Foreground = _theme.B_SecondaryTextColor,
                    TextWrapping = TextWrapping.Wrap,
                    MaxHeight = 15,
                    TextAlignment = TextAlignment.Center,
                    HorizontalAlignment = HorizontalAlignment.Center
                };
                contentStack.Children.Add(albumArtistBlock);

                return new Border
                {
                    Width = 120,
                    Height = 150,
                    Background = Brushes.Transparent,
                    Padding = new Thickness(5),
                    Child = contentStack,
                    HorizontalAlignment = HorizontalAlignment.Center,
                    VerticalAlignment = VerticalAlignment.Center
                };
            }, supportsRecycling: true);
        }

        private void InitializePanelTemplates()
        {
            StackPanelItemsPanelTemplate = new FuncTemplate<Panel?>(() => new VirtualizingStackPanel { Orientation = Orientation.Vertical });
            WrapPanelItemsPanelTemplate = new FuncTemplate<Panel?>(() => new WrapPanel { Orientation = Orientation.Horizontal });
        }
    }
}
</file>

