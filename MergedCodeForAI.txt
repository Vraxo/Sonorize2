<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\App.cs">
using System.Diagnostics;
using Avalonia;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Media;
using Avalonia.Styling;
using Avalonia.Themes.Fluent;
using Sonorize.Models;
using Sonorize.Services;
using Sonorize.ViewModels;
using Sonorize.Views;
using Sonorize.Extensions;
using Sonorize.UI; // Added for ThemeResourceApplicator

namespace Sonorize;

public class App : Application
{
    public override void Initialize()
    {
        // Delay adding FluentTheme until OnFrameworkInitializationCompleted
    }

    public override void OnFrameworkInitializationCompleted()
    {
        if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
        {
            var settingsService = new SettingsService();
            var appSettings = settingsService.LoadSettings();

            var themeService = new ThemeService(appSettings.PreferredThemeFileName);
            ThemeColors currentCustomTheme = themeService.CurrentTheme;

            var fluentTheme = new FluentTheme();
            Styles.Add(fluentTheme);
            RequestedThemeVariant = ThemeVariant.Dark;
            Debug.WriteLine($"[App] RequestedThemeVariant set to: {RequestedThemeVariant}");

            // Delegate theme color application to the new service
            ThemeResourceApplicator.ApplyCustomColorsToResources(this, currentCustomTheme);

            // Use the bootstrapper to create services and the main ViewModel
            var bootstrapper = new ApplicationServicesBootstrapper();
            var mainWindowViewModel = bootstrapper.Bootstrap(settingsService, currentCustomTheme);

            desktop.MainWindow = new MainWindow(currentCustomTheme)
            {
                DataContext = mainWindowViewModel
            };

            mainWindowViewModel.LoadInitialDataCommand.Execute(null);
        }

        base.OnFrameworkInitializationCompleted();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Program.cs">
using System;
using Avalonia;
using Avalonia.Logging;
using NAudio.MediaFoundation; // Required for MediaFoundationApi

namespace Sonorize;

class Program
{
    // Initialization code. Don't use any Avalonia, third-party APIs or any
    // SynchronizationContext-reliant code before AppMain is called: things aren't initialized
    // yet and stuff might break.
    [STAThread]
    public static void Main(string[] args)
    {
        // Initialize Media Foundation
        try
        {
            MediaFoundationApi.Startup();
            Console.WriteLine("[Program] MediaFoundationApi.Startup() called successfully.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[Program] CRITICAL ERROR: MediaFoundationApi.Startup() failed: {ex.Message}");
            // Optionally, prevent the app from starting or notify the user,
            // as MF features will likely not work.
        }

        try
        {
            BuildAvaloniaApp().StartWithClassicDesktopLifetime(args);
        }
        finally
        {
            // Shutdown Media Foundation
            try
            {
                MediaFoundationApi.Shutdown();
                Console.WriteLine("[Program] MediaFoundationApi.Shutdown() called successfully.");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[Program] ERROR: MediaFoundationApi.Shutdown() failed: {ex.Message}");
            }
        }
    }

    // Avalonia configuration, don't remove; also used by visual designer.
    public static AppBuilder BuildAvaloniaApp()
        => AppBuilder.Configure<App>()
            .UsePlatformDetect()
            .LogToTrace(level: LogEventLevel.Warning);
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Controls\WaveformDisplayControl.cs">
using System;
using System.Collections.Generic;
using System.Linq; // Required for Enumerable.Empty
using Avalonia;
using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Media;
using Sonorize.Models; // For LoopRegion
using Sonorize.Services; // For WaveformPoint

namespace Sonorize.Controls;

public class WaveformDisplayControl : Control
{
    private readonly WaveformRenderer _renderer = new();

    // Background Property
    public static readonly StyledProperty<IBrush?> BackgroundProperty =
        Border.BackgroundProperty.AddOwner<WaveformDisplayControl>();

    public IBrush? Background
    {
        get => GetValue(BackgroundProperty);
        set => SetValue(BackgroundProperty, value);
    }

    // Corrected to use IEnumerable<WaveformPoint>
    public static readonly StyledProperty<IEnumerable<WaveformPoint>> WaveformPointsProperty =
        AvaloniaProperty.Register<WaveformDisplayControl, IEnumerable<WaveformPoint>>(
            nameof(WaveformPoints),
            defaultValue: Enumerable.Empty<WaveformPoint>()); // Default to an empty enumerable

    public IEnumerable<WaveformPoint> WaveformPoints
    {
        get => GetValue(WaveformPointsProperty);
        set => SetValue(WaveformPointsProperty, value);
    }

    public static readonly StyledProperty<TimeSpan> CurrentPositionProperty =
        AvaloniaProperty.Register<WaveformDisplayControl, TimeSpan>(nameof(CurrentPosition));

    public TimeSpan CurrentPosition
    {
        get => GetValue(CurrentPositionProperty);
        set => SetValue(CurrentPositionProperty, value);
    }

    public static readonly StyledProperty<TimeSpan> DurationProperty =
        AvaloniaProperty.Register<WaveformDisplayControl, TimeSpan>(nameof(Duration), TimeSpan.FromSeconds(1));

    public TimeSpan Duration
    {
        get => GetValue(DurationProperty);
        set => SetValue(DurationProperty, value);
    }

    public static readonly StyledProperty<LoopRegion?> ActiveLoopProperty =
        AvaloniaProperty.Register<WaveformDisplayControl, LoopRegion?>(nameof(ActiveLoop));

    public LoopRegion? ActiveLoop
    {
        get => GetValue(ActiveLoopProperty);
        set => SetValue(ActiveLoopProperty, value);
    }

    public static readonly StyledProperty<IBrush> WaveformBrushProperty =
        AvaloniaProperty.Register<WaveformDisplayControl, IBrush>(nameof(WaveformBrush), Brushes.DodgerBlue);
    public IBrush WaveformBrush { get => GetValue(WaveformBrushProperty); set => SetValue(WaveformBrushProperty, value); }

    public static readonly StyledProperty<IBrush> PositionMarkerBrushProperty =
        AvaloniaProperty.Register<WaveformDisplayControl, IBrush>(nameof(PositionMarkerBrush), Brushes.Red);
    public IBrush PositionMarkerBrush { get => GetValue(PositionMarkerBrushProperty); set => SetValue(PositionMarkerBrushProperty, value); }

    public static readonly StyledProperty<IBrush> LoopRegionBrushProperty =
        AvaloniaProperty.Register<WaveformDisplayControl, IBrush>(nameof(LoopRegionBrush), new SolidColorBrush(Colors.Orange, 0.3));
    public IBrush LoopRegionBrush { get => GetValue(LoopRegionBrushProperty); set => SetValue(LoopRegionBrushProperty, value); }


    public event EventHandler<TimeSpan>? SeekRequested;

    static WaveformDisplayControl()
    {
        AffectsRender<WaveformDisplayControl>(BackgroundProperty, WaveformPointsProperty, CurrentPositionProperty, DurationProperty, ActiveLoopProperty, WaveformBrushProperty, PositionMarkerBrushProperty, LoopRegionBrushProperty);
    }

    public WaveformDisplayControl()
    {
        ClipToBounds = true;
    }

    protected override void OnPointerPressed(PointerPressedEventArgs e)
    {
        base.OnPointerPressed(e);
        if (Duration.TotalSeconds > 0 && e.GetCurrentPoint(this).Properties.IsLeftButtonPressed)
        {
            var position = e.GetPosition(this);
            var relativeX = position.X / Bounds.Width;
            var seekTime = TimeSpan.FromSeconds(relativeX * Duration.TotalSeconds);
            SeekRequested?.Invoke(this, seekTime);
        }
    }

    public override void Render(DrawingContext context)
    {
        base.Render(context);
        var width = Bounds.Width;
        var height = Bounds.Height;

        if (width <= 0 || height <= 0) return;

        WaveformRenderer.DrawBackground(context, Bounds, Background);
        WaveformRenderer.DrawWaveform(context, Bounds, WaveformPoints, WaveformBrush);
        WaveformRenderer.DrawLoopRegion(context, Bounds, ActiveLoop, Duration, LoopRegionBrush);
        WaveformRenderer.DrawPositionMarker(context, Bounds, CurrentPosition, Duration, PositionMarkerBrush);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Controls\WaveformRenderer.cs">
using System;
using System.Collections.Generic;
using System.Linq;
using Avalonia;
using Avalonia.Media;
using Sonorize.Models;
using Sonorize.Services;

namespace Sonorize.Controls;

public class WaveformRenderer
{
    public static void DrawBackground(DrawingContext context, Rect bounds, IBrush? backgroundBrush)
    {
        if (backgroundBrush is null)
        {
            return;
        }

        context.FillRectangle(backgroundBrush, bounds);
    }

    public static void DrawWaveform(DrawingContext context, Rect bounds, IEnumerable<WaveformPoint> waveformPoints, IBrush waveformBrush)
    {
        double width = bounds.Width;
        double height = bounds.Height;
        var waveformPen = new Pen(waveformBrush, 1);

        List<WaveformPoint>? pointsList = waveformPoints?.ToList(); // Materialize once, handles null waveformPoints

        if (pointsList is not null && pointsList.Count > 0)
        {
            for (int i = 0; i < pointsList.Count; i++)
            {
                WaveformPoint point = pointsList[i];
                double x = point.X * width;
                double yPeakMagnitude = point.YPeak * (height / 2);
                double centerY = height / 2;

                context.DrawLine(waveformPen, new Point(x, centerY - yPeakMagnitude), new Point(x, centerY + yPeakMagnitude));
            }
        }
        else
        {
            context.DrawLine(waveformPen, new Point(0, height / 2), new Point(width, height / 2));
        }
    }

    public static void DrawLoopRegion(DrawingContext context, Rect bounds, LoopRegion? activeLoop, TimeSpan duration, IBrush loopRegionBrush)
    {
        if (activeLoop is null || duration.TotalSeconds <= 0)
        {
            return;
        }

        double width = bounds.Width;
        double height = bounds.Height;
        double loopStartRatio = activeLoop.Start.TotalSeconds / duration.TotalSeconds;
        double loopEndRatio = activeLoop.End.TotalSeconds / duration.TotalSeconds;
        double loopStartX = loopStartRatio * width;
        double loopEndX = loopEndRatio * width;

        if (loopEndX <= loopStartX)
        {
            return;
        }

        context.FillRectangle(loopRegionBrush, new(loopStartX, 0, loopEndX - loopStartX, height));
    }

    public static void DrawPositionMarker(DrawingContext context, Rect bounds, TimeSpan currentPosition, TimeSpan duration, IBrush positionMarkerBrush)
    {
        if (duration.TotalSeconds <= 0)
        {
            return;
        }

        double width = bounds.Width;
        double height = bounds.Height;
        Pen positionPen = new(positionMarkerBrush, 1.5);
        double currentX = (currentPosition.TotalSeconds / duration.TotalSeconds) * width;
        currentX = Math.Clamp(currentX, 0, width);

        context.DrawLine(positionPen, new(currentX, 0), new(currentX, height));
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Converters\BooleanToPlayPauseIconConverter.cs">
using System;
using System.Globalization;
using Avalonia.Data.Converters;

namespace Sonorize.Converters
{
    public class BooleanToPlayPauseIconConverter : IValueConverter
    {
        public static readonly BooleanToPlayPauseIconConverter Instance = new();

        private const string PlayIcon = "▶"; // U+25B6
        private const string PauseIcon = "||"; // U+2016 (Double Vertical Line)

        public object Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
        {
            if (value is bool isPlaying)
            {
                return isPlaying ? PauseIcon : PlayIcon;
            }
            return PlayIcon; // Default to Play icon if value is not a bool
        }

        public object ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
        {
            throw new NotSupportedException();
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Converters\BooleanToPlayPauseTextConverter.cs">
// Path: Source/Views/MainView.cs
using System;
using Avalonia.Data.Converters;

namespace Sonorize.Converters;

public class BooleanToPlayPauseTextConverter : IValueConverter
{
    public static readonly BooleanToPlayPauseTextConverter Instance = new();

    public object Convert(object? value, Type targetType, object? parameter, System.Globalization.CultureInfo culture)
    {
        if (value is bool isPlaying) return isPlaying ? "Pause" : "Play";
        return "Play";
    }

    public object ConvertBack(object? value, Type targetType, object? parameter, System.Globalization.CultureInfo culture)
    {
        throw new NotSupportedException();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Converters\BooleanToShuffleIconConverter.cs">
using System;
using System.Diagnostics; // Added for Debug
using System.Globalization;
using Avalonia.Data.Converters;

namespace Sonorize.Converters
{
    public class BooleanToShuffleIconConverter : IValueConverter
    {
        public static readonly BooleanToShuffleIconConverter Instance = new();

        private const string ShuffleActiveIcon = "🔀"; // U+1F500 Twisted Arrows Right and Left
        private const string ShuffleInactiveIcon = "↔"; // U+2194 Left Right Arrow

        public object Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
        {
            // Add debug logging here
            Debug.WriteLine($"[Converter] BooleanToShuffleIconConverter Convert called. Value: {value}, TargetType: {targetType}");
            if (value is bool isShuffleEnabled)
            {
                Debug.WriteLine($"[Converter] isShuffleEnabled: {isShuffleEnabled}. Returning: {(isShuffleEnabled ? ShuffleActiveIcon : ShuffleInactiveIcon)}");
                return isShuffleEnabled ? ShuffleActiveIcon : ShuffleInactiveIcon;
            }
            Debug.WriteLine($"[Converter] Value is not bool ({value?.GetType().Name ?? "null"}). Returning: {ShuffleInactiveIcon}");
            return ShuffleInactiveIcon; // Default
        }

        public object ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
        {
            throw new NotSupportedException();
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Converters\EnumToBooleanConverter.cs">
using System;
using System.Globalization;
using Avalonia.Data.Converters;

namespace Sonorize.Converters;

public class EnumToBooleanConverter : IValueConverter
{
    public static readonly EnumToBooleanConverter Instance = new();

    public object Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        return value is not null && parameter is not null && value.Equals(parameter);
    }

    public object ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        // This converter is typically used one-way for visibility.
        // If two-way binding is needed (e.g., for radio buttons), parameter would be the enum value to return.
        throw new NotSupportedException();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Converters\GridViewImageVisibilityConverter.cs">
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Avalonia.Data.Converters;
using Avalonia.Media.Imaging;
using Sonorize.ViewModels;

namespace Sonorize.Converters
{
    public class GridViewImageVisibilityConverter : IMultiValueConverter
    {
        public GridViewImageType TargetType { get; set; }

        public object Convert(IList<object?> values, Type targetType, object? parameter, CultureInfo culture)
        {
            if (values.Count != 2 || values[1] is not GridViewImageType currentSetting)
            {
                return false;
            }

            int thumbnailCount = 0;
            if (values[0] is IEnumerable<Bitmap?> thumbnails)
            {
                thumbnailCount = thumbnails.Count(t => t is not null);
            }

            if (TargetType == GridViewImageType.Composite)
            {
                return currentSetting == GridViewImageType.Composite && thumbnailCount > 1;
            }
            else // TargetType is Single
            {
                return currentSetting == GridViewImageType.Single || (currentSetting == GridViewImageType.Composite && thumbnailCount <= 1);
            }
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Converters\NotNullToBooleanConverter.cs">
using System;
using System.Globalization;
using Avalonia.Data.Converters;

namespace Sonorize.Converters;

public class NotNullToBooleanConverter : IValueConverter
{
    public static readonly NotNullToBooleanConverter Instance = new();

    public object Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        return value is not null;
    }

    public object ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        throw new NotSupportedException();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Converters\SliderFillWidthConverter.cs">
using System;
using Avalonia;

namespace Sonorize.Converters;

public class SliderFillWidthConverter : Avalonia.Data.Converters.IMultiValueConverter
{
    public object Convert(System.Collections.Generic.IList<object> values, Type targetType, object parameter, System.Globalization.CultureInfo culture)
    {
        if (values.Count == 3 &&
            values[0] is double value &&
            values[1] is double max &&
            values[2] is Rect bounds &&
            max > 0)
        {
            return bounds.Width * (value / max);
        }

        return 0.0;
    }

    public object[] ConvertBack(object value, Type[] targetTypes, object parameter, System.Globalization.CultureInfo culture)
    {
        throw new NotSupportedException();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Extensions\ColorExtensions.cs">
using Avalonia.Media;

namespace Sonorize.Extensions;

public static class ColorExtensions
{
    public static Color ChangeLightness(this Color color, double factor)
    {
        HslColor hsl = color.ToHsl();
        double newL = System.Math.Clamp(hsl.L + factor, 0.0, 1.0);
        return HslColor.FromAhsl(hsl.A, hsl.H, hsl.S, newL).ToRgb();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Extensions\ColorManipulationExtensions.cs">
using Avalonia.Media;

namespace Sonorize.Extensions;

public static class ColorManipulationExtensions
{
    public static Color WithAlpha(this Color color, byte alpha)
    {
        return new(alpha, color.R, color.G, color.B);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Models\AppSettings.cs">
using System.Collections.Generic;
using Sonorize.ViewModels;

namespace Sonorize.Models;

public class AppSettings
{
    public List<string> MusicDirectories { get; set; } = [];
    public string? PreferredThemeFileName { get; set; }

    public string LibraryViewModePreference { get; set; } = SongDisplayMode.Detailed.ToString();
    public string ArtistViewModePreference { get; set; } = SongDisplayMode.Detailed.ToString();
    public string AlbumViewModePreference { get; set; } = SongDisplayMode.Detailed.ToString();
    public string PlaylistViewModePreference { get; set; } = SongDisplayMode.Detailed.ToString();

    // Grid View Image Preferences
    public string ArtistGridViewImageType { get; set; } = "Composite";
    public string AlbumGridViewImageType { get; set; } = "Composite";
    public string PlaylistGridViewImageType { get; set; } = "Composite";

    // Last.fm Settings
    public bool LastfmScrobblingEnabled { get; set; } = false;
    public string? LastfmUsername { get; set; }
    public string? LastfmPassword { get; set; } // Used for initial authentication to get a session key.
    public string? LastfmSessionKey { get; set; } // Stores the authenticated session key.

    public int ScrobbleThresholdPercentage { get; set; } = 50; // Default to 50%
    public int ScrobbleThresholdAbsoluteSeconds { get; set; } = 240; // Default to 240 seconds (4 minutes)
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Models\LoopRegion.cs">
using System;

namespace Sonorize.Models;

public sealed record LoopRegion(TimeSpan Start, TimeSpan End, string Name = "Loop")
{
    public string DisplayText => $"({Start:mm\\:ss} - {End:mm\\:ss})";
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Models\LoopStorageData.cs">
using System;

namespace Sonorize.Models;

public record LoopStorageData(TimeSpan Start, TimeSpan End, bool IsActive);
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Models\Playlist.cs">
using System.Collections.Generic;

namespace Sonorize.Models;

public class Playlist
{
public string Name { get; set; } = "Unknown Playlist";
    public string? FilePath { get; set; }
    public List<Song> Songs { get; set; } = new();
    public bool IsAutoPlaylist { get; set; } = false;
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Models\ScrobbleThresholds.cs">
namespace Sonorize.Models;

public record ScrobbleThresholds(int ScrobbleThresholdPercentage, int ScrobbleThresholdAbsoluteSeconds);
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Models\Song.cs">
using System;
using System.Diagnostics;
using Avalonia.Media.Imaging;
using Sonorize.ViewModels;

namespace Sonorize.Models;

public class Song : ViewModelBase
{
    public string DurationString => $"{Duration:mm\\:ss}";

    public string FilePath
    {
        get;
        set => SetProperty(ref field, value);
    } = string.Empty;

    public string Title
    {
        get;
        set => SetProperty(ref field, value);
    } = "Unknown Title";

    public string Artist
    {
        get;
        set => SetProperty(ref field, value);
    } = "Unknown Artist";

    public string Album
    {
        get;
        set => SetProperty(ref field, value);
    } = "Unknown Album";

    public TimeSpan Duration
    {
        get;
        set => SetProperty(ref field, value);
    }

    public Bitmap? Thumbnail
    {
        get;
        set => SetProperty(ref field, value);
    }

    public DateTime DateAdded { get; set; }

    public int PlayCount
    {
        get;
        set => SetProperty(ref field, value);
    }

    public LoopRegion? SavedLoop
    {
        get;
        set => SetProperty(ref field, value);
    }

    public bool IsLoopActive
    {
        get;

        set
        {
            if (!SetProperty(ref field, value))
            {
                return;
            }

            Debug.WriteLine($"[SongModel] {Title} - IsLoopActive set to: {value}");
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Models\ThemeColors.cs">
using System.Text.Json.Serialization;
using Avalonia.Media;

namespace Sonorize.Models;

public class ThemeColors
{
    // --- Main UI Colors ---
    public string BackgroundColor { get; set; } = "#FF1E1E1E";
    public string SlightlyLighterBackground { get; set; } = "#FF2D2D30";
    public string ControlBackgroundColor { get; set; } = "#FF3C3C3C";
    public string TextColor { get; set; } = "#FFF1F1F1";
    public string SecondaryTextColor { get; set; } = "#FFAAAAAA";
    public string AccentColor { get; set; } = "#FF007ACC";
    public string AccentForeground { get; set; } = "#FFFFFFFF";

    // --- ListBox Specific Colors ---
    public string ListBoxBackground { get; set; } = "#FF2D2D30"; // Default: Same as SlightlyLighterBackground

    // --- Brush Properties ---
    [JsonIgnore] public IBrush B_BackgroundColor => SolidColorBrush.Parse(BackgroundColor);
    [JsonIgnore] public IBrush B_SlightlyLighterBackground => SolidColorBrush.Parse(SlightlyLighterBackground);
    [JsonIgnore] public IBrush B_ControlBackgroundColor => SolidColorBrush.Parse(ControlBackgroundColor);
    [JsonIgnore] public IBrush B_TextColor => SolidColorBrush.Parse(TextColor);
    [JsonIgnore] public IBrush B_SecondaryTextColor => SolidColorBrush.Parse(SecondaryTextColor);
    [JsonIgnore] public IBrush B_AccentColor => SolidColorBrush.Parse(AccentColor);
    [JsonIgnore] public IBrush B_AccentForeground => SolidColorBrush.Parse(AccentForeground);
    [JsonIgnore] public IBrush B_ListBoxBackground => SolidColorBrush.Parse(ListBoxBackground);

    public static ThemeColors CreateAmoledSpotifyTheme()
    {
        return new()
        {
            BackgroundColor = "#FF000000",
            SlightlyLighterBackground = "#FF121212",
            ControlBackgroundColor = "#FF181818",
            TextColor = "#FFFFFFFF",
            SecondaryTextColor = "#FFB3B3B3",
            AccentColor = "#FF1DB954",      // Spotify Green
            AccentForeground = "#FF000000",  // Black text on green buttons
            ListBoxBackground = "#FF000000"   // <<< CRUCIAL FOR AMOLED LIST ITEMS (unselected)
        };
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\AlbumArtLoader.cs">
using System;
using System.Diagnostics;
using System.IO;
using System.Threading.Tasks;
using Avalonia;
using Avalonia.Media.Imaging;
using TagLib;
using File = System.IO.File; // Required for IPicture, CorruptFileException, UnsupportedFormatException

namespace Sonorize.Services;

public class AlbumArtLoader
{
    public async Task<Bitmap?> LoadFromFileAsync(string filePath)
    {
        if (string.IsNullOrEmpty(filePath) || !File.Exists(filePath))
        {
            Debug.WriteLine($"[AlbumArtLoader] File path is invalid or file does not exist: {filePath}");
            return null;
        }

        try
        {
            return await Task.Run(() =>
            {
                using var tagFile = TagLib.File.Create(filePath);
                if (tagFile.Tag.Pictures.Length > 0)
                {
                    IPicture pic = tagFile.Tag.Pictures[0];
                    using var ms = new MemoryStream(pic.Data.Data);
                    if (ms.Length > 0)
                    {
                        // Load the original bitmap
                        using var originalBitmap = new Bitmap(ms);
                        // Define the target size for the thumbnail
                        var targetSize = new PixelSize(128, 128); // Example size, adjust as needed
                        // Create a scaled version of the bitmap
                        return originalBitmap.CreateScaledBitmap(targetSize, BitmapInterpolationMode.HighQuality);
                    }
                }
                Debug.WriteLine($"[AlbumArtLoader] No pictures found in tags for: {Path.GetFileName(filePath)}");
                return null; // No pictures found or picture data is empty
            });
        }
        catch (CorruptFileException cfe)
        {
            Debug.WriteLine($"[AlbumArtLoader] Corrupt file when loading album art for \"{Path.GetFileName(filePath)}\": {cfe.Message}");
        }
        catch (UnsupportedFormatException ufe)
        {
            Debug.WriteLine($"[AlbumArtLoader] Unsupported format when loading album art for \"{Path.GetFileName(filePath)}\": {ufe.Message}");
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[AlbumArtLoader] Generic error loading album art for \"{Path.GetFileName(filePath)}\": {ex.Message}");
        }
        return null; // Return null on any error
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\AutoPlaylistGeneratorService.cs">
using System;
using System.Collections.Generic;
using System.Linq;
using Sonorize.Models;

namespace Sonorize.Services;

public class AutoPlaylistGeneratorService
{
    public List<Playlist> GenerateAll(IEnumerable<Song> allSongs)
    {
        var autoPlaylists = new List<Playlist>();

        // Generate "Recently Added"
        var recentlyAdded = GenerateRecentlyAddedPlaylist(allSongs, 50);
        if (recentlyAdded.Songs.Any())
        {
            autoPlaylists.Add(recentlyAdded);
        }

        // Generate "Most Played" and always add it, even if empty.
        var mostPlayed = GenerateMostPlayedPlaylist(allSongs, 25);
        autoPlaylists.Add(mostPlayed);


        return autoPlaylists;
    }

    private Playlist GenerateRecentlyAddedPlaylist(IEnumerable<Song> allSongs, int count)
    {
        var songs = allSongs.OrderByDescending(s => s.DateAdded).Take(count).ToList();
        return new Playlist
        {
            Name = "Recently Added",
            IsAutoPlaylist = true,
            Songs = songs
        };
    }

    private Playlist GenerateMostPlayedPlaylist(IEnumerable<Song> allSongs, int count)
    {
        // Now implemented to use the PlayCount property
        var songs = allSongs
            .Where(s => s.PlayCount > 0)
            .OrderByDescending(s => s.PlayCount)
            .ThenByDescending(s => s.DateAdded) // Secondary sort for ties
            .Take(count)
            .ToList();

        return new Playlist
        {
            Name = "Most Played",
            IsAutoPlaylist = true,
            Songs = songs
        };
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\DefaultIconGenerator.cs">
using System;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using Avalonia;
using Avalonia.Media;
using Avalonia.Media.Imaging;

namespace Sonorize.Services;

public class DefaultIconGenerator
{
    private const int IconDimension = 96;
    private const double DpiValue = 96.0;
    private const string MusicalNoteCharacter = "♫";
    private const double FontSizeFactor = 0.5;

    public static Bitmap? CreateMusicalNoteIcon()
    {
        Debug.WriteLine("[DefaultIconGenerator] CreateMusicalNoteIcon called.");
        try
        {
            var pixelSize = new PixelSize(IconDimension, IconDimension);
            var dpi = new Vector(DpiValue, DpiValue);

            using var renderTarget = new RenderTargetBitmap(pixelSize, dpi);
            using (DrawingContext context = renderTarget.CreateDrawingContext())
            {
                DrawMusicalNote(context, pixelSize);
            }

            return SaveToBitmap(renderTarget);
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[DefaultIconGenerator] CRITICAL EXCEPTION creating default icon: {ex}");
            return null;
        }
    }

    private static void DrawMusicalNote(DrawingContext context, PixelSize pixelSize)
    {
        var backgroundBrush = new SolidColorBrush(Colors.DimGray);
        var foregroundBrush = Brushes.WhiteSmoke;
        var bounds = new Rect(new Size(pixelSize.Width, pixelSize.Height));

        // Fill background
        context.FillRectangle(backgroundBrush, bounds);

        // Create formatted text for the musical note icon
        var formattedText = new FormattedText(
            MusicalNoteCharacter,
            CultureInfo.CurrentCulture,
            FlowDirection.LeftToRight,
            Typeface.Default,
            pixelSize.Width * FontSizeFactor, // Font size relative to icon size
            foregroundBrush);

        // Calculate text origin to center it
        var textOrigin = new Point(
            (bounds.Width - formattedText.Width) / 2,
            (bounds.Height - formattedText.Height) / 2);

        // Draw the text
        context.DrawText(formattedText, textOrigin);
    }

    private static Bitmap? SaveToBitmap(RenderTargetBitmap renderTarget)
    {
        using var memoryStream = new MemoryStream();
        renderTarget.Save(memoryStream);
        memoryStream.Seek(0, SeekOrigin.Begin);

        return memoryStream.Length > 0 ? new Bitmap(memoryStream) : null;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\LastfmAuthenticatorService.cs">
using System;
using System.Diagnostics;
using System.Threading.Tasks;
using IF.Lastfm.Core.Api;
using IF.Lastfm.Core.Objects; // For LastUserSession
using Sonorize.Models;

namespace Sonorize.Services;

public class LastfmAuthenticatorService
{
    private readonly SettingsService _settingsService;

    // Last.fm API Credentials
    private const string LastfmApiKey = "d623e7a246a80c3bd60819e86c7b5ee1"; // Keep your actual key
    private const string LastfmApiSecret = "9414a77c9b7f8c361d96d4575ccd97f0"; // Keep your actual secret

    public LastfmAuthenticatorService(SettingsService settingsService)
    {
        _settingsService = settingsService ?? throw new ArgumentNullException(nameof(settingsService));
        Debug.WriteLine("[LastfmAuthenticatorService] Initialized.");
    }

    private async Task<LastfmClient?> TryAuthenticateWithCredentialsAsync(AppSettings settings)
    {
        Debug.WriteLine($"[LastfmAuthenticatorService] Attempting credential authentication for '{settings.LastfmUsername}'…");
        var auth = new LastAuth(LastfmApiKey, LastfmApiSecret);
        try
        {
            // Callers ensure LastfmUsername and LastfmPassword are not null/empty
            var response = await auth.GetSessionTokenAsync(settings.LastfmUsername!, settings.LastfmPassword!);
            if (response.Success && auth.Authenticated && auth.UserSession is not null)
            {
                var session = auth.UserSession;
                settings.LastfmSessionKey = session.Token;
                settings.LastfmPassword = null; // Clear password for security
                _settingsService.SaveSettings(settings); // Save updated settings with session key

                Debug.WriteLine($"[LastfmAuthenticatorService] Successfully obtained and saved session key for '{settings.LastfmUsername}'. Password cleared from settings.");
                return new LastfmClient(auth);
            }
            // else: If authentication failed but no exception, falls through to return null.
            // Debug.WriteLine($"[LastfmAuthenticatorService] Credential authentication failed. Success={response.Success}, Authenticated={auth.Authenticated}");
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[LastfmAuthenticatorService] Exception during credential authentication for '{settings.LastfmUsername}': {ex.Message}");
        }
        return null;
    }

    public async Task<LastfmClient?> GetAuthenticatedClientAsync()
    {
        if (string.IsNullOrEmpty(LastfmApiKey) || LastfmApiKey == "YOUR_LASTFM_API_KEY" ||
            string.IsNullOrEmpty(LastfmApiSecret) || LastfmApiSecret == "YOUR_LASTFM_API_SECRET")
        {
            Debug.WriteLine("[LastfmAuthenticatorService] CRITICAL: Last.fm API Key or Secret is not configured. Aborting.");
            return null;
        }

        AppSettings currentSettings = _settingsService.LoadSettings(); // Always load fresh settings

        // Attempt 1: Use existing session key from settings
        if (!string.IsNullOrEmpty(currentSettings.LastfmSessionKey))
        {
            Debug.WriteLine("[LastfmAuthenticatorService] Using existing session key from settings.");
            var auth = new LastAuth(LastfmApiKey, LastfmApiSecret);
            auth.LoadSession(new LastUserSession { Token = currentSettings.LastfmSessionKey });
            return new LastfmClient(auth);
        }

        // Attempt 2: Authenticate with username/password
        if (!string.IsNullOrEmpty(currentSettings.LastfmUsername) &&
            !string.IsNullOrEmpty(currentSettings.LastfmPassword))
        {
            var client = await TryAuthenticateWithCredentialsAsync(currentSettings);
            if (client is not null)
            {
                return client;
            }
            // If TryAuthenticateWithCredentialsAsync returns null, fall through
        }
        else
        {
            Debug.WriteLine("[LastfmAuthenticatorService] No session key, and username/password not fully provided in settings. Cannot attempt login.");
            // Fall through to final debug message and return null
        }

        Debug.WriteLine("[LastfmAuthenticatorService] GetAuthenticatedClientAsync: Could not obtain an authenticated Last.fm client after all attempts.");
        return null;
    }

    public static bool AreCredentialsEffectivelyConfigured(AppSettings settings)
    {
        return !string.IsNullOrEmpty(settings.LastfmSessionKey) ||
               (!string.IsNullOrEmpty(settings.LastfmUsername) && !string.IsNullOrEmpty(settings.LastfmPassword));
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\LibraryPlaybackLinkService.cs">
using System;
using System.ComponentModel;
using System.Diagnostics;
using Avalonia.Threading;
using Sonorize.ViewModels;

namespace Sonorize.Services;

public class LibraryPlaybackLinkService : IDisposable
{
    private readonly LibraryViewModel _libraryViewModel;
    private readonly PlaybackService _playbackService;
    private readonly PlaybackViewModel _playbackViewModel; // To observe HasCurrentSong easily

    public LibraryPlaybackLinkService(
        LibraryViewModel libraryViewModel,
        PlaybackService playbackService,
        PlaybackViewModel playbackViewModel)
    {
        _libraryViewModel = libraryViewModel ?? throw new ArgumentNullException(nameof(libraryViewModel));
        _playbackService = playbackService ?? throw new ArgumentNullException(nameof(playbackService));
        _playbackViewModel = playbackViewModel ?? throw new ArgumentNullException(nameof(playbackViewModel));

        SubscribeToEvents();
        Debug.WriteLine("[LibraryPlaybackLinkService] Initialized and subscribed to events.");
    }

    private void SubscribeToEvents()
    {
        _libraryViewModel.PropertyChanged += OnLibraryViewModelPropertyChanged;
        _playbackViewModel.PropertyChanged += OnPlaybackViewModelPropertyChanged;
    }

    private void UnsubscribeFromEvents()
    {
        _libraryViewModel.PropertyChanged -= OnLibraryViewModelPropertyChanged;
        _playbackViewModel.PropertyChanged -= OnPlaybackViewModelPropertyChanged;
    }

    private void OnLibraryViewModelPropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName != nameof(LibraryViewModel.SelectedSong))
        {
            return;
        }

        Dispatcher.UIThread.InvokeAsync(() =>
        {
            Debug.WriteLine($"[LibraryPlaybackLinkService] Library.SelectedSong changed to: {_libraryViewModel.SelectedSong?.Title ?? "null"}. Instance: {_libraryViewModel.SelectedSong?.GetHashCode() ?? 0}");

            if (_libraryViewModel.SelectedSong is not null && _playbackService.CurrentSong != _libraryViewModel.SelectedSong)
            {
                Debug.WriteLine($"[LibraryPlaybackLinkService] Library.SelectedSong changed to a *different* song ({_libraryViewModel.SelectedSong.Title}) than PlaybackService.CurrentSong ({_playbackService.CurrentSong?.Title ?? "null"}). Calling PlaybackService.Play().");
                _playbackService.Play(_libraryViewModel.SelectedSong);
            }
            else if (_libraryViewModel.SelectedSong is not null && _playbackService.CurrentSong == _libraryViewModel.SelectedSong)
            {
                Debug.WriteLine($"[LibraryPlaybackLinkService] Library.SelectedSong changed but is the SAME song instance as PlaybackService.CurrentSong ({_libraryViewModel.SelectedSong.Title}). No Play call needed here.");
            }
            else if (_libraryViewModel.SelectedSong == null)
            {
                Debug.WriteLine("[LibraryPlaybackLinkService] Library.SelectedSong is null. No Play call needed here.");
            }
        });
    }

    private void OnPlaybackViewModelPropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName != nameof(PlaybackViewModel.HasCurrentSong)) // Or CurrentSong
        {
            return;
        }

        Dispatcher.UIThread.InvokeAsync(() =>
        {
            if (_playbackViewModel.HasCurrentSong || _libraryViewModel.SelectedSong == null)
            {
                return;
            }

            Debug.WriteLine("[LibraryPlaybackLinkService] Playback has no current song. Clearing Library selection.");
            _libraryViewModel.SelectedSong = null;
        });
    }

    public void Dispose()
    {
        UnsubscribeFromEvents();
        Debug.WriteLine("[LibraryPlaybackLinkService] Disposed and unsubscribed from events.");
        GC.SuppressFinalize(this);
    }

    ~LibraryPlaybackLinkService()
    {
        Dispose();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\LoopDataMigrator.cs">
using System;
using System.Diagnostics;
using System.IO; // Required for Path.GetFileName
using System.Text.Json;
using Sonorize.Models;

namespace Sonorize.Services;

public class LoopDataMigrator
{
    public static bool TryProcessEntry(string filePathKey, JsonElement jsonData, out LoopStorageData? loopData)
    {
        loopData = null;
        try
        {
            if (TryDeserializeCurrentFormat(jsonData, out loopData))
            {
                return true;
            }

            // If current format deserialization fails (or returns null and JsonException wasn't thrown for some reason, though unlikely for Deserialize<T>),
            // it will fall through to the catch block for JsonException if that's the cause,
            // or proceed to old format migration if Deserialize<T> just returned null without exception.
        }
        catch (JsonException)
        {
            // Deserialization to LoopStorageData failed, explicitly try migrating from old format
            if (TryMigrateOldFormat(filePathKey, jsonData, out loopData))
            {
                return true;
            }
        }
        catch (Exception exGeneral)
        {
            Debug.WriteLine($"[LoopDataMigrator] General error processing loop entry for {Path.GetFileName(filePathKey)}: {exGeneral.Message}");
            return false;
        }

        // If loopData is still null here, it means it couldn't be processed as new or old format properly
        // or an unhandled scenario where Deserialize<T> returned null without throwing JsonException.
        if (loopData == null)
        {
            Debug.WriteLine($"[LoopDataMigrator] Could not deserialize or migrate loop entry for {Path.GetFileName(filePathKey)} into a known format.");
        }
        return loopData is not null;
    }

    private static bool TryDeserializeCurrentFormat(JsonElement jsonData, out LoopStorageData? loopData)
    {
        // This method specifically attempts deserialization to the current format.
        // It's expected to throw JsonException if the structure doesn't match,
        // which will be caught by the caller (TryProcessEntry).
        // If Deserialize<T> can return null without an exception for certain inputs,
        // that case would also result in `loopData` being null.
        loopData = jsonData.Deserialize<LoopStorageData>();
        if (loopData is not null)
        {
            // Successfully deserialized to current format
            return true;
        }
        return false; // Indicates null was returned without exception, or that current format failed.
    }

    private static bool TryMigrateOldFormat(string filePathKey, JsonElement jsonData, out LoopStorageData? loopData)
    {
        loopData = null;
        try
        {
            if (jsonData.TryGetProperty("Start", out JsonElement startElement) &&
                jsonData.TryGetProperty("End", out JsonElement endElement))
            {
                TimeSpan start = JsonSerializer.Deserialize<TimeSpan>(startElement.GetRawText());
                TimeSpan end = JsonSerializer.Deserialize<TimeSpan>(endElement.GetRawText());

                // Check if "IsActive" property exists, if not, it's the old format
                if (!jsonData.TryGetProperty("IsActive", out _))
                {
                    loopData = new LoopStorageData(start, end, false); // Default IsActive to false for old data
                    Debug.WriteLine($"[LoopDataMigrator] Migrated old loop format for {Path.GetFileName(filePathKey)} to Start={loopData.Start}, End={loopData.End}, IsActive={loopData.IsActive}");
                    return true;
                }
                else
                {
                    // This case implies "Start", "End", and "IsActive" exist, which should have been caught by TryDeserializeCurrentFormat.
                    // However, if TryDeserializeCurrentFormat failed for some other reason (e.g. type mismatch on IsActive),
                    // this path might be hit. We treat it as "not the old format we're trying to migrate from here".
                    Debug.WriteLine($"[LoopDataMigrator] Data for {Path.GetFileName(filePathKey)} has Start, End, and IsActive but failed current format deserialization. Not an old format target for this method.");
                    return false;
                }
            }
            else
            {
                Debug.WriteLine($"[LoopDataMigrator] Old format migration for {Path.GetFileName(filePathKey)} failed: 'Start' or 'End' property not found.");
            }
        }
        catch (JsonException jsonEx)
        {
            Debug.WriteLine($"[LoopDataMigrator] JSON error during old format migration for {Path.GetFileName(filePathKey)}: {jsonEx.Message}");
        }
        catch (Exception exMigrate)
        {
            Debug.WriteLine($"[LoopDataMigrator] Failed to migrate loop for {Path.GetFileName(filePathKey)} from old format: {exMigrate.Message}");
        }
        return false;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\LoopDataService.cs">
// Path: Source/Services/LoopDataService.cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text.Json;
using Sonorize.Models;

namespace Sonorize.Services;

public class LoopDataService
{
    private readonly string _loopDataFilePath;
    private Dictionary<string, LoopStorageData> _loopDataStore = new();
    private readonly object _lock = new object();
    private readonly LoopDataMigrator _loopDataMigrator;

    public LoopDataService()
    {
        var baseDirectory = AppContext.BaseDirectory;
        var dataDirectory = Path.Combine(baseDirectory, "Data");
        Directory.CreateDirectory(dataDirectory);
        _loopDataFilePath = Path.Combine(dataDirectory, "loopdata.json");

        _loopDataMigrator = new LoopDataMigrator(); // Instantiate the migrator
        LoadLoopData();
        Debug.WriteLine($"[LoopDataService] Initialized. Data loaded from: {_loopDataFilePath}");
    }

    private void LoadLoopData()
    {
        lock (_lock)
        {
            try
            {
                if (File.Exists(_loopDataFilePath))
                {
                    var json = File.ReadAllText(_loopDataFilePath);
                    var tempStore = JsonSerializer.Deserialize<Dictionary<string, JsonElement>>(json);
                    _loopDataStore = new Dictionary<string, LoopStorageData>();

                    if (tempStore is not null)
                    {
                        foreach (var kvp in tempStore)
                        {
                            if (LoopDataMigrator.TryProcessEntry(kvp.Key, kvp.Value, out LoopStorageData? processedData) && processedData is not null)
                            {
                                _loopDataStore[kvp.Key] = processedData;
                            }
                            else
                            {
                                Debug.WriteLine($"[LoopDataService] Failed to process or migrate loop entry for {Path.GetFileName(kvp.Key)}, entry skipped.");
                            }
                        }
                        Debug.WriteLine($"[LoopDataService] Successfully loaded/migrated {_loopDataStore.Count} loop entries using LoopDataMigrator.");
                    }
                    else
                    {
                        _loopDataStore = new Dictionary<string, LoopStorageData>();
                        Debug.WriteLine($"[LoopDataService] Loop data file was empty or malformed (tempStore is null).");
                    }
                }
                else
                {
                    _loopDataStore = new Dictionary<string, LoopStorageData>();
                    Debug.WriteLine($"[LoopDataService] Loop data file not found. Initialized with empty store.");
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[LoopDataService] Error loading loop data: {ex.Message}. Initializing with empty store.");
                _loopDataStore = new Dictionary<string, LoopStorageData>();
            }
        }
    }

    // OldLoopStorageDataTemp record is removed from here, as it's now in LoopDataMigrator


    private void SaveLoopData()
    {
        lock (_lock)
        {
            try
            {
                var options = new JsonSerializerOptions { WriteIndented = true };
                var json = JsonSerializer.Serialize(_loopDataStore, options);
                File.WriteAllText(_loopDataFilePath, json);
                Debug.WriteLine($"[LoopDataService] Successfully saved {_loopDataStore.Count} loop entries to {_loopDataFilePath}");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[LoopDataService] Error saving loop data: {ex.Message}");
            }
        }
    }

    public LoopStorageData? GetLoop(string filePath)
    {
        if (string.IsNullOrEmpty(filePath)) return null;
        lock (_lock)
        {
            _loopDataStore.TryGetValue(filePath, out var loopData);
            return loopData;
        }
    }

    // Modified to accept isActive
    public void SetLoop(string filePath, TimeSpan start, TimeSpan end, bool isActive)
    {
        if (string.IsNullOrEmpty(filePath)) return;
        var loopData = new LoopStorageData(start, end, isActive);
        lock (_lock)
        {
            _loopDataStore[filePath] = loopData;
        }
        Debug.WriteLine($"[LoopDataService] SetLoop for \"{Path.GetFileName(filePath)}\": Start={start}, End={end}, IsActive={isActive}. Triggering save.");
        SaveLoopData();
    }

    public void UpdateLoopActiveState(string filePath, bool isActive)
    {
        if (string.IsNullOrEmpty(filePath)) return;
        lock (_lock)
        {
            if (_loopDataStore.TryGetValue(filePath, out var existingLoop))
            {
                _loopDataStore[filePath] = existingLoop with { IsActive = isActive }; // Using record 'with' expression
                Debug.WriteLine($"[LoopDataService] UpdateLoopActiveState for \"{Path.GetFileName(filePath)}\" to IsActive={isActive}. Triggering save.");
                SaveLoopData();
            }
            else
            {
                Debug.WriteLine($"[LoopDataService] UpdateLoopActiveState: No loop definition found for \"{Path.GetFileName(filePath)}\" to update active state.");
            }
        }
    }

    public void ClearLoop(string filePath)
    {
        if (string.IsNullOrEmpty(filePath)) return;
        bool removed = false;
        lock (_lock)
        {
            if (_loopDataStore.ContainsKey(filePath))
            {
                removed = _loopDataStore.Remove(filePath);
            }
        }
        if (removed)
        {
            Debug.WriteLine($"[LoopDataService] ClearLoop for \"{Path.GetFileName(filePath)}\". Triggering save.");
            SaveLoopData();
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\MusicDirectoryScanner.cs">
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Avalonia.Media.Imaging;
using Avalonia.Threading;
using Sonorize.Models;

namespace Sonorize.Services;

public class MusicDirectoryScanner
{
    private readonly SongFactory _songFactory;
    private readonly ThumbnailService _thumbnailService;

    public MusicDirectoryScanner(SongFactory songFactory, ThumbnailService thumbnailService)
    {
        _songFactory = songFactory ?? throw new ArgumentNullException(nameof(songFactory));
        _thumbnailService = thumbnailService ?? throw new ArgumentNullException(nameof(thumbnailService));
    }

    public async Task ScanAsync(
        IEnumerable<string> directories,
        Action<Song> songAddedCallback,
        Action<string> statusUpdateCallback,
        Bitmap? defaultIcon,
        Action<Song, Bitmap?> thumbnailReadyCallback)
    {
        Debug.WriteLine("[MusicDirScanner] ScanAsync started.");
        var supportedExtensions = new[] { ".mp3", ".wav", ".flac", ".m4a", ".ogg" };
        int totalFilesProcessed = 0;
        int directoriesScanned = 0;

        foreach (string dir in directories)
        {
            int filesProcessedInDir = await ProcessDirectoryAsync(
                dir,
                supportedExtensions,
                songAddedCallback,
                statusUpdateCallback,
                defaultIcon,
                thumbnailReadyCallback
            );

            totalFilesProcessed += filesProcessedInDir;
            directoriesScanned++;

            // Batch update for UI responsiveness, especially with many small directories
            if (directoriesScanned % 5 == 0 || filesProcessedInDir > 0) // Update status if files were found or after every 5 dirs
            {
                await Dispatcher.UIThread.InvokeAsync(() => statusUpdateCallback($"Processed {totalFilesProcessed} songs from {directoriesScanned} directories..."));
            }
        }

        await Dispatcher.UIThread.InvokeAsync(() => statusUpdateCallback($"Metadata scan complete. {totalFilesProcessed} songs found. Thumbnails loading in background..."));
        Debug.WriteLine("[MusicDirScanner] ScanAsync finished.");
    }

    private async Task<int> ProcessDirectoryAsync(
        string directoryPath,
        string[] supportedExtensions,
        Action<Song> songAddedCallback,
        Action<string> statusUpdateCallback,
        Bitmap? defaultIcon,
        Action<Song, Bitmap?> thumbnailReadyCallback)
    {
        if (!Directory.Exists(directoryPath))
        {
            Debug.WriteLine($"[MusicDirScanner] Directory not found: {directoryPath}");
            await Dispatcher.UIThread.InvokeAsync(() => statusUpdateCallback($"Directory not found: {directoryPath}"));
            return 0;
        }

        await Dispatcher.UIThread.InvokeAsync(() => statusUpdateCallback($"Scanning: {Path.GetFileName(directoryPath)}..."));

        List<string> filesInDir;
        try
        {
            filesInDir = Directory.EnumerateFiles(directoryPath, "*.*", SearchOption.AllDirectories)
                .Where(f => supportedExtensions.Any(ext => f.EndsWith(ext, StringComparison.OrdinalIgnoreCase)))
                .ToList();
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[MusicDirScanner] Error enumerating files in {directoryPath}: {ex.Message}");
            await Dispatcher.UIThread.InvokeAsync(() => statusUpdateCallback($"Error scanning {Path.GetFileName(directoryPath)}"));
            return 0;
        }

        int filesProcessedInThisDirectory = 0;
        foreach (var file in filesInDir)
        {
            await ProcessMusicFileAsync(file, defaultIcon, songAddedCallback, thumbnailReadyCallback);
            filesProcessedInThisDirectory++;
        }
        return filesProcessedInThisDirectory;
    }

    private async Task ProcessMusicFileAsync(
        string filePath,
        Bitmap? defaultIcon,
        Action<Song> songAddedCallback,
        Action<Song, Bitmap?> thumbnailReadyCallback)
    {
        Song song = _songFactory.CreateSongFromFile(filePath, defaultIcon);
        await Dispatcher.UIThread.InvokeAsync(() => songAddedCallback(song));
        _thumbnailService.QueueThumbnailRequest(song, thumbnailReadyCallback);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\MusicLibraryService.cs">
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Avalonia.Media.Imaging;
using Sonorize.Models;

namespace Sonorize.Services;

public class MusicLibraryService
{
    private readonly LoopDataService _loopDataService;
    private readonly ThumbnailService _thumbnailService;
    private readonly SongFactory _songFactory;
    private readonly MusicDirectoryScanner _directoryScanner;
    private readonly PlaylistParserService _playlistParserService = new();

    public event Action<Song>? SongThumbnailUpdated;

    public MusicLibraryService(LoopDataService loopDataService, ThumbnailService thumbnailService, SongFactory songFactory)
    {
        _loopDataService = loopDataService ?? throw new ArgumentNullException(nameof(loopDataService));
        _thumbnailService = thumbnailService ?? throw new ArgumentNullException(nameof(thumbnailService));
        _songFactory = songFactory ?? throw new ArgumentNullException(nameof(songFactory));
        _directoryScanner = new MusicDirectoryScanner(_songFactory, _thumbnailService); // Initialize scanner
        Debug.WriteLine("[MusicLibService] Constructor called.");
    }

    public Bitmap? GetDefaultThumbnail() => _thumbnailService.GetDefaultThumbnail();

    public async Task LoadMusicFromDirectoriesAsync(
        IEnumerable<string> directories,
        Action<Song> songAddedCallback,
        Action<string> statusUpdateCallback)
    {
        Debug.WriteLine("[MusicLibService] LoadMusicFromDirectoriesAsync called, delegating to MusicDirectoryScanner.");
        Bitmap? defaultIcon = GetDefaultThumbnail();

        await _directoryScanner.ScanAsync(
            directories,
            songAddedCallback,
            statusUpdateCallback,
            defaultIcon,
            HandleThumbnailReady // Pass the local callback method
        );
        Debug.WriteLine("[MusicLibService] LoadMusicFromDirectoriesAsync delegation completed.");
    }

    public async Task<List<Playlist>> LoadPlaylistsAsync(IEnumerable<string> directories, IEnumerable<Song> allSongs)
    {
        return await Task.Run(() =>
        {
            var playlists = new List<Playlist>();
            var allSongsLookup = allSongs.ToDictionary(s => s.FilePath, StringComparer.OrdinalIgnoreCase);

            if (!allSongsLookup.Any())
            {
                Debug.WriteLine("[MusicLibService] No songs loaded, skipping playlist scan.");
                return playlists;
            }

            foreach (var dir in directories)
            {
                if (Directory.Exists(dir))
                {
                    try
                    {
                        var m3uFiles = Directory.EnumerateFiles(dir, "*.m3u", SearchOption.AllDirectories);
                        foreach (var m3uFile in m3uFiles)
                        {
                            var playlist = _playlistParserService.Parse(m3uFile, allSongsLookup);
                            if (playlist.Songs.Any())
                            {
                                playlists.Add(playlist);
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Debug.WriteLine($"[MusicLibService] Error scanning for playlists in '{dir}': {ex.Message}");
                    }
                }
            }
            Debug.WriteLine($"[MusicLibService] Found {playlists.Count} playlists with songs.");
            return playlists.OrderBy(p => p.Name, StringComparer.OrdinalIgnoreCase).ToList();
        });
    }

    // Callback for when ThumbnailService has processed a thumbnail (called by MusicDirectoryScanner via ThumbnailService)
    private void HandleThumbnailReady(Song song, Bitmap? loadedThumbnail)
    {
        // This callback is invoked on the UI thread by ThumbnailService
        if (loadedThumbnail is not null)
        {
            song.Thumbnail = loadedThumbnail;
        }
        SongThumbnailUpdated?.Invoke(song);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\NAudioWaveformPointGenerator.cs">
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using NAudio.Wave;

namespace Sonorize.Services;

public class NAudioWaveformPointGenerator
{
    public List<WaveformPoint> Generate(string filePath, int targetPoints)
    {
        if (!WaveformProcessingLogic.ValidateInput(filePath, targetPoints, out var validationErrorPoints))
        {
            return validationErrorPoints;
        }

        Debug.WriteLine($"[NAudioWaveformPointGenerator] Generating waveform for \"{Path.GetFileName(filePath)}\". Target points: {targetPoints}.");

        try
        {
            using var reader = WaveformProcessingLogic.TryInitializeReader(filePath, out long totalSampleFrames);

            if (reader is null || totalSampleFrames == 0)
            {
                return [];
            }

            if (!WaveformProcessingLogic.CalculateProcessingParameters(totalSampleFrames,
                targetPoints,
                reader.WaveFormat.Channels,
                out int samplesPerFrameToProcessPerPoint,
                out int bufferSizeInSamples,
                out var paramErrorPoints))
            {
                return paramErrorPoints;
            }

            return WaveformProcessingLogic.ProcessAudioStream(reader, targetPoints, samplesPerFrameToProcessPerPoint, bufferSizeInSamples, filePath);
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[NAudioWaveformPointGenerator] CRITICAL Error generating waveform for \"{Path.GetFileName(filePath)}\": {ex.ToString()}");
            return [];
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\NextTrackSelectorService.cs">
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Sonorize.Models;
using Sonorize.ViewModels;

namespace Sonorize.Services;

public class NextTrackSelectorService(Random shuffleRandom)
{
    private readonly Random _shuffleRandom = shuffleRandom ?? throw new ArgumentNullException(nameof(shuffleRandom));

    public Song? GetNextSong(Song? currentSong, List<Song> currentList, RepeatMode repeatMode, bool shuffleEnabled)
    {
        if (currentSong is null || currentList.Count == 0)
        {
            Debug.WriteLine("[NextTrackSelector] No current song or list is empty. No next song.");
            return null;
        }

        if (repeatMode == RepeatMode.RepeatOne)
        {
            Debug.WriteLine($"[NextTrackSelector] Repeat Mode is RepeatOne. Next song is current: {currentSong.Title}");
            return currentSong;
        }

        if (repeatMode == RepeatMode.None)
        {
            Debug.WriteLine("[NextTrackSelector] Repeat Mode is None. No next song.");
            return null;
        }

        return shuffleEnabled
            ? GetNextSongShuffle(currentSong, currentList, repeatMode)
            : GetNextSongSequential(currentSong, currentList, repeatMode);
    }

    private Song? GetNextSongShuffle(Song currentSong, List<Song> currentList, RepeatMode repeatMode)
    {
        Debug.WriteLine("[NextTrackSelector] Shuffle is Enabled.");

        Song? nextSong = null;

        if (currentList.Count == 0)
        {
            Debug.WriteLine("[NextTrackSelector] Shuffle enabled, but list is empty.");
            return null;
        }

        List<Song> potentialNextSongs = currentList.Where(s => s != currentSong).ToList();

        if (potentialNextSongs.Count != 0)
        {
            int nextIndex = _shuffleRandom.Next(potentialNextSongs.Count);
            nextSong = potentialNextSongs[nextIndex];

            Debug.WriteLine($"[NextTrackSelector] Shuffle pick: {nextSong?.Title ?? "null"}");
        }
        else if (currentList.Count == 1)
        {
            if (repeatMode == RepeatMode.RepeatAll)
            {
                Debug.WriteLine($"[NextTrackSelector] Shuffle enabled, one song in list, RepeatAll active. Replaying: {currentSong.Title}");
                nextSong = currentSong;
            }
            else
            {
                Debug.WriteLine($"[NextTrackSelector] Shuffle enabled, only one song ({currentSong.Title}) in list, not RepeatAll. No next song.");
                nextSong = null;
            }
        }
        else
        {
            Debug.WriteLine("[NextTrackSelector] Shuffle enabled, logical error: no potential next songs from a multi-item list. No next song.");
            nextSong = null;
        }

        return nextSong;
    }

    private static Song? GetNextSongSequential(Song currentSong, List<Song> currentList, RepeatMode repeatMode)
    {
        Debug.WriteLine("[NextTrackSelector] Shuffle is Disabled (Sequential).");
        int currentIndex = currentList.IndexOf(currentSong);

        if (currentIndex == -1)
        {
            Debug.WriteLine("[NextTrackSelector] Sequential: Current song not found in list. No next song.");
            return null;
        }

        Song? nextSong;

        if (currentIndex < currentList.Count - 1)
        {
            nextSong = currentList[currentIndex + 1];
            Debug.WriteLine($"[NextTrackSelector] Sequential next: {nextSong?.Title ?? "null"}");
        }
        else
        {
            Debug.WriteLine("[NextTrackSelector] End of sequential list reached.");

            if (repeatMode == RepeatMode.RepeatAll && currentList.Count != 0)
            {
                nextSong = currentList.First(); // Wrap around
                Debug.WriteLine($"[NextTrackSelector] RepeatAll active, wrapping around to first: {nextSong.Title}");
            }
            else
            {
                Debug.WriteLine($"[NextTrackSelector] RepeatMode is {repeatMode} (not RepeatAll), end of list reached. No next song.");
                nextSong = null;
            }
        }

        return nextSong;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\PlayCountDataService.cs">
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text.Json;

namespace Sonorize.Services;

public class PlayCountDataService
{
    private readonly string _playCountFilePath;
    private Dictionary<string, int> _playCountStore = new();
    private readonly object _lock = new();

    public PlayCountDataService()
    {
        var baseDirectory = AppContext.BaseDirectory;
        var dataDirectory = Path.Combine(baseDirectory, "Data");
        Directory.CreateDirectory(dataDirectory);
        _playCountFilePath = Path.Combine(dataDirectory, "playcounts.json");
        LoadPlayCounts();
        Debug.WriteLine($"[PlayCountDataService] Initialized. Data loaded from: {_playCountFilePath}");
    }

    private void LoadPlayCounts()
    {
        lock (_lock)
        {
            try
            {
                if (File.Exists(_playCountFilePath))
                {
                    var json = File.ReadAllText(_playCountFilePath);
                    _playCountStore = JsonSerializer.Deserialize<Dictionary<string, int>>(json) ?? new();
                }
                else
                {
                    _playCountStore = new();
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[PlayCountDataService] Error loading play count data: {ex.Message}. Initializing with empty store.");
                _playCountStore = new();
            }
        }
    }

    private void SavePlayCounts()
    {
        lock (_lock)
        {
            try
            {
                var options = new JsonSerializerOptions { WriteIndented = true };
                var json = JsonSerializer.Serialize(_playCountStore, options);
                File.WriteAllText(_playCountFilePath, json);
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[PlayCountDataService] Error saving play count data: {ex.Message}");
            }
        }
    }

    public int GetPlayCount(string filePath)
    {
        if (string.IsNullOrEmpty(filePath)) return 0;
        lock (_lock)
        {
            _playCountStore.TryGetValue(filePath, out var count);
            return count;
        }
    }

    public void IncrementPlayCount(string filePath)
    {
        if (string.IsNullOrEmpty(filePath)) return;
        lock (_lock)
        {
            _playCountStore.TryGetValue(filePath, out var currentCount);
            _playCountStore[filePath] = currentCount + 1;
        }
        SavePlayCounts(); // Save after every increment
        Debug.WriteLine($"[PlayCountDataService] Incremented play count for \"{Path.GetFileName(filePath)}\" to {_playCountStore[filePath]}.");
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\PlaylistParserService.cs">
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using Sonorize.Models;

namespace Sonorize.Services;

public class PlaylistParserService
{
    public Playlist Parse(string m3uFilePath, IReadOnlyDictionary<string, Song> allSongsLookup)
    {
        Playlist playlist = new()
        {
            Name = Path.GetFileNameWithoutExtension(m3uFilePath),
            FilePath = m3uFilePath
        };

        try
        {
            string? m3uDirectory = Path.GetDirectoryName(m3uFilePath);
            IEnumerable<string> songEntries = GetSongEntriesFromM3u(m3uFilePath);

            foreach (string songEntry in songEntries)
            {
                if (!TryResolveAbsolutePath(songEntry, m3uDirectory, out var absolutePath))
                {
                    continue;
                }

                if (allSongsLookup.TryGetValue(absolutePath, out var song))
                {
                    playlist.Songs.Add(song);
                }
                else
                {
                    LogFailedLookup(playlist.Name, absolutePath);
                }
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[PlaylistParser] Error parsing playlist file '{m3uFilePath}': {ex.Message}");
        }

        return playlist;
    }

    private static IEnumerable<string> GetSongEntriesFromM3u(string m3uFilePath)
    {
        return File.ReadAllLines(m3uFilePath)
                   .Select(line => line.Trim())
                   .Where(line => !string.IsNullOrEmpty(line) && !line.StartsWith('#'));
    }

    private bool TryResolveAbsolutePath(string songEntry, string? m3uDirectory, out string absolutePath)
    {
        absolutePath = string.Empty;

        if (Path.IsPathRooted(songEntry))
        {
            absolutePath = Path.GetFullPath(songEntry);
            return true;
        }

        if (m3uDirectory is null)
        {
            Debug.WriteLine($"[PlaylistParser] Cannot resolve relative path for '{songEntry}' as M3U directory is null.");
            return false;
        }

        absolutePath = DetermineAbsolutePathForRelativeEntry(songEntry, m3uDirectory);

        return true;
    }

    private string DetermineAbsolutePathForRelativeEntry(string relativeSongPath, string m3uFileDirectory)
    {
        string baseDirectory = GetBaseDirectoryForPathResolution(relativeSongPath, m3uFileDirectory);
        return Path.GetFullPath(Path.Combine(baseDirectory, relativeSongPath));
    }

    private static string GetBaseDirectoryForPathResolution(string relativeSongPath, string m3uFileDirectory)
    {
        string m3uDirectoryName = Path.GetFileName(m3uFileDirectory.TrimEnd(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar));
        string? songPathFirstSegment = relativeSongPath.Split([Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar], 2).FirstOrDefault();

        bool isPathRelativeToLibraryRoot = !string.IsNullOrEmpty(m3uDirectoryName)
            && m3uDirectoryName.Equals(songPathFirstSegment, StringComparison.OrdinalIgnoreCase);

        if (!isPathRelativeToLibraryRoot)
        {
            return m3uFileDirectory;
        }

        string? libraryRoot = Path.GetDirectoryName(m3uFileDirectory);

        if (libraryRoot is not null)
        {
            return libraryRoot;
        }

        return m3uFileDirectory;
    }

    private static void LogFailedLookup(string playlistName, string failedPath)
    {
        Debug.WriteLine($"[PlaylistParser] FAILED LOOKUP: " +
            $"Song from playlist '{playlistName}' not found in library." +
            $" Path: '{failedPath}'");
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\ScrobbleEligibilityService.cs">
using System;
using System.Diagnostics;
using Sonorize.Models; // For Song

namespace Sonorize.Services;

public record ScrobbleThresholds(int ScrobbleThresholdPercentage, int ScrobbleThresholdAbsoluteSeconds);

public class ScrobbleEligibilityService
{
    private const int MinTrackLengthForScrobbleSeconds = 30;

    public static bool ShouldScrobble(Song song, TimeSpan playedDuration, ScrobbleThresholds thresholds)
    {
        if (song == null || song.Duration.TotalSeconds <= MinTrackLengthForScrobbleSeconds)
        {
            Debug.WriteLine($"[ScrobbleEligibilityService] ShouldScrobble: Song '{song?.Title ?? "null"}' is null or too short ({song?.Duration.TotalSeconds ?? 0}s). Min required: {MinTrackLengthForScrobbleSeconds}s. Returning false.");
            return false;
        }

        double percentagePlayed = (playedDuration.TotalSeconds / song.Duration.TotalSeconds) * 100.0;
        double requiredPlaybackFromPercentage = song.Duration.TotalSeconds * (thresholds.ScrobbleThresholdPercentage / 100.0);
        double requiredPlaybackAbsolute = thresholds.ScrobbleThresholdAbsoluteSeconds;

        // Effective threshold is the stricter of the two: percentage-based OR absolute time.
        // However, the Last.fm guideline is "The track must be played for at least half its duration, or for 4 minutes (whichever is shorter)."
        // This implies a MINIMUM of the two conditions (percentage vs absolute) for the *required playback time*, not the maximum.
        // E.g., if 50% is 30s, and absolute is 240s, need 30s. If 50% is 300s, and absolute is 240s, need 240s.
        double effectiveRequiredSeconds = Math.Min(requiredPlaybackFromPercentage, requiredPlaybackAbsolute);

        bool conditionMet = playedDuration.TotalSeconds >= effectiveRequiredSeconds;

        Debug.WriteLine($"[ScrobbleEligibilityService] ShouldScrobble for '{song.Title}': " +
                        $"Played: {playedDuration.TotalSeconds:F1}s ({percentagePlayed:F1}%), " +
                        $"Song Duration: {song.Duration.TotalSeconds:F1}s. " +
                        $"Configured Thresholds: {thresholds.ScrobbleThresholdPercentage}% (gives {requiredPlaybackFromPercentage:F1}s) OR {thresholds.ScrobbleThresholdAbsoluteSeconds}s. " +
                        $"Effective Threshold: {effectiveRequiredSeconds:F1}s. Met: {conditionMet}");
        return conditionMet;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\ScrobblingService.cs">
using System;
using System.Diagnostics;
using System.Threading.Tasks;
using IF.Lastfm.Core.Api;
using IF.Lastfm.Core.Api.Helpers;
using IF.Lastfm.Core.Objects; // Added for service classes like Track, Auth
using Sonorize.Models;

namespace Sonorize.Services;

public class ScrobblingService
{
    private readonly SettingsService _settingsService;
    private readonly LastfmAuthenticatorService _authenticatorService;
    private AppSettings _currentSettings;

    public bool IsScrobblingEnabled => _currentSettings.LastfmScrobblingEnabled;

    public bool AreCredentialsEffectivelyConfigured
    {
        get
        {
            return LastfmAuthenticatorService.AreCredentialsEffectivelyConfigured(_currentSettings);
        }
    }

    // ScrobbleEligibilityService constants and logic moved here
    private const int MinTrackLengthForScrobbleSeconds = 30;

    private static bool DetermineScrobbleEligibility(Song song, TimeSpan playedDuration, ScrobbleThresholds thresholds)
    {
        if (song == null || song.Duration.TotalSeconds <= MinTrackLengthForScrobbleSeconds)
        {
            Debug.WriteLine($"[ScrobblingService.Eligibility] Song " +
                $"'{song?.Title ?? "null"}'" +
                $" is null or too short " +
                $"({song?.Duration.TotalSeconds ?? 0}s). " +
                $"Min required: {MinTrackLengthForScrobbleSeconds}s. " +
                $"Not scrobbling.");

            return false;
        }

        double percentagePlayed = (playedDuration.TotalSeconds / song.Duration.TotalSeconds) * 100.0;
        double requiredPlaybackFromPercentage = song.Duration.TotalSeconds * (thresholds.ScrobbleThresholdPercentage / 100.0);
        double requiredPlaybackAbsolute = thresholds.ScrobbleThresholdAbsoluteSeconds;

        double effectiveRequiredSeconds = Math.Min(requiredPlaybackFromPercentage, requiredPlaybackAbsolute);

        bool conditionMet = playedDuration.TotalSeconds >= effectiveRequiredSeconds;

        //Debug.WriteLine($"[ScrobblingService.Eligibility] For '{song.Title}': " +
        //                $"Played: {playedDuration.TotalSeconds:F1}s ({percentagePlayed:F1}%), " +
        //                $"Song Duration: {song.Duration.TotalSeconds:F1}s. " +
        //                $"Configured Thresholds: {thresholds.ScrobbleThresholdPercentage}% (gives {requiredPlaybackFromPercentage:F1}s) OR {thresholds.ScrobbleThresholdAbsoluteSeconds}s. " +
        //                $"Effective Threshold: {effectiveRequiredSeconds:F1}s. " +
        //                $"Met: {conditionMet}");
        return conditionMet;
    }


    public ScrobblingService(
        SettingsService settingsService,
        LastfmAuthenticatorService authenticatorService)
    {
        _settingsService = settingsService ?? throw new ArgumentNullException(nameof(settingsService));
        _authenticatorService = authenticatorService ?? throw new ArgumentNullException(nameof(authenticatorService));
        RefreshSettings(); // Initial load of settings
        Debug.WriteLine($"[ScrobblingService] Initialized. Scrobbling Enabled: {IsScrobblingEnabled}, Credentials Configured: {AreCredentialsEffectivelyConfigured}");
    }

    public void RefreshSettings()
    {
        _currentSettings = _settingsService.LoadSettings();
        Debug.WriteLine($"[ScrobblingService] Settings refreshed. " +
            $"Scrobbling Enabled: {IsScrobblingEnabled}, " +
            $"Credentials Configured: {AreCredentialsEffectivelyConfigured}, " +
            $"Thresholds: {_currentSettings.ScrobbleThresholdPercentage}% / {_currentSettings.ScrobbleThresholdAbsoluteSeconds}s");
    }

    private async Task<LastfmClient?> GetAuthenticatedClientAsync()
    {
        // _authenticatorService.GetAuthenticatedClientAsync() will load settings itself if needed.
        // No need to call RefreshSettings() here as it would be redundant.
        return await _authenticatorService.GetAuthenticatedClientAsync();
    }

    public bool ShouldScrobble(Song song, TimeSpan playedDuration)
    {
        // Rely on _currentSettings being up-to-date from constructor or external RefreshSettings call.
        var thresholds = new ScrobbleThresholds(
            _currentSettings.ScrobbleThresholdPercentage,
            _currentSettings.ScrobbleThresholdAbsoluteSeconds);

        return DetermineScrobbleEligibility(song, playedDuration, thresholds);
    }


    public async Task UpdateNowPlayingAsync(Song song)
    {
        // Rely on _currentSettings being up-to-date.
        if (!IsScrobblingEnabled || song == null)
        {
            Debug.WriteLine($"[ScrobblingService] UpdateNowPlayingAsync skipped. Enabled: {IsScrobblingEnabled}, Song: {song?.Title ?? "null"}");
            return;
        }

        // FINAL SAFEGUARD: Last.fm requires artist and title for scrobbles.
        if (string.IsNullOrWhiteSpace(song.Artist) || string.IsNullOrWhiteSpace(song.Title))
        {
            Debug.WriteLine($"[ScrobblingService] UpdateNowPlayingAsync skipped for '{song.FilePath}'. Reason: Artist or Title metadata is missing.");
            return;
        }

        var client = await GetAuthenticatedClientAsync();
        if (client == null)
        {
            Debug.WriteLine("[ScrobblingService] UpdateNowPlayingAsync: No authenticated client. Skipping.");
            return;
        }

        try
        {
            LastResponse? response = null;
            for (int i = 0; i < 2; i++) // Retry once on failure
            {
                Debug.WriteLine($"[ScrobblingService] Sending UpdateNowPlaying for: {song.Title} by {song.Artist} (Attempt {i + 1})");
                var scrobble = new Scrobble(song.Artist, song.Album, song.Title, DateTimeOffset.Now);
                response = await client.Track.UpdateNowPlayingAsync(scrobble);

                if (response.Success)
                {
                    Debug.WriteLine($"[ScrobblingService] UpdateNowPlaying successful for: {song.Title}");
                    break; // Exit loop on success
                }
                else
                {
                    Debug.WriteLine($"[ScrobblingService] UpdateNowPlaying FAILED for: {song.Title}. Error: {response.Status} - {response.Error}");
                    if (i == 0) // If it's the first attempt
                    {
                        Debug.WriteLine("[ScrobblingService] Waiting 2 seconds before retry...");
                        await Task.Delay(2000);
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[ScrobblingService] CRITICAL EXCEPTION during UpdateNowPlaying for {song.Title}: {ex.Message}");
        }
    }

    public async Task ScrobbleAsync(Song song, DateTime timePlayed)
    {
        // Rely on _currentSettings being up-to-date.
        if (!IsScrobblingEnabled || song == null)
        {
            Debug.WriteLine($"[ScrobblingService] ScrobbleAsync skipped. Enabled: {IsScrobblingEnabled}, Song: {song?.Title ?? "null"}");
            return;
        }

        // FINAL SAFEGUARD: Last.fm requires artist and title for scrobbles.
        if (string.IsNullOrWhiteSpace(song.Artist) || string.IsNullOrWhiteSpace(song.Title))
        {
            Debug.WriteLine($"[ScrobblingService] ScrobbleAsync skipped for '{song.FilePath}'. Reason: Artist or Title metadata is missing.");
            return;
        }

        var client = await GetAuthenticatedClientAsync();
        if (client == null)
        {
            Debug.WriteLine("[ScrobblingService] ScrobbleAsync: No authenticated client. Skipping.");
            return;
        }

        try
        {
            LastResponse? response = null;
            for (int i = 0; i < 2; i++) // Retry once on failure
            {
                Debug.WriteLine($"[ScrobblingService] Sending Scrobble for: {song.Title} by {song.Artist}, TimePlayed: {timePlayed} (Attempt {i + 1})");
                var scrobble = new Scrobble(song.Artist, song.Album, song.Title, timePlayed);
                response = await client.Track.ScrobbleAsync(scrobble);

                if (response.Success)
                {
                    Debug.WriteLine($"[ScrobblingService] Scrobble successful for: {song.Title}");
                    break; // Exit loop on success
                }
                else
                {
                    Debug.WriteLine($"[ScrobblingService] Scrobble FAILED for: {song.Title}. Error: {response.Status} - {response.Error}");
                    if (i == 0) // If it's the first attempt
                    {
                        Debug.WriteLine("[ScrobblingService] Waiting 2 seconds before retry...");
                        await Task.Delay(2000);
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[ScrobblingService] CRITICAL EXCEPTION during Scrobble for {song.Title}: {ex.Message}");
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\SongEditInteractionService.cs">
using System;
using System.Diagnostics;
using System.Threading.Tasks;
using Avalonia.Controls;
using Sonorize.Models;
using Sonorize.Services.Playback; // For PlaybackResourceInterlockService
using Sonorize.ViewModels; // For SongMetadataEditorViewModel

namespace Sonorize.Services;

public class SongEditInteractionService
{
    private readonly PlaybackResourceInterlockService _playbackResourceInterlock;
    private readonly SongMetadataService _songMetadataService;
    private readonly ThemeColors _currentTheme;

    public SongEditInteractionService(
        PlaybackResourceInterlockService playbackResourceInterlock,
        SongMetadataService songMetadataService,
        ThemeColors currentTheme)
    {
        _playbackResourceInterlock = playbackResourceInterlock ?? throw new ArgumentNullException(nameof(playbackResourceInterlock));
        _songMetadataService = songMetadataService ?? throw new ArgumentNullException(nameof(songMetadataService));
        _currentTheme = currentTheme ?? throw new ArgumentNullException(nameof(currentTheme));
        Debug.WriteLine("[SongEditInteractionService] Initialized.");
    }

    public async Task<(bool metadataSaved, string statusMessage)> HandleEditSongMetadataAsync(Song songToEdit, Window ownerWindow)
    {
        if (songToEdit == null)
        {
            Debug.WriteLine("[SongEditInteractionService] HandleEditSongMetadataAsync: Song is null.");
            return (false, "Error: No song selected for editing.");
        }

        if (ownerWindow == null)
        {
            Debug.WriteLine("[SongEditInteractionService] HandleEditSongMetadataAsync: Owner window is null.");
            return (false, "Error: Cannot open editor dialog without an owner window.");
        }

        (bool WasPlaying, TimeSpan Position)? previousPlaybackState = null;

        // Use PlaybackResourceInterlockService to prepare for editing
        previousPlaybackState = _playbackResourceInterlock.PrepareForExternalOperation(songToEdit);

        if (previousPlaybackState == null && _playbackResourceInterlock.PrepareForExternalOperation(songToEdit) is not null) // Check if the song was the one playing
        {
            // This case implies the song *was* current, but PrepareForExternalOperation failed to return state (should not happen if song matches)
            // Or, more likely, if the songToEdit was NOT the current song, previousPlaybackState would be null.
            // The logic of PrepareForExternalOperation already handles if the song is not current.
            // If previousPlaybackState is null it means either the song wasn't current, or an issue occurred.
            // If it was current and an issue occurred, _playbackResourceInterlock.PrepareForExternalOperation might log it.
            // For this method, if previousPlaybackState is null after call, it means we couldn't (or didn't need to) get its state.
            // If it *was* the current song but something went wrong in Prepare, we should not proceed.
            // The check inside PrepareForExternalOperation `if (_sessionManager.CurrentSong != song)` handles non-current songs returning null.
            // So, if it's null here, it was either not the current song, or songToEdit was null (already checked).
            // If it *was* the current song and PrepareForExternalOperation returned null due to an *internal error* in Prepare,
            // that's an issue for PrepareForExternalOperation to log.
            // From this method's perspective, if previousPlaybackState is not null, it means the song was current and resources were released.
        }


        bool metadataSaved = false;
        string finalStatusMessage = string.Empty;

        try
        {
            var editorViewModel = new SongMetadataEditorViewModel(songToEdit);
            var editorDialog = new Sonorize.Views.SongMetadataEditorWindow(_currentTheme)
            {
                DataContext = editorViewModel
            };
            await editorDialog.ShowDialog(ownerWindow);

            if (editorViewModel.DialogResult)
            {
                Debug.WriteLine($"[SongEditInteractionService] Metadata editor for {songToEdit.Title} closed with Save. Attempting to save to file.");
                metadataSaved = await _songMetadataService.SaveMetadataAsync(songToEdit);
                if (metadataSaved)
                {
                    Debug.WriteLine($"[SongEditInteractionService] Metadata (and thumbnail) for {songToEdit.Title} saved to file successfully.");
                    finalStatusMessage = $"Metadata for '{songToEdit.Title}' updated.";
                }
                else
                {
                    Debug.WriteLine($"[SongEditInteractionService] Failed to save metadata for {songToEdit.Title} to file.");
                    finalStatusMessage = $"Error saving metadata for '{songToEdit.Title}'.";
                }
            }
            else
            {
                Debug.WriteLine($"[SongEditInteractionService] Metadata editor for {songToEdit.Title} closed without saving.");
                finalStatusMessage = "Metadata editing cancelled.";
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[SongEditInteractionService] Exception during metadata edit/save for {songToEdit.Title}: {ex.Message}");
            finalStatusMessage = $"Error during metadata edit for '{songToEdit.Title}'.";
            metadataSaved = false;
        }
        finally
        {
            if (previousPlaybackState.HasValue)
            {
                Debug.WriteLine($"[SongEditInteractionService] Reinitializing playback for {songToEdit.Title} to WasPlaying: {previousPlaybackState.Value.WasPlaying}, Position: {previousPlaybackState.Value.Position}");
                // Use PlaybackResourceInterlockService to resume playback
                bool reinitSuccess = _playbackResourceInterlock.ResumeAfterExternalOperation(songToEdit, previousPlaybackState.Value.Position, previousPlaybackState.Value.WasPlaying);
                if (!reinitSuccess)
                {
                    Debug.WriteLine($"[SongEditInteractionService] Failed to reinitialize playback for {songToEdit.Title}.");
                    finalStatusMessage = string.IsNullOrEmpty(finalStatusMessage) || finalStatusMessage.StartsWith("Error") ?
                                         $"Playback error after editing '{songToEdit.Title}'." :
                                         finalStatusMessage + $" (Playback error after edit)";
                }
            }
        }
        return (metadataSaved, finalStatusMessage);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\SongFactory.cs">
using System;
using System.Diagnostics;
using System.IO;
using Avalonia.Media.Imaging;
using Sonorize.Models;
using TagLib; // Required for TagLib.File, CorruptFileException, UnsupportedFormatException

namespace Sonorize.Services;

public class SongFactory
{
    private readonly LoopDataService _loopDataService;
    private readonly PlayCountDataService _playCountDataService;

    public SongFactory(LoopDataService loopDataService, PlayCountDataService playCountDataService)
    {
        _loopDataService = loopDataService ?? throw new ArgumentNullException(nameof(loopDataService));
        _playCountDataService = playCountDataService ?? throw new ArgumentNullException(nameof(playCountDataService));
        Debug.WriteLine("[SongFactory] Initialized.");
    }

    public Song CreateSongFromFile(string filePath, Bitmap? defaultThumbnail)
    {
        if (string.IsNullOrEmpty(filePath))
        {
            Debug.WriteLine("[SongFactory] FilePath is null or empty. Returning a default Song object.");
            return new Song { FilePath = string.Empty, Thumbnail = defaultThumbnail };
        }

        var song = new Song
        {
            FilePath = filePath,
            Title = Path.GetFileNameWithoutExtension(filePath), // Default title
            Artist = "Unknown Artist",                         // Default artist
            Album = "Unknown Album",                           // Default album
            Duration = TimeSpan.Zero,                          // Default duration
            Thumbnail = defaultThumbnail                       // Initial default thumbnail
        };

        try
        {
            using var tagFile = TagLib.File.Create(filePath);
            if (!string.IsNullOrWhiteSpace(tagFile.Tag.Title)) song.Title = tagFile.Tag.Title;

            if (tagFile.Tag.Performers.Length > 0 && !string.IsNullOrWhiteSpace(tagFile.Tag.Performers[0]))
                song.Artist = tagFile.Tag.Performers[0];
            else if (tagFile.Tag.AlbumArtists.Length > 0 && !string.IsNullOrWhiteSpace(tagFile.Tag.AlbumArtists[0]))
                song.Artist = tagFile.Tag.AlbumArtists[0];

            if (!string.IsNullOrWhiteSpace(tagFile.Tag.Album)) song.Album = tagFile.Tag.Album;
            if (tagFile.Properties.Duration > TimeSpan.Zero) song.Duration = tagFile.Properties.Duration;
        }
        catch (CorruptFileException cfe)
        {
            Debug.WriteLine($"[SongFactory] Corrupt file when reading tags for \"{Path.GetFileName(filePath)}\": {cfe.Message}. Song will use defaults.");
        }
        catch (UnsupportedFormatException ufe)
        {
            Debug.WriteLine($"[SongFactory] Unsupported format when reading tags for \"{Path.GetFileName(filePath)}\": {ufe.Message}. Song will use defaults.");
        }
        catch (Exception ex)
        {
            // Catching generic Exception for any other TagLib# related issues
            Debug.WriteLine($"[SongFactory] Error reading tags for \"{Path.GetFileName(filePath)}\": {ex.Message}. Song will use defaults.");
        }

        try
        {
            song.DateAdded = new FileInfo(filePath).CreationTimeUtc;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[SongFactory] Could not read file creation time for {Path.GetFileName(filePath)}: {ex.Message}. Using current time as fallback.");
            song.DateAdded = DateTime.UtcNow;
        }

        var storedLoopData = _loopDataService.GetLoop(song.FilePath);
        if (storedLoopData is not null)
        {
            song.SavedLoop = new LoopRegion(storedLoopData.Start, storedLoopData.End);
            song.IsLoopActive = storedLoopData.IsActive;
        }

        song.PlayCount = _playCountDataService.GetPlayCount(song.FilePath);

        return song;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\SongLoopService.cs">
using System;
using System.Diagnostics;
using Sonorize.Models;

namespace Sonorize.Services;

public class SongLoopService
{
    private readonly LoopDataService _loopDataService;

    public SongLoopService(LoopDataService loopDataService)
    {
        _loopDataService = loopDataService ?? throw new ArgumentNullException(nameof(loopDataService));
        Debug.WriteLine("[SongLoopService] Initialized.");
    }

    public void SaveLoop(Song song, TimeSpan start, TimeSpan end, bool activate)
    {
        if (song == null)
        {
            Debug.WriteLine("[SongLoopService] SaveLoop: Song is null.");
            return;
        }

        song.SavedLoop = new LoopRegion(start, end, "User Loop");
        song.IsLoopActive = activate; // This will raise PropertyChanged on the Song model

        _loopDataService.SetLoop(song.FilePath, start, end, activate);
        Debug.WriteLine($"[SongLoopService] Loop saved and persisted for {song.Title}. Start: {start}, End: {end}, Active: {activate}");
    }

    public void ClearLoop(Song song)
    {
        if (song == null)
        {
            Debug.WriteLine("[SongLoopService] ClearLoop: Song is null.");
            return;
        }

        var filePath = song.FilePath;
        // Update model first
        song.IsLoopActive = false;
        song.SavedLoop = null; // This will raise PropertyChanged on the Song model

        if (!string.IsNullOrEmpty(filePath))
        {
            _loopDataService.ClearLoop(filePath);
        }
        Debug.WriteLine($"[SongLoopService] Loop cleared and persistence updated for {song.Title}.");
    }

    public void SetLoopActiveState(Song song, bool isActive)
    {
        if (song == null)
        {
            Debug.WriteLine("[SongLoopService] SetLoopActiveState: Song is null.");
            return;
        }

        if (song.SavedLoop == null && isActive)
        {
            Debug.WriteLine($"[SongLoopService] SetLoopActiveState: Cannot activate loop for {song.Title} as no loop is defined. No change made.");
            return; // Do not change IsLoopActive if no loop is defined and trying to activate.
        }

        if (song.IsLoopActive == isActive) // No change needed
        {
            return;
        }

        song.IsLoopActive = isActive; // This will raise PropertyChanged on the Song model

        // Persist only if a loop actually exists
        if (song.SavedLoop is not null)
        {
            _loopDataService.UpdateLoopActiveState(song.FilePath, isActive);
            Debug.WriteLine($"[SongLoopService] Loop active state for {song.Title} set to {isActive} and persisted.");
        }
        else
        {
            // This case should ideally be caught by the check above, 
            // but as a safeguard: if IsLoopActive was true and loop became null, ensure it's set to false.
            if (isActive) // Should not happen if SavedLoop is null
            {
                song.IsLoopActive = false; // Correct the model state
                Debug.WriteLine($"[SongLoopService] Corrected IsLoopActive to false for {song.Title} as SavedLoop is null.");
            }
            // No persistence needed if SavedLoop is null, IsLoopActive should be false.
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\SongMetadataService.cs">
using System;
using System.Diagnostics;
using System.IO;
using System.Threading.Tasks;
using Avalonia.Media.Imaging; // Required for Bitmap
using Sonorize.Models;
using TagLib;

namespace Sonorize.Services;

public class SongMetadataService
{
    public async Task<bool> SaveMetadataAsync(Song song)
    {
        if (song == null || string.IsNullOrEmpty(song.FilePath) || !System.IO.File.Exists(song.FilePath))
        {
            Debug.WriteLine("[SongMetadataService] SaveMetadataAsync: Invalid song or file path.");
            return false;
        }

        try
        {
            await Task.Run(() =>
            {
                using var tagFile = TagLib.File.Create(song.FilePath);

                tagFile.Tag.Title = song.Title;
                tagFile.Tag.Performers = new[] { song.Artist };
                tagFile.Tag.AlbumArtists = new[] { song.Artist };
                tagFile.Tag.Album = song.Album;

                // Handle Thumbnail
                if (song.Thumbnail is not null)
                {
                    using var ms = new MemoryStream();
                    // Save the Avalonia Bitmap to a stream (defaults to PNG format)
                    song.Thumbnail.Save(ms);
                    ms.Position = 0;
                    var pictureData = ms.ToArray();

                    var newPicture = new TagLib.Picture(new TagLib.ByteVector(pictureData))
                    {
                        Type = TagLib.PictureType.FrontCover,
                        MimeType = "image/png" // Assuming PNG, as Avalonia's Bitmap.Save default
                        // Description = "Cover" // Optional
                    };
                    tagFile.Tag.Pictures = new IPicture[] { newPicture };
                    Debug.WriteLine($"[SongMetadataService] Thumbnail data prepared for saving for: {Path.GetFileName(song.FilePath)}");
                }
                else
                {
                    // If song.Thumbnail is null, clear existing pictures from the file
                    tagFile.Tag.Pictures = Array.Empty<IPicture>();
                    Debug.WriteLine($"[SongMetadataService] Thumbnail is null. Clearing existing pictures for: {Path.GetFileName(song.FilePath)}");
                }

                tagFile.Save();
                Debug.WriteLine($"[SongMetadataService] Metadata (and potentially thumbnail) saved successfully for: {Path.GetFileName(song.FilePath)}");
            });
            return true;
        }
        catch (CorruptFileException cfe)
        {
            Debug.WriteLine($"[SongMetadataService] Corrupt file when saving metadata for \"{Path.GetFileName(song.FilePath)}\": {cfe.Message}");
        }
        catch (UnsupportedFormatException ufe)
        {
            Debug.WriteLine($"[SongMetadataService] Unsupported format when saving metadata for \"{Path.GetFileName(song.FilePath)}\": {ufe.Message}");
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[SongMetadataService] Error saving metadata for \"{Path.GetFileName(song.FilePath)}\": {ex.Message} - Stack: {ex.StackTrace}");
        }
        return false;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\ThemeService.cs">
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text.Json;
using Sonorize.Models;

namespace Sonorize.Services;

public class ThemeService
{
    private readonly string _themesDirectory;
    public ThemeColors CurrentTheme { get; private set; }

    public const string DefaultThemeFileName = "DefaultTheme.json"; // Made public const
    private const string AmoledSpotifyThemeFileName = "AmoledSpotify.json";


    public ThemeService(string? preferredThemeNameFromSettings)
    {
        var baseDirectory = AppContext.BaseDirectory;
        var dataDirectory = Path.Combine(baseDirectory, "Data");
        _themesDirectory = Path.Combine(dataDirectory, "Themes");
        Directory.CreateDirectory(_themesDirectory);

        EnsureDefaultThemesExist();

        string themeToLoad = DefaultThemeFileName; // Default to this one first

        if (!string.IsNullOrEmpty(preferredThemeNameFromSettings))
        {
            // Check if preferred theme exists
            if (File.Exists(Path.Combine(_themesDirectory, preferredThemeNameFromSettings)))
            {
                themeToLoad = preferredThemeNameFromSettings;
            }
            else
            {
                Debug.WriteLine($"[ThemeService] Preferred theme '{preferredThemeNameFromSettings}' not found. Falling back to default.");
            }
        }

        CurrentTheme = LoadThemeFromFile(themeToLoad);
        if (CurrentTheme == null) // If chosen (or default) theme failed, use hardcoded
        {
            Debug.WriteLine($"[ThemeService] Theme '{themeToLoad}' failed to load. Using hardcoded fallback (standard dark).");
            CurrentTheme = new ThemeColors(); // Hardcoded fallback (standard dark)
        }
        Debug.WriteLine($"[ThemeService] Current theme loaded: {themeToLoad} (BG: {CurrentTheme.BackgroundColor}, Accent: {CurrentTheme.AccentColor})");
    }

    private void EnsureDefaultThemesExist()
    {
        string defaultThemePath = Path.Combine(_themesDirectory, DefaultThemeFileName);
        if (!File.Exists(defaultThemePath))
        {
            SaveThemeToFile(new ThemeColors(), DefaultThemeFileName);
        }

        string amoledSpotifyThemePath = Path.Combine(_themesDirectory, AmoledSpotifyThemeFileName);
        if (!File.Exists(amoledSpotifyThemePath))
        {
            SaveThemeToFile(ThemeColors.CreateAmoledSpotifyTheme(), AmoledSpotifyThemeFileName);
        }
    }

    public ThemeColors? LoadThemeFromFile(string themeFileName)
    {
        // ... (LoadThemeFromFile remains the same as previous correct version) ...
        string filePath = Path.Combine(_themesDirectory, themeFileName);
        Debug.WriteLine($"[ThemeService] Attempting to load theme from: {filePath}");
        if (File.Exists(filePath))
        {
            try
            {
                var json = File.ReadAllText(filePath);
                var theme = JsonSerializer.Deserialize<ThemeColors>(json);
                if (theme is not null)
                {
                    Debug.WriteLine($"[ThemeService] Theme '{themeFileName}' loaded successfully.");
                    return theme;
                }
                Debug.WriteLine($"[ThemeService] Failed to deserialize theme '{themeFileName}'. Json content was: {json.Substring(0, Math.Min(json.Length, 200))}");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[ThemeService] Error loading theme '{themeFileName}': {ex.Message}");
            }
        }
        else
        {
            Debug.WriteLine($"[ThemeService] Theme file not found: {filePath}");
        }
        return null;
    }

    public void SaveThemeToFile(ThemeColors theme, string themeFileName)
    {
        // ... (SaveThemeToFile remains the same as previous correct version) ...
        string filePath = Path.Combine(_themesDirectory, themeFileName);
        try
        {
            var options = new JsonSerializerOptions { WriteIndented = true };
            var json = JsonSerializer.Serialize(theme, options);
            File.WriteAllText(filePath, json);
            Debug.WriteLine($"[ThemeService] Theme '{themeFileName}' saved to: {filePath}");
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[ThemeService] Error saving theme '{themeFileName}': {ex.Message}");
        }
    }

    public List<string> GetAvailableThemeFiles()
    {
        if (!Directory.Exists(_themesDirectory))
        {
            return new List<string>();
        }
        return Directory.GetFiles(_themesDirectory, "*.json")
                        .Select(Path.GetFileName)
                        .Where(f => f is not null) // Path.GetFileName can return null
                        .ToList()!; // Non-null asserted as we filter nulls
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\ThumbnailService.cs">
using System;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Avalonia;
using Avalonia.Media;
using Avalonia.Media.Imaging;
using Avalonia.Threading;
using Sonorize.Models;
// TagLib is no longer directly used by ThumbnailService

namespace Sonorize.Services;

public class ThumbnailService : IDisposable
{
    private Bitmap? _defaultThumbnail;
    private readonly ConcurrentQueue<ThumbnailRequest> _thumbnailQueue = new();
    private readonly SemaphoreSlim _thumbnailWorkers = new(4); // Limit concurrent thumbnail loads
    private Task? _processingTask;
    private CancellationTokenSource _cts = new();
    private readonly object _lock = new();
    private readonly DefaultIconGenerator _defaultIconGenerator;
    private readonly AlbumArtLoader _albumArtLoader;


    private record ThumbnailRequest(Song SongToUpdate, Action<Song, Bitmap?> Callback);

    public ThumbnailService(DefaultIconGenerator defaultIconGenerator, AlbumArtLoader albumArtLoader) // Constructor for DI
    {
        _defaultIconGenerator = defaultIconGenerator ?? throw new ArgumentNullException(nameof(defaultIconGenerator));
        _albumArtLoader = albumArtLoader ?? throw new ArgumentNullException(nameof(albumArtLoader));
        Debug.WriteLine("[ThumbnailService] Initialized.");
        // _defaultThumbnail will be created on first access via GetDefaultThumbnail()
    }

    public Bitmap? GetDefaultThumbnail()
    {
        _defaultThumbnail ??= DefaultIconGenerator.CreateMusicalNoteIcon();
        return _defaultThumbnail;
    }

    public void QueueThumbnailRequest(Song song, Action<Song, Bitmap?> onThumbnailReadyCallback)
    {
        if (song == null) throw new ArgumentNullException(nameof(song));
        if (onThumbnailReadyCallback == null) throw new ArgumentNullException(nameof(onThumbnailReadyCallback));

        _thumbnailQueue.Enqueue(new ThumbnailRequest(song, onThumbnailReadyCallback));
        EnsureProcessingRunning();
    }

    private void EnsureProcessingRunning()
    {
        lock (_lock)
        {
            if (_processingTask == null || _processingTask.IsCompleted)
            {
                _cts = new CancellationTokenSource(); // Reset CTS if task was completed/faulted
                _processingTask = Task.Run(ProcessQueueAsync, _cts.Token);
                Debug.WriteLine("[ThumbnailService] Thumbnail processing task started.");
            }
        }
    }

    private async Task ProcessQueueAsync()
    {
        Debug.WriteLine("[ThumbnailService] ProcessQueueAsync loop started.");
        try
        {
            while (!_cts.Token.IsCancellationRequested)
            {
                if (_thumbnailQueue.TryDequeue(out var request))
                {
                    await _thumbnailWorkers.WaitAsync(_cts.Token); // Wait for a free worker slot

                    // Fire-and-forget the actual loading for this request to not block the dequeuing loop
                    _ = Task.Run(async () =>
                    {
                        Bitmap? loadedThumbnail = null;
                        try
                        {
                            if (!_cts.Token.IsCancellationRequested)
                            {
                                // Delegate loading to AlbumArtLoader
                                loadedThumbnail = await _albumArtLoader.LoadFromFileAsync(request.SongToUpdate.FilePath);

                                // Callback needs to be on UI thread as it might update UI-bound properties
                                await Dispatcher.UIThread.InvokeAsync(() =>
                                {
                                    request.Callback(request.SongToUpdate, loadedThumbnail);
                                }, DispatcherPriority.Background, _cts.Token);
                            }
                        }
                        catch (OperationCanceledException)
                        {
                            Debug.WriteLine($"[ThumbnailService] Thumbnail loading task (via AlbumArtLoader) cancelled for {request.SongToUpdate.Title}.");
                        }
                        catch (Exception ex)
                        {
                            Debug.WriteLine($"[ThumbnailService] Error during thumbnail processing for {request.SongToUpdate.Title}: {ex.Message}");
                            // Invoke callback with null to signal completion, even on error
                            try
                            {
                                await Dispatcher.UIThread.InvokeAsync(() =>
                                {
                                    request.Callback(request.SongToUpdate, null);
                                }, DispatcherPriority.Background); // Don't use cancelled token for cleanup callback
                            }
                            catch (Exception callbackEx)
                            {
                                Debug.WriteLine($"[ThumbnailService] Error invoking callback after error for {request.SongToUpdate.Title}: {callbackEx.Message}");
                            }
                        }
                        finally
                        {
                            _thumbnailWorkers.Release();
                        }
                    }, _cts.Token);
                }
                else
                {
                    // Queue is empty, wait a bit before checking again or break if cancellation is requested
                    await Task.Delay(100, _cts.Token);
                }
            }
        }
        catch (OperationCanceledException)
        {
            Debug.WriteLine("[ThumbnailService] ProcessQueueAsync task itself cancelled.");
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[ThumbnailService] Unhandled exception in ProcessQueueAsync: {ex}");
        }
        finally
        {
            Debug.WriteLine("[ThumbnailService] ProcessQueueAsync loop finished.");
            lock (_lock) // Ensure task is nulled out safely
            {
                _processingTask = null;
            }
        }
    }

    public void Dispose()
    {
        Debug.WriteLine("[ThumbnailService] Dispose called.");
        lock (_lock)
        {
            if (!_cts.IsCancellationRequested)
            {
                _cts.Cancel();
            }
        }

        // Wait for the processing task to complete, with a timeout
        _processingTask?.Wait(TimeSpan.FromSeconds(5));

        _cts.Dispose();
        _thumbnailWorkers.Dispose();
        _defaultThumbnail?.Dispose(); // Dispose the bitmap if it was created
        Debug.WriteLine("[ThumbnailService] Dispose finished.");
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\WaveformProcessingLogic.cs">
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using NAudio.Wave;

namespace Sonorize.Services;

internal static class WaveformProcessingLogic
{
    internal static bool ValidateInput(string filePath, int targetPoints, out List<WaveformPoint> errorResult)
    {
        errorResult = [];

        if (string.IsNullOrEmpty(filePath) || targetPoints <= 0)
        {
            Debug.WriteLine($"[WaveformProcessingLogic] Invalid input: filePath is null/empty or targetPoints <= 0. File: '{filePath}', Points: {targetPoints}");
            return false;
        }

        return true;
    }

    internal static AudioFileReader? TryInitializeReader(string filePath, out long totalSampleFrames)
    {
        totalSampleFrames = 0;
        AudioFileReader? reader;

        try
        {
            reader = new(filePath);
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[WaveformProcessingLogic] Failed to initialize AudioFileReader for \"{Path.GetFileName(filePath)}\": {ex.Message}");
            return null;
        }

        Debug.WriteLine($"[WaveformProcessingLogicReader] File: \"{Path.GetFileName(filePath)}\", TotalTime: {reader.TotalTime}, Channels: {reader.WaveFormat.Channels}, SampleRate: {reader.WaveFormat.SampleRate}, BitsPerSample: {reader.WaveFormat.BitsPerSample}, Encoding: {reader.WaveFormat.Encoding}, BlockAlign: {reader.WaveFormat.BlockAlign}, Length (bytes): {reader.Length}");

        if (reader.WaveFormat.BlockAlign == 0)
        {
            Debug.WriteLine($"[WaveformProcessingLogicReader] File \"{Path.GetFileName(filePath)}\" has BlockAlign = 0. Cannot calculate total sample frames.");
            reader.Dispose();
            return null;
        }

        totalSampleFrames = reader.Length / reader.WaveFormat.BlockAlign;

        if (totalSampleFrames == 0)
        {
            Debug.WriteLine($"[WaveformProcessingLogicReader] File \"{Path.GetFileName(filePath)}\" has 0 sample frames (Length: {reader.Length}, BlockAlign: {reader.WaveFormat.BlockAlign}). Cannot generate waveform.");
            reader.Dispose();
            return null;
        }

        return reader;
    }

    internal static bool CalculateProcessingParameters(
        long totalSampleFrames,
        int targetPoints,
        int channels,
        out int samplesPerFrameToProcessPerPoint,
        out int bufferSizeInSamples,
        out List<WaveformPoint> errorResult)
    {
        errorResult = [];
        samplesPerFrameToProcessPerPoint = (int)Math.Max(1, totalSampleFrames / targetPoints);
        bufferSizeInSamples = samplesPerFrameToProcessPerPoint * channels;

        if (bufferSizeInSamples == 0)
        {
            Debug.WriteLine($"[WaveformProcessingLogicReader] Calculated bufferSizeInSamples is 0. TotalSampleFrames: {totalSampleFrames}, TargetPoints: {targetPoints}, Channels: {channels}, SamplesPerFrameToProcessPerPoint: {samplesPerFrameToProcessPerPoint}. Cannot generate.");
            return false;
        }

        return true;
    }

    internal static List<WaveformPoint> ProcessAudioStream(AudioFileReader reader, int targetPoints, int samplesPerFrameToProcessPerPoint, int bufferSizeInSamples, string filePath)
    {
        List<WaveformPoint> points = [];
        float[] buffer = new float[bufferSizeInSamples]; // Corrected buffer initialization
        double currentX = 0;
        double xIncrement = 1.0 / targetPoints;
        int pointsGeneratedCount = 0;

        Debug.WriteLine($"[WaveformProcessingLogicReader] Processing \"{Path.GetFileName(filePath)}\": TargetPoints: {targetPoints}, SamplesPerFrameToProcessPerPoint: {samplesPerFrameToProcessPerPoint}, BufferSizeInFloats: {bufferSizeInSamples}");

        for (int i = 0; i < targetPoints; i++)
        {
            float maxPeakInChunk = 0f;
            int samplesReadFromAudioFile = reader.Read(buffer, 0, buffer.Length);

            if (samplesReadFromAudioFile == 0)
            {
                Debug.WriteLine($"[WaveformProcessingLogicReader] Read 0 samples at waveform point index {i} (target: {targetPoints}) for \"{Path.GetFileName(filePath)}\". End of audio stream reached.");
                break;
            }

            for (int n = 0; n < samplesReadFromAudioFile; n++)
            {
                maxPeakInChunk = float.Max(maxPeakInChunk, float.Abs(buffer[n]));
            }

            points.Add(new WaveformPoint(currentX, maxPeakInChunk));
            pointsGeneratedCount++;

            if (i < 5 || (i > 0 && i % Math.Max(1, (targetPoints / 10)) == 0) || i == targetPoints - 1) // Corrected int.Max to Math.Max
            {
                Debug.WriteLine($"[WaveformProcessingLogicReader] Point {i}: X={currentX:F3}, Calculated YPeak={maxPeakInChunk:F4}, SamplesInThisChunk={samplesReadFromAudioFile}");
            }

            currentX += xIncrement;

            if (currentX > 1.0)
            {
                currentX = 1.0;
            }
        }

        Debug.WriteLine($"[WaveformProcessingLogicReader] Loop finished for \"{Path.GetFileName(filePath)}\". Total waveform points generated: {pointsGeneratedCount}. (Target was {targetPoints})");
        return points;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\WaveFormService.cs">
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

namespace Sonorize.Services;

public record WaveformPoint(double X, double YPeak);

public class WaveformService
{
    private readonly Dictionary<string, List<WaveformPoint>> _waveformCache = new();
    private readonly NAudioWaveformPointGenerator _pointGenerator;

    public WaveformService()
    {
        _pointGenerator = new();
    }

    public async Task<List<WaveformPoint>> GetWaveformAsync(string filePath, int targetPoints)
    {
        if (string.IsNullOrEmpty(filePath) || targetPoints <= 0)
        {
            Debug.WriteLine($"[WaveformService] Invalid input: filePath is null/empty or targetPoints <= 0. File: '{filePath}', Points: {targetPoints}");
            return [];
        }

        if (_waveformCache.TryGetValue(filePath, out var cachedData))
        {
            Debug.WriteLine($"[WaveformService] Returning cached waveform for \"{Path.GetFileName(filePath)}\". Points: {cachedData.Count}");
            return cachedData;
        }

        Debug.WriteLine($"[WaveformService] Requesting waveform generation for \"{Path.GetFileName(filePath)}\". Target points: {targetPoints}.");

        List<WaveformPoint> points = await Task.Run(() 
            => _pointGenerator.Generate(filePath, targetPoints));

        if (points.Count != 0)
        {
            _waveformCache[filePath] = points;
            Debug.WriteLine($"[WaveformService] Waveform generated and cached for \"{Path.GetFileName(filePath)}\", {points.Count} points. First point YPeak: {points[0].YPeak:F4}. Approx mid point YPeak: {points[points.Count / 2].YPeak:F4}. Last point YPeak: {points.Last().YPeak:F4}");
        }
        else
        {
            Debug.WriteLine($"[WaveformService] No points generated for \"{Path.GetFileName(filePath)}\". It might be too short, silent, or an issue with reading audio data.");
        }

        return points;
    }

    public void ClearCache()
    {
        _waveformCache.Clear();
        Debug.WriteLine("[WaveformService] Cache cleared.");
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\UI\ThemeResourceApplicator.cs">
using System.Diagnostics;
using Avalonia;
using Avalonia.Media;
using Sonorize.Models;
using Sonorize.Extensions; // For ChangeLightness and WithAlpha

namespace Sonorize.UI;

public static class ThemeResourceApplicator
{
    public static void ApplyCustomColorsToResources(Application app, ThemeColors themeColors)
    {
        System.ArgumentNullException.ThrowIfNull(app);
        System.ArgumentNullException.ThrowIfNull(themeColors);

        if (themeColors.B_AccentColor is ISolidColorBrush accentSolidBrush &&
            themeColors.B_AccentForeground is ISolidColorBrush accentForegroundSolidBrush)
        {
            Color accentColor = accentSolidBrush.Color;
            Color accentForegroundColor = accentForegroundSolidBrush.Color;
            Debug.WriteLine($"[ThemeResourceApplicator] Overriding FluentTheme accent resources. Accent: {accentColor}, AccentFG: {accentForegroundColor}");

            app.Resources["SystemAccentColor"] = accentColor;
            app.Resources["SystemAccentColorLight1"] = accentColor.ChangeLightness(0.15);
            app.Resources["SystemAccentColorLight2"] = accentColor.ChangeLightness(0.30);
            app.Resources["SystemAccentColorLight3"] = accentColor.ChangeLightness(0.45);
            app.Resources["SystemAccentColorDark1"] = accentColor.ChangeLightness(-0.15);
            app.Resources["SystemAccentColorDark2"] = accentColor.ChangeLightness(-0.30);
            app.Resources["SystemAccentColorDark3"] = accentColor.ChangeLightness(-0.45);
            app.Resources["AccentFillColorDefaultBrush"] = new SolidColorBrush(accentColor);
            app.Resources["AccentFillColorSecondaryBrush"] = new SolidColorBrush(accentColor.ChangeLightness(0.15).WithAlpha(204));
            app.Resources["AccentFillColorTertiaryBrush"] = new SolidColorBrush(accentColor.ChangeLightness(0.30).WithAlpha(153));
            app.Resources["AccentFillColorDisabledBrush"] = new SolidColorBrush(accentColor.WithAlpha(51));
            app.Resources["AccentFillColorSelectedTextBackgroundBrush"] = new SolidColorBrush(accentColor);
            app.Resources["TextOnAccentFillColorPrimaryBrush"] = new SolidColorBrush(accentForegroundColor);
            app.Resources["TextOnAccentFillColorSecondaryBrush"] = new SolidColorBrush(accentForegroundColor.WithAlpha(178));
            app.Resources["TextOnAccentFillColorDisabledBrush"] = new SolidColorBrush(accentForegroundColor.WithAlpha(127));
            app.Resources["AccentControlBackgroundBrush"] = new SolidColorBrush(accentColor);
        }
        else
        {
            Debug.WriteLine("[ThemeResourceApplicator] Warning: Custom theme AccentColor or AccentForeground is not a SolidColorBrush. Cannot fully override Fluent accent system.");
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Utils\AlbumArtistTupleComparer.cs">
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

namespace Sonorize.Utils;

public class AlbumArtistTupleComparer : IEqualityComparer<(string Album, string Artist)>
{
    public bool Equals((string Album, string Artist) x, (string Album, string Artist) y)
    {
        return string.Equals(x.Album, y.Album, StringComparison.OrdinalIgnoreCase) &&
               string.Equals(x.Artist, y.Artist, StringComparison.OrdinalIgnoreCase);
    }

    public int GetHashCode([DisallowNull] (string Album, string Artist) obj)
    {
        int albumHashCode = obj.Album?.ToLowerInvariant().GetHashCode() ?? 0;
        int artistHashCode = obj.Artist?.ToLowerInvariant().GetHashCode() ?? 0;
        return HashCode.Combine(albumHashCode, artistHashCode);
    }

    public static readonly AlbumArtistTupleComparer Instance = new();
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\AdvancedPanelViewModel.cs">
using System.ComponentModel;
using System.Linq;
using System.Windows.Input;
using Sonorize.Services; // Required for PlaybackService if directly interacting, or PlaybackViewModel

namespace Sonorize.ViewModels;

public class AdvancedPanelViewModel : ViewModelBase
{
    private readonly PlaybackViewModel _playbackViewModel;
    private readonly LibraryViewModel _libraryViewModel;

    private bool _isVisible;
    public bool IsVisible
    {
        get => _isVisible;
        set
        {
            if (SetProperty(ref _isVisible, value))
            {
                OnVisibilityChanged();
            }
        }
    }

    public ICommand ToggleVisibilityCommand { get; }

    public AdvancedPanelViewModel(PlaybackViewModel playbackViewModel, LibraryViewModel libraryViewModel)
    {
        _playbackViewModel = playbackViewModel ?? throw new System.ArgumentNullException(nameof(playbackViewModel));
        _libraryViewModel = libraryViewModel ?? throw new System.ArgumentNullException(nameof(libraryViewModel));

        ToggleVisibilityCommand = new RelayCommand(
            _ => IsVisible = !IsVisible,
            CanToggleVisibility
        );

        _playbackViewModel.PropertyChanged += OnDependentViewModelPropertyChanged;
        _libraryViewModel.PropertyChanged += OnDependentViewModelPropertyChanged;
        // Listen to IsWaveformLoading on the new WaveformDisplayViewModel
        _playbackViewModel.WaveformDisplay.PropertyChanged += WaveformDisplay_PropertyChanged;
    }

    private void WaveformDisplay_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName == nameof(WaveformDisplayViewModel.IsWaveformLoading))
        {
            // If any command in AdvancedPanelViewModel depends on IsWaveformLoading, update it here.
            // For now, ToggleVisibilityCommand might not directly, but if it did:
            (ToggleVisibilityCommand as RelayCommand)?.RaiseCanExecuteChanged();
        }
    }

    private bool CanToggleVisibility(object? parameter)
    {
        // Visibility can be toggled if a song is playing and library is not loading.
        // Waveform loading state might also influence this if we want to prevent toggling during load.
        return _playbackViewModel.HasCurrentSong &&
               !_libraryViewModel.IsLoadingLibrary &&
               !_playbackViewModel.WaveformDisplay.IsWaveformLoading; // Prevent toggling if waveform is loading
    }

    private void OnVisibilityChanged()
    {
        (ToggleVisibilityCommand as RelayCommand)?.RaiseCanExecuteChanged();

        // Inform the WaveformDisplayViewModel about the panel's visibility
        _playbackViewModel.WaveformDisplay.SetPanelVisibility(IsVisible);
    }

    private void OnDependentViewModelPropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName == nameof(PlaybackViewModel.HasCurrentSong) ||
            e.PropertyName == nameof(LibraryViewModel.IsLoadingLibrary))
        {
            (ToggleVisibilityCommand as RelayCommand)?.RaiseCanExecuteChanged();
        }
    }

    public void Dispose()
    {
        _playbackViewModel.PropertyChanged -= OnDependentViewModelPropertyChanged;
        _libraryViewModel.PropertyChanged -= OnDependentViewModelPropertyChanged;
        if (_playbackViewModel?.WaveformDisplay is not null)
        {
            _playbackViewModel.WaveformDisplay.PropertyChanged -= WaveformDisplay_PropertyChanged;
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\AlbumViewModel.cs">
using System.Collections.Generic; // For List
using Avalonia.Media.Imaging;
// Removed System.Collections.ObjectModel as List is sufficient here and ViewModelBase handles INPC

namespace Sonorize.ViewModels;

public class AlbumViewModel : ViewModelBase
{
    public string? Title { get; set; }
    public string? Artist { get; set; }
    public int SongCount { get; set; }
    public List<Bitmap?> SongThumbnailsForGrid
    {
        get;
        // Setter might be used by LibraryVM during initialization
        set => SetProperty(ref field, value);
    } = new List<Bitmap?>(new Bitmap?[4]);

    public Bitmap? RepresentativeThumbnail
    {
        get;
        set => SetProperty(ref field, value);
    }

    public string DisplayText => $"{Title} - {Artist}";
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\ApplicationWorkflowManager.cs">
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Avalonia.Controls; // For Window
using Sonorize.Models;
using Sonorize.Services;
using Sonorize.ViewModels.Status; // For StatusBarTextProvider

namespace Sonorize.ViewModels;

public class ApplicationWorkflowManager : IDisposable
{
    private readonly SettingsService _settingsService;
    private readonly ScrobblingService _scrobblingService;
    private readonly ThemeColors _currentTheme;
    private readonly LibraryViewModel _libraryViewModel;
    private readonly PlaybackViewModel _playbackViewModel;
    private readonly PlaybackService _playbackService;

    private readonly NextTrackSelectorService _nextTrackSelectorService;
    // Removed: private readonly StatusBarTextProvider _statusBarTextProvider;
    private readonly SettingsChangeProcessorService _settingsChangeProcessorService;
    private readonly PlaybackFlowManagerService _playbackFlowManagerService;
    private readonly ApplicationInteractionService _applicationInteractionService;
    private readonly LibraryPlaybackLinkService _libraryPlaybackLinkService;
    // Removed: private readonly SongMetadataService _songMetadataService; 


    private readonly Random _shuffleRandom = new();

    public ApplicationWorkflowManager(
        SettingsService settingsService,
        ScrobblingService scrobblingService,
        ThemeColors currentTheme,
        LibraryViewModel libraryViewModel,
        PlaybackViewModel playbackViewModel,
        PlaybackService playbackService,
        LoopDataService loopDataService)
    {
        _settingsService = settingsService ?? throw new ArgumentNullException(nameof(settingsService));
        _scrobblingService = scrobblingService ?? throw new ArgumentNullException(nameof(scrobblingService));
        _currentTheme = currentTheme ?? throw new ArgumentNullException(nameof(currentTheme));
        _libraryViewModel = libraryViewModel ?? throw new ArgumentNullException(nameof(libraryViewModel));
        _playbackViewModel = playbackViewModel ?? throw new ArgumentNullException(nameof(playbackViewModel));
        _playbackService = playbackService ?? throw new ArgumentNullException(nameof(playbackService));
        // Removed: _songMetadataService = songMetadataService ?? throw new ArgumentNullException(nameof(songMetadataService)); 

        // Create internal services
        _nextTrackSelectorService = new NextTrackSelectorService(_shuffleRandom);
        // Removed: _statusBarTextProvider = new StatusBarTextProvider(_playbackViewModel, null!, _libraryViewModel); // Placeholder

        _settingsChangeProcessorService = new SettingsChangeProcessorService(_libraryViewModel, _scrobblingService);
        _playbackFlowManagerService = new PlaybackFlowManagerService(_libraryViewModel, _playbackViewModel, _playbackService, _nextTrackSelectorService);

        _applicationInteractionService = new ApplicationInteractionService(
            _settingsService,
            _settingsChangeProcessorService,
            _currentTheme); // Removed _songMetadataService from instantiation

        _libraryPlaybackLinkService = new LibraryPlaybackLinkService(_libraryViewModel, _playbackService, _playbackViewModel);
    }

    public async Task<(List<string> statusMessages, bool settingsChanged)> HandleOpenSettingsDialogAsync(Window owner)
    {
        return await _applicationInteractionService.HandleOpenSettingsDialogAsync(owner);
    }

    public async Task<(bool directoryAddedAndLibraryRefreshNeeded, string statusMessage)> HandleAddMusicDirectoryAsync(Window owner)
    {
        return await _applicationInteractionService.HandleAddMusicDirectoryAsync(owner);
    }

    public void HandlePlaybackEndedNaturally()
    {
        _playbackFlowManagerService.HandlePlaybackEndedNaturally();
    }

    public string GetCurrentStatusText(LoopEditorViewModel loopEditorViewModel)
    {
        return StatusBarTextProvider.GetCurrentStatusText(_playbackViewModel, loopEditorViewModel, _libraryViewModel);
    }

    public void Dispose()
    {
        _libraryPlaybackLinkService?.Dispose();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\ArtistViewModel.cs">
using System.Collections.Generic;
using Avalonia.Media.Imaging;

namespace Sonorize.ViewModels;

public class ArtistViewModel : ViewModelBase // Inherit from ViewModelBase
{
    public string? Name { get; set; } // Name can remain simple if not changed after creation
    public int SongCount { get; set; }

    public List<Bitmap?> SongThumbnailsForGrid
    {
        get;
        set => SetProperty(ref field, value);
    } = new List<Bitmap?>(new Bitmap?[4]);

    private Bitmap? _thumbnail;
    public Bitmap? Thumbnail
    {
        get => _thumbnail;
        set => SetProperty(ref _thumbnail, value); // Use SetProperty for INotifyPropertyChanged
    }
    // You could add more properties later, like SongCount or AlbumCount
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\AsyncWaveformLoader.cs">
using System;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;
using Avalonia.Threading;
using Sonorize.Models;
using Sonorize.Services;

namespace Sonorize.ViewModels;

internal class AsyncWaveformLoader : ViewModelBase
{
    private readonly WaveformService _waveformService;
    private Song? _songCurrentlyLoadingOrLoaded; // Tracks the song for which the current/last load was initiated

    public ObservableCollection<WaveformPoint> WaveformRenderData { get; } = new();

    private bool _isLoading;
    public bool IsLoading
    {
        get => _isLoading;
        private set => SetProperty(ref _isLoading, value);
    }

    public AsyncWaveformLoader(WaveformService waveformService)
    {
        _waveformService = waveformService ?? throw new ArgumentNullException(nameof(waveformService));
    }

    public async Task RequestLoadAsync(Song songToLoad, int targetPoints, Song? currentDisplaySongContext, bool isPanelVisibleContext)
    {
        if (string.IsNullOrEmpty(songToLoad.FilePath))
        {
            Debug.WriteLine($"[AsyncWaveformLoader] Load request skipped: Invalid path for song '{songToLoad.Title}'.");
            if (_songCurrentlyLoadingOrLoaded == songToLoad) // If this invalid song was being "loaded"
            {
                IsLoading = false;
                WaveformRenderData.Clear();
                _songCurrentlyLoadingOrLoaded = null;
            }
            return;
        }

        // If already loading for this exact song instance, don't restart.
        if (IsLoading && _songCurrentlyLoadingOrLoaded == songToLoad)
        {
            Debug.WriteLine($"[AsyncWaveformLoader] Already loading waveform for '{songToLoad.Title}'. Skipping redundant load request.");
            return;
        }

        _songCurrentlyLoadingOrLoaded = songToLoad; // Set the song context for this load operation
        IsLoading = true;
        WaveformRenderData.Clear(); // Clear previous data before loading new

        try
        {
            Debug.WriteLine($"[AsyncWaveformLoader] Requesting waveform from service for: {songToLoad.Title}");
            var points = await _waveformService.GetWaveformAsync(songToLoad.FilePath, targetPoints);

            // Critical check: Ensure the context for display (current song and panel visibility)
            // still matches the song we just loaded data for.
            if (currentDisplaySongContext == songToLoad && isPanelVisibleContext)
            {
                await Dispatcher.UIThread.InvokeAsync(() =>
                {
                    WaveformRenderData.Clear(); // Ensure it's empty before adding new points
                    foreach (var p in points)
                    {
                        WaveformRenderData.Add(p);
                    }
                    Debug.WriteLine($"[AsyncWaveformLoader] Waveform loaded and UI updated for: {songToLoad.Title}, {points.Count} points.");
                });
            }
            else
            {
                Debug.WriteLine($"[AsyncWaveformLoader] Waveform for '{songToLoad.Title}' loaded, but display context changed. Current display song: '{currentDisplaySongContext?.Title}', panel visible: {isPanelVisibleContext}. Discarding result.");
                // If context changed, ensure data for the (now irrelevant) loaded song is cleared if it wasn't already.
                // This path implies another load might be in progress or needed for the new context.
                if (WaveformRenderData.Any()) // If by some chance it got populated
                {
                    await Dispatcher.UIThread.InvokeAsync(() => WaveformRenderData.Clear());
                }
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[AsyncWaveformLoader] CRITICAL Error loading waveform for '{songToLoad.Title}': {ex.Message}");
            await Dispatcher.UIThread.InvokeAsync(() =>
            {
                WaveformRenderData.Clear(); // Clear on error
            });
        }
        finally
        {
            // Set IsLoading to false only if this load operation was for the song that's still
            // considered the "active" one for the loader, or if no song is active.
            // This prevents a completed load for an old song from incorrectly marking IsLoading as false
            // if a new load for a different song has already started.
            if (_songCurrentlyLoadingOrLoaded == songToLoad || currentDisplaySongContext == null)
            {
                IsLoading = false;
            }
            else
            {
                Debug.WriteLine($"[AsyncWaveformLoader] Load for '{songToLoad.Title}' finished, but a new song '{_songCurrentlyLoadingOrLoaded?.Title}' might be targeted. IsLoading state determined by newer operations.");
            }
        }
    }

    public void ClearDataAndState()
    {
        WaveformRenderData.Clear();
        IsLoading = false;
        _songCurrentlyLoadingOrLoaded = null;
        Debug.WriteLine("[AsyncWaveformLoader] Data and loading state cleared.");
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\GridViewImageType.cs">
namespace Sonorize.ViewModels
{
    public enum GridViewImageType
    {
        Single,
        Composite
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\LastfmSettingsViewModel.cs">
using Sonorize.Models; // Required for AppSettings

namespace Sonorize.ViewModels;

public class LastfmSettingsViewModel : ViewModelBase
{
    public bool LastfmScrobblingEnabled
    {
        get;

        set
        {
            SetProperty(ref field, value);
        }
    }
    
    public string? LastfmUsername
    {
        get;

        set
        {
            SetProperty(ref field, value);
        }
    }
    
    public string? LastfmPassword
    {
        get;

        set
        {
            SetProperty(ref field, value);
        }
    }
    
    public int ScrobbleThresholdPercentage
    {
        get;

        set
        {
            SetProperty(ref field, value);
        }
    }
    
    public int ScrobbleThresholdAbsoluteSeconds
    {
        get;

        set
        {
            SetProperty(ref field, value);
        }
    }

    public LastfmSettingsViewModel() { }

    public void LoadFromSettings(AppSettings settings)
    {
        LastfmScrobblingEnabled = settings.LastfmScrobblingEnabled;
        LastfmUsername = settings.LastfmUsername;
        LastfmPassword = settings.LastfmPassword;
        ScrobbleThresholdPercentage = settings.ScrobbleThresholdPercentage;
        ScrobbleThresholdAbsoluteSeconds = settings.ScrobbleThresholdAbsoluteSeconds;
    }

    public void UpdateAppSettings(AppSettings settings)
    {
        settings.LastfmScrobblingEnabled = LastfmScrobblingEnabled;
        settings.LastfmUsername = LastfmUsername;
        
        if (LastfmPassword is not null)
        {
            settings.LastfmPassword = LastfmPassword;
        }
        
        settings.ScrobbleThresholdPercentage = ScrobbleThresholdPercentage;
        settings.ScrobbleThresholdAbsoluteSeconds = ScrobbleThresholdAbsoluteSeconds;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\LibraryViewModel.cs">
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Threading.Tasks;
using System.Windows.Input;
using Avalonia.Threading;
using Sonorize.Models;
using Sonorize.Services;
using Sonorize.ViewModels.LibraryManagement;

namespace Sonorize.ViewModels;

public class LibraryViewModel : ViewModelBase, IDisposable
{
    private readonly SettingsService _settingsService;
    private readonly MusicLibraryService _musicLibraryService;
    private readonly MainWindowViewModel _parentViewModel;
    private readonly LibraryDisplayModeService _displayModeService;
    private readonly TrackNavigationManager _trackNavigationManager;
    private readonly LibraryComponentProvider _components;
    private readonly LibraryLoadProcess _libraryLoadProcess;

    public LibraryDisplayModeService LibraryDisplayModeService => _displayModeService;
    public LibraryGroupingsViewModel Groupings => _components.Groupings;
    public ObservableCollection<Song> FilteredSongs => _components.SongList.FilteredSongs;
    public LibraryFilterStateManager FilterState => _components.FilterState;

    public ICommand SetDisplayModeCommand => _displayModeService.SetDisplayModeCommand;
    public ICommand PreviousTrackCommand => _trackNavigationManager.PreviousTrackCommand;
    public ICommand NextTrackCommand => _trackNavigationManager.NextTrackCommand;
    public ICommand EditSongMetadataCommand { get; }

    public SongDisplayMode LibraryViewMode => _displayModeService.LibraryViewMode;
    public SongDisplayMode ArtistViewMode => _displayModeService.ArtistViewMode;
    public SongDisplayMode AlbumViewMode => _displayModeService.AlbumViewMode;
    public SongDisplayMode PlaylistViewMode => _displayModeService.PlaylistViewMode;

    public bool IsLoadingLibrary
    {
        get;

        private set
        {
            if (!SetProperty(ref field, value))
            {
                return;
            }

            RaiseLibraryCommandsCanExecuteChanged();
        }
    } = false;

    public string LibraryStatusText
    {
        get;

        private set
        {
            SetProperty(ref field, value);
        }
    } = "";

    public Song? SelectedSong
    {
        get => _components.SongList.SelectedSong;
        set
        {
            if (_components.SongList.SelectedSong == value)
            {
                return;
            }

            _components.SongList.SelectedSong = value;
            OnPropertyChanged();
            _trackNavigationManager.UpdateSelectedSong(value);
            (EditSongMetadataCommand as RelayCommand)?.RaiseCanExecuteChanged();

            Debug.WriteLine($"[LibraryVM] SelectedSong changed to: {value?.Title ?? "null"} (via SongListManager)");
        }
    }

    public LibraryViewModel(
        MainWindowViewModel parentViewModel,
        SettingsService settingsService,
        MusicLibraryService musicLibraryService,
        LoopDataService loopDataService,
        LibraryDisplayModeService displayModeService)
    {
        _parentViewModel = parentViewModel ?? throw new ArgumentNullException(nameof(parentViewModel));
        _settingsService = settingsService;
        _musicLibraryService = musicLibraryService;
        _displayModeService = displayModeService ?? throw new ArgumentNullException(nameof(displayModeService));

        _components = new LibraryComponentProvider(musicLibraryService, settingsService);
        _trackNavigationManager = new TrackNavigationManager(_components.SongList.FilteredSongs);

        // Instantiate the new LibraryLoadProcess
        _libraryLoadProcess = new LibraryLoadProcess(
            _components,
            ApplyFilter, // Pass private method as delegate
            UpdateStatusBarText, // Pass private method as delegate
            isLoading => IsLoadingLibrary = isLoading, // Lambda to set property
            status => LibraryStatusText = status,       // Lambda to set property
            Dispatcher.UIThread                         // Pass dispatcher
        );

        // Subscribe to events from components provided by _components
        _components.FilterState.FilterCriteriaChanged += (s, e) => ApplyFilter();
        _components.FilterState.RequestTabSwitchToLibrary += (s, e) => _parentViewModel.ActiveTabIndex = 0;
        _components.SongList.PropertyChanged += SongListManager_PropertyChanged;

        _displayModeService.PropertyChanged += DisplayModeService_PropertyChanged;
        _musicLibraryService.SongThumbnailUpdated += MusicLibraryService_SongThumbnailUpdated;

        EditSongMetadataCommand = new RelayCommand(ExecuteEditSongMetadata, CanExecuteEditSongMetadata);

        UpdateStatusBarText();
    }

    private void SongListManager_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName == nameof(SongListManager.SelectedSong))
        {
            OnPropertyChanged(nameof(SelectedSong));
            _trackNavigationManager.UpdateSelectedSong(_components.SongList.SelectedSong);
            (EditSongMetadataCommand as RelayCommand)?.RaiseCanExecuteChanged();
            Debug.WriteLine($"[LibraryVM] SongListManager.SelectedSong changed to: {_components.SongList.SelectedSong?.Title ?? "null"}. Updated own SelectedSong.");
        }
        else if (e.PropertyName == nameof(SongListManager.FilteredSongs))
        {
            OnPropertyChanged(nameof(FilteredSongs));
        }
    }

    private void DisplayModeService_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        switch (e.PropertyName)
        {
            case nameof(LibraryDisplayModeService.LibraryViewMode):
                OnPropertyChanged(nameof(LibraryViewMode));
                break;
            case nameof(LibraryDisplayModeService.ArtistViewMode):
                OnPropertyChanged(nameof(ArtistViewMode));
                break;
            case nameof(LibraryDisplayModeService.AlbumViewMode):
                OnPropertyChanged(nameof(AlbumViewMode));
                break;
            case nameof(LibraryDisplayModeService.PlaylistViewMode):
                OnPropertyChanged(nameof(PlaylistViewMode));
                break;
        }
    }

    private async void MusicLibraryService_SongThumbnailUpdated(Song updatedSong)
    {
        await Dispatcher.UIThread.InvokeAsync(() =>
        {
            _components.Groupings.HandleSongThumbnailUpdate(updatedSong, _components.SongList.GetAllSongsReadOnly());
        });
    }

    public async Task LoadLibraryAsync()
    {
        if (IsLoadingLibrary)
        {
            return;
        }
        // Delegate the loading process to the new class
        await _libraryLoadProcess.ExecuteLoadAsync();
    }

    public void RefreshAutoPlaylists()
    {
        if (IsLoadingLibrary)
        {
            return;
        }

        Debug.WriteLine("[LibraryVM] RefreshAutoPlaylists called.");
        _components.AutoPlaylistManager.RefreshAutoPlaylists();
    }

    private void ApplyFilter()
    {
        _components.SongList.ApplyFilter(
            _components.FilterState.SearchQuery,
            _components.FilterState.SelectedArtist,
            _components.FilterState.SelectedAlbum,
            _components.FilterState.SelectedPlaylist);

        _trackNavigationManager.UpdateSelectedSong(_components.SongList.SelectedSong);
        UpdateStatusBarText();
    }

    public void UpdateStatusBarText()
    {
        if (IsLoadingLibrary)
        {
            return;
        }

        LibraryStatusText = _components.StatusTextGenerator.GenerateStatusText(
            IsLoadingLibrary,
            _components.SongList.AllSongsCount,
            FilteredSongs.Count,
            _components.FilterState.SelectedArtist,
            _components.FilterState.SelectedAlbum,
            _components.FilterState.SelectedPlaylist,
            _components.FilterState.SearchQuery,
            _settingsService
        );
    }

    private void ExecuteEditSongMetadata(object? parameter)
    {
        if (parameter is not Song song || !_parentViewModel.OpenEditSongMetadataDialogCommand.CanExecute(song))
        {
            Debug.WriteLine($"[LibraryVM] Edit metadata requested but parameter is not a Song or parent command cannot execute.");
            return;
        }

        Debug.WriteLine($"[LibraryVM] Delegating Edit metadata for: {song.Title} to MainWindowViewModel.");
        _parentViewModel.OpenEditSongMetadataDialogCommand.Execute(song);
    }

    private bool CanExecuteEditSongMetadata(object? parameter)
    {
        return parameter is Song
            && _parentViewModel.OpenEditSongMetadataDialogCommand.CanExecute(parameter);
    }


    public void RaiseLibraryCommandsCanExecuteChanged()
    {
        (EditSongMetadataCommand as RelayCommand)?.RaiseCanExecuteChanged();
    }

    public void Dispose()
    {
        if (_musicLibraryService is not null)
        {
            _musicLibraryService.SongThumbnailUpdated -= MusicLibraryService_SongThumbnailUpdated;
        }

        if (_displayModeService is not null)
        {
            _displayModeService.PropertyChanged -= DisplayModeService_PropertyChanged;
        }

        if (_components?.FilterState is not null)
        {
            _components.FilterState.FilterCriteriaChanged -= (s, e) => ApplyFilter();
            _components.FilterState.RequestTabSwitchToLibrary -= (s, e) => _parentViewModel.ActiveTabIndex = 0;
        }

        if (_components?.SongList is not null)
        {
            _components.SongList.PropertyChanged -= SongListManager_PropertyChanged;
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\PlaybackEffectsViewModel.cs">
using System;
using System.Diagnostics;
using Sonorize.Services; // Required for PlaybackService

namespace Sonorize.ViewModels;

public class PlaybackEffectsViewModel : ViewModelBase
{
    private readonly PlaybackService _playbackService;

    public double PlaybackSpeed
    {
        get;
        set
        {
            value = Math.Clamp(value, 0.5, 2.0);
            if (SetProperty(ref field, value))
            {
                _playbackService.PlaybackRate = (float)value;
                OnPropertyChanged(nameof(PlaybackSpeedDisplay));
                Debug.WriteLine($"[PlaybackEffectsVM] PlaybackSpeed set to: {value}");
            }
        }
    } = 1.0;

    public string PlaybackSpeedDisplay => $"{PlaybackSpeed:F2}x";

    public double PlaybackPitch
    {
        get;
        set
        {
            // Round to nearest 0.5
            double roundedValue = Math.Round(value * 2, MidpointRounding.AwayFromZero) / 2.0;
            roundedValue = Math.Clamp(roundedValue, -4.0, 4.0); // Clamp after rounding

            if (SetProperty(ref field, roundedValue))
            {
                _playbackService.PitchSemitones = (float)roundedValue;
                OnPropertyChanged(nameof(PlaybackPitchDisplay));
                Debug.WriteLine($"[PlaybackEffectsVM] PlaybackPitch set to: {roundedValue}");
            }
        }
    } = 0.0;
    
    public string PlaybackPitchDisplay => $"{PlaybackPitch:+0.0;-0.0;0} st";

    public PlaybackEffectsViewModel(PlaybackService playbackService)
    {
        _playbackService = playbackService ?? throw new ArgumentNullException(nameof(playbackService));
        // Initialize with current service values if necessary, or assume service defaults are fine.
        // For now, assume ViewModel defaults (1.0 speed, 0.0 pitch) are fine and will set service on first change.
        // Or, sync from service:
        // _playbackSpeed = _playbackService.PlaybackRate;
        // _playbackPitch = _playbackService.PitchSemitones;
    }

    // If PlaybackService can change these values externally and this VM needs to reflect that,
    // then PlaybackEffectsViewModel would need to subscribe to PlaybackService.PropertyChanged.
    // For now, assuming changes are driven from this VM.
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\PlaybackModeViewModel.cs">
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Windows.Input; // Required for ICommand

namespace Sonorize.ViewModels;

public class PlaybackModeViewModel : ViewModelBase
{
    private readonly PlaybackViewModel _parentPlaybackViewModel;

    public bool ShuffleEnabled
    {
        get;
        set
        {
            if (!SetProperty(ref field, value))
            {
                return;
            }

            Debug.WriteLine($"[PlaybackModeVM] ShuffleEnabled set to: {value}");
            // Parent PlaybackViewModel might need to know if preferences are saved here
            // or if this directly influences something in PlaybackService.
            // For now, it's a UI state.
            RaiseCommandCanExecuteChanged();
        }
    } = false;

    public RepeatMode RepeatMode
    {
        get;
        set
        {
            if (!SetProperty(ref field, value))
            {
                return;
            }

            Debug.WriteLine($"[PlaybackModeVM] RepeatMode set to: {value}");
            OnPropertyChanged(nameof(IsRepeatOne));
            OnPropertyChanged(nameof(IsRepeatAll));
            OnPropertyChanged(nameof(IsRepeatActive)); // Notify composite state change
            RaiseCommandCanExecuteChanged();
        }
    } = RepeatMode.PlayOnce;

    // Helper properties for UI bindings
    public bool IsRepeatOne { get => RepeatMode == RepeatMode.RepeatOne; set { if (value) RepeatMode = RepeatMode.RepeatOne; else if (RepeatMode == RepeatMode.RepeatOne) RepeatMode = RepeatMode.PlayOnce; } }
    public bool IsRepeatAll { get => RepeatMode == RepeatMode.RepeatAll; set { if (value) RepeatMode = RepeatMode.RepeatAll; else if (RepeatMode == RepeatMode.RepeatAll) RepeatMode = RepeatMode.PlayOnce; } }
    public bool IsRepeatActive => RepeatMode != RepeatMode.None;

    public ICommand ToggleShuffleCommand { get; }
    public ICommand CycleRepeatModeCommand { get; }

    public PlaybackModeViewModel(PlaybackViewModel parentPlaybackViewModel)
    {
        _parentPlaybackViewModel = parentPlaybackViewModel ?? throw new ArgumentNullException(nameof(parentPlaybackViewModel));
        _parentPlaybackViewModel.PropertyChanged += ParentPlaybackViewModel_PropertyChanged;

        ToggleShuffleCommand = new RelayCommand(
            _ => ShuffleEnabled = !ShuffleEnabled,
            _ => _parentPlaybackViewModel.HasCurrentSong
        );

        CycleRepeatModeCommand = new RelayCommand(
            _ => CycleRepeatModeInternal(),
            _ => _parentPlaybackViewModel.HasCurrentSong
        );
    }

    private void ParentPlaybackViewModel_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName != nameof(PlaybackViewModel.HasCurrentSong))
        {
            return;
        }

        RaiseCommandCanExecuteChanged();
    }

    private void CycleRepeatModeInternal()
    {
        RepeatMode = RepeatMode switch
        {
            RepeatMode.None => RepeatMode.PlayOnce,
            RepeatMode.PlayOnce => RepeatMode.RepeatOne,
            RepeatMode.RepeatOne => RepeatMode.RepeatAll,
            RepeatMode.RepeatAll => RepeatMode.None,
            _ => RepeatMode.None // Should not happen
        };
    }

    public void RaiseCommandCanExecuteChanged()
    {
        (ToggleShuffleCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (CycleRepeatModeCommand as RelayCommand)?.RaiseCanExecuteChanged();
    }

    public void Dispose()
    {
        if (_parentPlaybackViewModel == null)
        {
            return;
        }

        _parentPlaybackViewModel.PropertyChanged -= ParentPlaybackViewModel_PropertyChanged;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\PlaybackViewModel.cs">
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Windows.Input;
using Avalonia.Threading;
using Sonorize.Models;
using Sonorize.Services; // This using directive makes PlaybackStateStatus from the Service available

namespace Sonorize.ViewModels;

public enum RepeatMode { None, PlayOnce, RepeatOne, RepeatAll }

public class PlaybackViewModel : ViewModelBase, IDisposable
{
    private readonly PlaybackService _playbackService;
    private bool _isUserDraggingSlider;

    public WaveformDisplayViewModel WaveformDisplay { get; }
    public PlaybackModeViewModel ModeControls { get; }
    public PlaybackEffectsViewModel EffectsControls { get; }

    // Properties directly from PlaybackService or managed by this ViewModel
    public Song? CurrentSong => _playbackService.CurrentSong;
    public bool HasCurrentSong => _playbackService.CurrentSong is not null;
    public TimeSpan CurrentPosition => _playbackService.CurrentPosition;
    public double CurrentPositionSeconds => _playbackService.CurrentPosition.TotalSeconds;
    public TimeSpan CurrentSongDuration => _playbackService.CurrentSongDuration;
    public double CurrentSongDurationSeconds => _playbackService.CurrentSongDurationSeconds;
    public PlaybackStateStatus CurrentPlaybackStatus => _playbackService.CurrentPlaybackStatus;
    public bool IsPlaying => _playbackService.IsPlaying;

    private double _sliderPosition;
    public double SliderPosition
    {
        get => _sliderPosition;
        set
        {
            // This is only set by the slider or the timer update.
            // The check prevents feedback loops if SetProperty is called from the timer
            // with the same value that the slider already has.
            if (Math.Abs(_sliderPosition - value) > 0.001)
            {
                SetProperty(ref _sliderPosition, value);
            }
        }
    }


    public string CurrentTimeDisplay => _playbackService.CurrentSong is not null ? $"{_playbackService.CurrentPosition:mm\\:ss}" : "--:--";
    public string TotalTimeDisplay => (_playbackService.CurrentSong is not null && _playbackService.CurrentSongDuration.TotalSeconds > 0)
            ? $"{_playbackService.CurrentSongDuration:mm\\:ss}"
            : "--:--";

    public ICommand PlayPauseResumeCommand { get; }
    public ICommand SeekCommand { get; }

    public PlaybackViewModel(PlaybackService playbackService, WaveformService waveformService)
    {
        _playbackService = playbackService;

        WaveformDisplay = new WaveformDisplayViewModel(playbackService, waveformService);
        ModeControls = new PlaybackModeViewModel(this);
        EffectsControls = new PlaybackEffectsViewModel(playbackService);

        PlayPauseResumeCommand = new RelayCommand(
            _ => TogglePlayPauseResume(),
            _ => CurrentSong is not null && !WaveformDisplay.IsWaveformLoading);

        SeekCommand = new RelayCommand(
            positionSecondsObj =>
            {
                if (positionSecondsObj is double seconds && CurrentSongDuration.TotalSeconds > 0)
                {
                    _playbackService.Seek(TimeSpan.FromSeconds(seconds));
                }
            },
             _ => CurrentSong is not null && CurrentSongDuration.TotalSeconds > 0 && !WaveformDisplay.IsWaveformLoading);

        _playbackService.PropertyChanged += PlaybackService_PropertyChanged;
        UpdateAllDisplayProperties(); // Initial sync

        PropertyChanged += PlaybackViewModel_PropertyChanged; // For ModeControls updates
        WaveformDisplay.PropertyChanged += WaveformDisplay_PropertyChanged;
    }

    private void PlaybackService_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        Dispatcher.UIThread.InvokeAsync(() =>
        {
            bool commandStateMayChange = false;
            switch (e.PropertyName)
            {
                case nameof(PlaybackService.CurrentSong):
                    OnPropertyChanged(nameof(CurrentSong));
                    OnPropertyChanged(nameof(HasCurrentSong));
                    OnPropertyChanged(nameof(CurrentTimeDisplay));
                    OnPropertyChanged(nameof(TotalTimeDisplay));
                    UpdateAllDisplayProperties();
                    commandStateMayChange = true;
                    break;
                case nameof(PlaybackService.CurrentPosition):
                    if (!_isUserDraggingSlider)
                    {
                        SliderPosition = _playbackService.CurrentPosition.TotalSeconds;
                    }
                    OnPropertyChanged(nameof(CurrentPosition));
                    OnPropertyChanged(nameof(CurrentPositionSeconds));
                    OnPropertyChanged(nameof(CurrentTimeDisplay));
                    break;
                case nameof(PlaybackService.CurrentSongDuration):
                    OnPropertyChanged(nameof(CurrentSongDuration));
                    OnPropertyChanged(nameof(CurrentSongDurationSeconds));
                    OnPropertyChanged(nameof(TotalTimeDisplay));
                    commandStateMayChange = true;
                    break;
                case nameof(PlaybackService.CurrentPlaybackStatus):
                    OnPropertyChanged(nameof(CurrentPlaybackStatus));
                    OnPropertyChanged(nameof(IsPlaying));
                    commandStateMayChange = true;
                    break;
            }
            if (commandStateMayChange)
            {
                RaisePlaybackCommandCanExecuteChanged();
            }
        });
    }

    private void UpdateAllDisplayProperties()
    {
        OnPropertyChanged(nameof(CurrentTimeDisplay));
        OnPropertyChanged(nameof(TotalTimeDisplay));
        OnPropertyChanged(nameof(CurrentSong));
        OnPropertyChanged(nameof(HasCurrentSong));
        OnPropertyChanged(nameof(CurrentPosition));
        OnPropertyChanged(nameof(CurrentPositionSeconds));
        OnPropertyChanged(nameof(CurrentSongDuration));
        OnPropertyChanged(nameof(CurrentSongDurationSeconds));
        OnPropertyChanged(nameof(CurrentPlaybackStatus));
        OnPropertyChanged(nameof(IsPlaying));
        SliderPosition = _playbackService.CurrentPosition.TotalSeconds;
    }

    private void WaveformDisplay_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName != nameof(WaveformDisplayViewModel.IsWaveformLoading))
        {
            return;
        }
        RaisePlaybackCommandCanExecuteChanged();
    }

    private void TogglePlayPauseResume()
    {
        Debug.WriteLine($"[PlaybackVM] TogglePlayPauseResume called. Current state: {CurrentPlaybackStatus}");
        if (CurrentPlaybackStatus == PlaybackStateStatus.Playing)
        {
            _playbackService.Pause();
        }
        else if (CurrentPlaybackStatus == PlaybackStateStatus.Paused)
        {
            _playbackService.Resume();
        }
        else if (CurrentPlaybackStatus == PlaybackStateStatus.Stopped && CurrentSong is not null)
        {
            _playbackService.Resume();
        }
        else if (CurrentPlaybackStatus == PlaybackStateStatus.Stopped && CurrentSong == null)
        {
            Debug.WriteLine("[PlaybackVM] TogglePlayPauseResume called in Stopped state with no song. Doing nothing.");
        }
    }

    private void PlaybackViewModel_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        switch (e.PropertyName)
        {
            case nameof(HasCurrentSong):
                ModeControls.RaiseCommandCanExecuteChanged();
                break;
        }
    }

    public void BeginSliderDrag()
    {
        _isUserDraggingSlider = true;
        Debug.WriteLine("[PlaybackVM] Begin slider drag");
    }

    public void CompleteSliderDrag()
    {
        if (_isUserDraggingSlider)
        {
            _isUserDraggingSlider = false;
            Debug.WriteLine($"[PlaybackVM] Slider drag complete. Seeking to: {SliderPosition}");
            _playbackService.Seek(TimeSpan.FromSeconds(SliderPosition));
        }
    }

    public void RaisePlaybackCommandCanExecuteChanged()
    {
        (PlayPauseResumeCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (SeekCommand as RelayCommand)?.RaiseCanExecuteChanged();
        ModeControls.RaiseCommandCanExecuteChanged();
    }

    public void Dispose()
    {
        _playbackService.PropertyChanged -= PlaybackService_PropertyChanged;
        PropertyChanged -= PlaybackViewModel_PropertyChanged;

        if (WaveformDisplay is not null)
        {
            WaveformDisplay.PropertyChanged -= WaveformDisplay_PropertyChanged;
            // If WaveformDisplay implements IDisposable, call it
        }
        ModeControls?.Dispose();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\PlaylistViewModel.cs">
using System.Collections.Generic;
using System.Linq;
using Avalonia.Media.Imaging;
using Sonorize.Models;

namespace Sonorize.ViewModels;

public class PlaylistViewModel : ViewModelBase
{
    public Playlist PlaylistModel { get; }

    private readonly Bitmap? _defaultIcon;

    public string Name => PlaylistModel.Name;
    public int SongCount => PlaylistModel.Songs.Count;
    public bool IsAutoPlaylist => PlaylistModel.IsAutoPlaylist;

    public List<Bitmap?> SongThumbnailsForGrid
    {
        get;
        private set
        {
            SetProperty(ref field, value);
        }

    } = new(new Bitmap?[4]);

    public Bitmap? RepresentativeThumbnail
    {
        get;

        private set
        {
            SetProperty(ref field, value);
        }
    }


    public PlaylistViewModel(Playlist playlist, Bitmap? defaultIcon)
    {
        PlaylistModel = playlist;
        _defaultIcon = defaultIcon;
        RecalculateThumbnails();
    }

    public void RecalculateThumbnails()
    {
        List<Bitmap?> newGrid = new(new Bitmap?[4]);

        List<Bitmap?> distinctSongThumbs = PlaylistModel.Songs
            .Select(s => s.Thumbnail)
            .Where(t => t is not null)
            .Distinct()
            .Take(4)
            .ToList();

        for (int i = 0; i < distinctSongThumbs.Count; i++)
        {
            newGrid[i] = distinctSongThumbs[i];
        }

        if (!SongThumbnailsForGrid.SequenceEqual(newGrid))
        {
            SongThumbnailsForGrid = newGrid;
        }

        Bitmap? newRepresentativeThumbnail = newGrid.FirstOrDefault(t => t is not null) ?? _defaultIcon;
        RepresentativeThumbnail = newRepresentativeThumbnail;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\RelayCommand.cs">
using System;
using System.Windows.Input;

namespace Sonorize.ViewModels;

public class RelayCommand : ICommand
{
    private readonly Action<object?> _execute;
    private readonly Predicate<object?>? _canExecute;
    private EventHandler? _canExecuteChanged;

    public event EventHandler? CanExecuteChanged
    {
        add
        {
            // Note: Avalonia doesn't have a global CommandManager.RequerySuggested like WPF.
            // For simplicity, this basic RelayCommand requires manual raising of CanExecuteChanged
            // or relies on UI controls that re-evaluate CanExecute on interactions.
            // For more robust scenarios, integrate with a mechanism that allows VMs to signal changes.
            _canExecuteChanged += value;
        }
        remove
        {
            _canExecuteChanged -= value;
        }
    }

    public void RaiseCanExecuteChanged()
    {
        _canExecuteChanged?.Invoke(this, EventArgs.Empty);
    }

    public RelayCommand(Action<object?> execute, Predicate<object?>? canExecute = null)
    {
        _execute = execute ?? throw new ArgumentNullException(nameof(execute));
        _canExecute = canExecute;
    }

    public RelayCommand(Action execute, Func<bool>? canExecute = null)
        : this(o => execute(), canExecute == null ? (Predicate<object?>?)null : o => canExecute())
    {
    }


    public bool CanExecute(object? parameter) => _canExecute == null || _canExecute(parameter);
    public void Execute(object? parameter) => _execute(parameter);
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\SongDisplayMode.cs">
namespace Sonorize.ViewModels;

public enum SongDisplayMode
{
    Detailed,
    Compact,
    Grid
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\SongMetadataEditorViewModel.cs">
using System.Windows.Input;
using Sonorize.Models;
using Avalonia.Media.Imaging; // For Bitmap
using System.IO; // For MemoryStream, File
using Avalonia.Platform.Storage; // For FilePicker
using Avalonia.Controls; // For Window (as command parameter)
using System.Linq; // For FirstOrDefault
using System.Diagnostics; // For Debug

namespace Sonorize.ViewModels;

public class SongMetadataEditorViewModel : ViewModelBase
{
    public Song SongToEdit { get; }

    private Bitmap? _currentDisplayThumbnail;
    public Bitmap? CurrentDisplayThumbnail
    {
        get => _currentDisplayThumbnail;
        private set => SetProperty(ref _currentDisplayThumbnail, value);
    }

    public string Title
    {
        get => SongToEdit.Title;
        set
        {
            if (SongToEdit.Title != value)
            {
                SongToEdit.Title = value;
                OnPropertyChanged();
            }
        }
    }

    public string Artist
    {
        get => SongToEdit.Artist;
        set
        {
            if (SongToEdit.Artist != value)
            {
                SongToEdit.Artist = value;
                OnPropertyChanged();
            }
        }
    }

    public string Album
    {
        get => SongToEdit.Album;
        set
        {
            if (SongToEdit.Album != value)
            {
                SongToEdit.Album = value;
                OnPropertyChanged();
            }
        }
    }

    public bool DialogResult { get; private set; } = false;

    public ICommand SaveCommand { get; }
    public ICommand CancelCommand { get; }
    public ICommand ChangeThumbnailCommand { get; }

    public System.Action? CloseWindowAction { get; set; }


    public SongMetadataEditorViewModel(Song songToEdit)
    {
        SongToEdit = songToEdit ?? throw new System.ArgumentNullException(nameof(songToEdit));
        _currentDisplayThumbnail = songToEdit.Thumbnail; // Initialize with current song's thumbnail

        SaveCommand = new RelayCommand(_ =>
        {
            SongToEdit.Thumbnail = CurrentDisplayThumbnail; // Commit the potentially changed thumbnail
            DialogResult = true;
            CloseWindowAction?.Invoke();
        });

        CancelCommand = new RelayCommand(_ =>
        {
            DialogResult = false;
            CloseWindowAction?.Invoke();
        });

        ChangeThumbnailCommand = new RelayCommand(async owner =>
        {
            if (owner is not Window ownerWindow) return;

            var filePickerOptions = new FilePickerOpenOptions
            {
                Title = "Select Cover Image",
                AllowMultiple = false,
                FileTypeFilter = new[] { FilePickerFileTypes.ImageAll }
            };

            var result = await ownerWindow.StorageProvider.OpenFilePickerAsync(filePickerOptions);
            if (result.Count > 0)
            {
                var selectedFile = result.FirstOrDefault();
                if (selectedFile is not null)
                {
                    try
                    {
                        await using var stream = await selectedFile.OpenReadAsync();
                        CurrentDisplayThumbnail = new Bitmap(stream);
                    }
                    catch (System.Exception ex)
                    {
                        Debug.WriteLine($"[SongMetaEditorVM] Error loading image: {ex.Message}");
                        // Optionally show an error to the user
                    }
                }
            }
        });
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\StatusBarTextProvider.cs">
using Sonorize.Models;
using Sonorize.Services;

namespace Sonorize.ViewModels.Status;

public static class StatusBarTextProvider
{
    public static string GetCurrentStatusText(PlaybackViewModel playbackViewModel, LoopEditorViewModel loopEditorViewModel, LibraryViewModel libraryViewModel)
    {
        if (!playbackViewModel.HasCurrentSong)
        {
            return libraryViewModel.LibraryStatusText;
        }

        string playbackStateStr = GetPlaybackStateString(playbackViewModel.CurrentPlaybackStatus);
        string baseStatus = $"{playbackStateStr}: {playbackViewModel.CurrentSong?.Title ?? "Unknown Song"}";
        string loopStatus = GetLoopStatusString(loopEditorViewModel, playbackViewModel.CurrentSong);
        string modeStatus = GetPlaybackModeStatusString(playbackViewModel.ModeControls);

        return $"{baseStatus}{loopStatus}{modeStatus}";
    }

    private static string GetPlaybackStateString(PlaybackStateStatus status)
    {
        return status switch
        {
            PlaybackStateStatus.Playing => "Playing",
            PlaybackStateStatus.Paused => "Paused",
            PlaybackStateStatus.Stopped => "Stopped",
            _ => "Idle"
        };
    }

    private static string GetLoopStatusString(LoopEditorViewModel loopEditorViewModel, Song? currentSong)
    {
        if (loopEditorViewModel.ActiveLoop.IsLoopActive && currentSong?.SavedLoop is not null)
        {
            return " (Loop Active)";
        }

        return string.Empty;
    }

    private static string GetPlaybackModeStatusString(PlaybackModeViewModel modeControls)
    {
        string modeStatus = "";
        if (modeControls.ShuffleEnabled)
        {
            modeStatus += " | Shuffle";
        }

        modeStatus += modeControls.RepeatMode switch
        {
            RepeatMode.None => " | Do Nothing",
            RepeatMode.PlayOnce => " | Play Once",
            RepeatMode.RepeatOne => " | Repeat Song",
            RepeatMode.RepeatAll => " | Repeat All",
            _ => ""
        };
        return modeStatus;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\ViewModelBase.cs">
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace Sonorize.ViewModels;

public class ViewModelBase : INotifyPropertyChanged
{
    public event PropertyChangedEventHandler? PropertyChanged;

    protected bool SetProperty<T>(ref T field, T value, [CallerMemberName] string? propertyName = null)
    {
        if (EqualityComparer<T>.Default.Equals(field, value))
        {
            return false;
        }

        field = value;
        OnPropertyChanged(propertyName);
        return true;
    }

    protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\WaveformDisplayViewModel.cs">
using System;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;
using Avalonia.Threading;
using Sonorize.Models;
using Sonorize.Services;

namespace Sonorize.ViewModels;

public class WaveformDisplayViewModel : ViewModelBase
{
    private readonly PlaybackService _playbackService;
    private readonly AsyncWaveformLoader _waveformLoader; // New helper class instance
    private Song? _currentSongForWaveform; // Song currently targeted for display
    private bool _isPanelVisible;

    // Properties now proxy to AsyncWaveformLoader
    public ObservableCollection<WaveformPoint> WaveformRenderData => _waveformLoader.WaveformRenderData;
    public bool IsWaveformLoading => _waveformLoader.IsLoading;

    public WaveformDisplayViewModel(PlaybackService playbackService, WaveformService waveformService)
    {
        _playbackService = playbackService ?? throw new ArgumentNullException(nameof(playbackService));
        _waveformLoader = new AsyncWaveformLoader(waveformService ?? throw new ArgumentNullException(nameof(waveformService)));

        // Subscribe to PropertyChanged on the loader to forward IsLoading changes
        _waveformLoader.PropertyChanged += WaveformLoader_PropertyChanged;

        _playbackService.PropertyChanged += PlaybackService_PropertyChanged;
        UpdateCurrentSongForWaveform(_playbackService.CurrentSong); // Initial sync
    }

    private void WaveformLoader_PropertyChanged(object? sender, System.ComponentModel.PropertyChangedEventArgs e)
    {
        if (e.PropertyName == nameof(AsyncWaveformLoader.IsLoading))
        {
            OnPropertyChanged(nameof(IsWaveformLoading)); // Notify that our proxied property changed
        }
        // WaveformRenderData is an ObservableCollection, changes within it will propagate automatically to bindings.
        // If the entire collection instance on the loader were to change (it doesn't in this design),
        // then we'd need to forward that too.
    }

    private async void PlaybackService_PropertyChanged(object? sender, System.ComponentModel.PropertyChangedEventArgs e)
    {
        if (e.PropertyName == nameof(PlaybackService.CurrentSong))
        {
            // Ensure UI-related updates from service are dispatched if not already on UI thread
            await Dispatcher.UIThread.InvokeAsync(() =>
            {
                UpdateCurrentSongForWaveform(_playbackService.CurrentSong);
            });
        }
    }

    private void UpdateCurrentSongForWaveform(Song? newSong)
    {
        if (_currentSongForWaveform == newSong)
        {
            // If the song is the same, and panel is visible, ensure waveform is loaded if not already
            // This handles cases where the panel might have been hidden and then reshown for the same song.
            if (_isPanelVisible && newSong is not null && !WaveformRenderData.Any() && !IsWaveformLoading)
            {
                Debug.WriteLine($"[WaveformDisplayVM] Panel visible for same song '{newSong.Title}', but no waveform. Triggering load.");
                _ = TryLoadWaveformAsync(newSong);
            }
            return;
        }

        _currentSongForWaveform = newSong;

        if (_currentSongForWaveform is not null && _isPanelVisible)
        {
            Debug.WriteLine($"[WaveformDisplayVM] Current song changed to '{_currentSongForWaveform.Title}' and panel is visible. Triggering load.");
            _ = TryLoadWaveformAsync(_currentSongForWaveform);
        }
        else
        {
            // If no song, or panel not visible, clear current waveform data and stop any loading.
            _waveformLoader.ClearDataAndState();
            OnPropertyChanged(nameof(WaveformRenderData)); // Ensure UI updates if collection was cleared
            Debug.WriteLine($"[WaveformDisplayVM] Current song is '{_currentSongForWaveform?.Title ?? "null"}' and panel visible: {_isPanelVisible}. Load deferred or data cleared.");
        }
    }

    public void SetPanelVisibility(bool isVisible)
    {
        if (_isPanelVisible == isVisible) return; // No change

        _isPanelVisible = isVisible;
        Debug.WriteLine($"[WaveformDisplayVM] Panel visibility set to: {isVisible}");

        if (_isPanelVisible && _currentSongForWaveform is not null)
        {
            // Panel became visible for the current song. If no data and not loading, start load.
            if (!WaveformRenderData.Any() && !IsWaveformLoading)
            {
                Debug.WriteLine($"[WaveformDisplayVM] Panel now visible for song '{_currentSongForWaveform.Title}'. Triggering waveform load.");
                _ = TryLoadWaveformAsync(_currentSongForWaveform);
            }
        }
        else if (!_isPanelVisible)
        {
            // Panel hidden. Existing logic in UpdateCurrentSongForWaveform handles clearing data if song also changes.
            // If only visibility changes, current design keeps data but won't load new.
            // Optionally, could clear data: _waveformLoader.ClearDataAndState(); OnPropertyChanged(nameof(WaveformRenderData));
            Debug.WriteLine($"[WaveformDisplayVM] Panel hidden. Waveform loading deferred if song changes or panel re-opens.");
        }
    }

    private async Task TryLoadWaveformAsync(Song songToLoad)
    {
        // The context passed to RequestLoadAsync uses the current state of the ViewModel
        await _waveformLoader.RequestLoadAsync(songToLoad, 1000, _currentSongForWaveform, _isPanelVisible);
    }

    // Dispose method if AsyncWaveformLoader needs disposal or to unsubscribe from its events
    // For now, only unsubscribing from _waveformLoader.PropertyChanged.
    // If AsyncWaveformLoader implemented IDisposable, call _waveformLoader.Dispose() here.
    protected override void OnPropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
    {
        base.OnPropertyChanged(propertyName);
        if (propertyName == nameof(IsWaveformLoading) && IsWaveformLoading == false && _playbackService.CurrentSong != _currentSongForWaveform)
        {
            // A previous load finished, but the song context has since changed.
            // Trigger a new load for the actual current song if conditions are met.
            if (_currentSongForWaveform is not null && _isPanelVisible)
            {
                Debug.WriteLine($"[WaveformDisplayVM] Post-load check: Song context changed from '{_playbackService.CurrentSong?.Title}' to '{_currentSongForWaveform.Title}'. Re-evaluating load for {_currentSongForWaveform.Title}.");
                _ = TryLoadWaveformAsync(_currentSongForWaveform);
            }
        }
    }

    public void Dispose()
    {
        _playbackService.PropertyChanged -= PlaybackService_PropertyChanged;
        _waveformLoader.PropertyChanged -= WaveformLoader_PropertyChanged;
        // If _waveformLoader were IDisposable: _waveformLoader.Dispose();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Views\BrushExtensions.cs">
using System;
using Avalonia.Media;

namespace Sonorize.Views;

public static class BrushExtensions
{
    public static IBrush Multiply(this IBrush brush, double factor)
    {
        if (brush is ISolidColorBrush solidBrush)
        {
            var c = solidBrush.Color;
            return new SolidColorBrush(Color.FromArgb(c.A, (byte)Math.Clamp(c.R * factor, 0, 255), (byte)Math.Clamp(c.G * factor, 0, 255), (byte)Math.Clamp(c.B * factor, 0, 255)));
        }

        return brush;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Views\MainWindow.cs">
using System; // For EventArgs
using System.ComponentModel; // For PropertyChangedEventArgs, CancelEventArgs
using System.Diagnostics; // For Debug
using Avalonia;
using Avalonia.Controls;
using Avalonia.Controls.Templates;
using Avalonia.Data;
using Avalonia.Layout;
using Avalonia.Threading; // Required for Dispatcher
using Sonorize.Models;
using Sonorize.ViewModels;
using Sonorize.Views.MainWindowControls;

namespace Sonorize.Views;
public class MainWindow : Window
{
    private readonly ThemeColors _theme;
    private LibraryViewModel? _currentLibraryVM;
    private readonly SharedViewTemplates _sharedViewTemplates;
    private readonly MainTabViewControls _mainTabViewControls;
    public MainWindow(ThemeColors theme)
    {
        _theme = theme;
        _sharedViewTemplates = new SharedViewTemplates(_theme);
        _mainTabViewControls = new MainTabViewControls(_theme, _sharedViewTemplates);

        Title = "Sonorize";
        Width = 950;
        Height = 750;
        MinWidth = 700;
        MinHeight = 500;
        WindowStartupLocation = WindowStartupLocation.CenterScreen;
        Background = _theme.B_BackgroundColor;

        var mainGrid = new Grid
        {
            RowDefinitions =
            [
                new(GridLength.Auto),
                new(GridLength.Auto),
                new(GridLength.Star),
                new(GridLength.Auto),
                new(GridLength.Auto),
                new(GridLength.Auto)
            ]
        };

        var menu = MainMenu.Create(_theme, this);
        Grid.SetRow(menu, 0);
        mainGrid.Children.Add(menu);

        var searchBarPanel = SearchBarPanel.Create(_theme);
        Grid.SetRow(searchBarPanel, 1);
        mainGrid.Children.Add(searchBarPanel);

        var tabControl = _mainTabViewControls.CreateMainTabView();
        Grid.SetRow(tabControl, 2);
        mainGrid.Children.Add(tabControl);

        var advancedPlaybackPanel = AdvancedPlaybackPanelControls.Create(_theme);
        advancedPlaybackPanel.Bind(Visual.IsVisibleProperty, new Binding("IsAdvancedPanelVisible"));
        Grid.SetRow(advancedPlaybackPanel, 3);
        mainGrid.Children.Add(advancedPlaybackPanel);

        var mainPlaybackControls = MainPlaybackControlsPanel.Create(_theme);
        Grid.SetRow(mainPlaybackControls, 4);
        mainGrid.Children.Add(mainPlaybackControls);

        var statusBar = CreateStatusBar();
        Grid.SetRow(statusBar, 5);
        mainGrid.Children.Add(statusBar);

        Content = mainGrid;

        this.DataContextChanged += MainWindow_DataContextChanged;
        this.Closing += OnMainWindowClosing; // Graceful shutdown hook
    }

    private void OnMainWindowClosing(object? sender, CancelEventArgs e)
    {
        if (DataContext is IDisposable disposable)
        {
            Debug.WriteLine("[MainWindow] Window is closing. Disposing ViewModel to ensure graceful shutdown.");
            disposable.Dispose();
        }
    }

    private void MainWindow_DataContextChanged(object? sender, EventArgs e)
    {
        if (_currentLibraryVM is not null)
        {
            _currentLibraryVM.PropertyChanged -= LibraryViewModel_PropertyChanged;
            _currentLibraryVM = null;
        }

        if (DataContext is not MainWindowViewModel vm || vm.Library == null)
        {
            return;
        }

        vm.SetOwnerView(this);

        _currentLibraryVM = vm.Library;
        _currentLibraryVM.PropertyChanged += LibraryViewModel_PropertyChanged;
    }

    private void LibraryViewModel_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        // No longer needed, view switching is now handled by direct binding in MainTabViewControls
    }

    private Border CreateStatusBar()
    {
        var statusBar = new Border { Background = _theme.B_SlightlyLighterBackground, Padding = new Thickness(10, 4), Height = 26 };
        var statusBarText = new TextBlock { Foreground = _theme.B_SecondaryTextColor, VerticalAlignment = VerticalAlignment.Center, FontSize = 11 };
        statusBarText.Bind(TextBlock.TextProperty, new Binding("StatusBarText"));
        statusBar.Child = statusBarText;
        return statusBar;
    }

    protected override void OnClosed(EventArgs e)
    {
        if (_currentLibraryVM is not null)
        {
            _currentLibraryVM.PropertyChanged -= LibraryViewModel_PropertyChanged;
        }

        if (DataContext is MainWindowViewModel vm)
        {
            vm.SetOwnerView(null!);
        }

        base.OnClosed(e);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Views\SettingsWindow.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Controls.Primitives; // Required for Style
using Avalonia.Data;
using Avalonia.Layout;
using Avalonia.Media;
using Avalonia.Styling;
using Sonorize.Converters; // For EnumToBooleanConverter
using Sonorize.Models;
using Sonorize.ViewModels;
using Sonorize.Views.SettingsWindowControls; // Added for new panel builders

namespace Sonorize.Views;

public class SettingsWindow : Window
{
    private readonly ThemeColors _theme;

    public SettingsWindow(ThemeColors currentDisplayTheme)
    {
        _theme = currentDisplayTheme;

        Title = "Sonorize Settings"; Width = 650; Height = 500; MinWidth = 600; MinHeight = 450;
        CanResize = true; WindowStartupLocation = WindowStartupLocation.CenterOwner; Icon = null;
        Background = _theme.B_SlightlyLighterBackground;

        // Style for the TextBox part of NumericUpDown controls in this window
        this.Styles.Add(new Style(s => s.OfType<NumericUpDown>().Descendant().OfType<TextBox>())
        {
            Setters =
            {
                new Setter(TextBox.ForegroundProperty, _theme.B_TextColor),
                new Setter(TextBox.BackgroundProperty, Brushes.Transparent),
                new Setter(TextBox.CaretBrushProperty, _theme.B_TextColor),
                new Setter(TextBox.BorderThicknessProperty, new Thickness(0)),
                new Setter(TextBox.VerticalContentAlignmentProperty, VerticalAlignment.Center),
                new Setter(TextBox.HorizontalContentAlignmentProperty, HorizontalAlignment.Center),
                new Setter(TextBox.PaddingProperty, new Thickness(10,0)) // Increased horizontal padding
            }
        });

        var mainGrid = new Grid
        {
            ColumnDefinitions = new ColumnDefinitions("150, *"), // Left menu, Right content
            RowDefinitions = new RowDefinitions("*, Auto")      // Content area, Bottom buttons
        };

        // --- Left Navigation Menu ---
        var menuPanelContainer = SettingsMenuPanel.Create(_theme);
        Grid.SetColumn(menuPanelContainer, 0);
        Grid.SetRow(menuPanelContainer, 0);
        mainGrid.Children.Add(menuPanelContainer);

        // --- Right Content Area ---
        var contentArea = CreateContentAreaPanel(); // This method remains to manage visibility
        Grid.SetColumn(contentArea, 1);
        Grid.SetRow(contentArea, 0);
        mainGrid.Children.Add(contentArea);

        // --- Bottom Buttons Panel ---
        var buttonsPanel = SettingsButtonPanel.Create(_theme, this);
        Grid.SetColumnSpan(buttonsPanel, 2); // Span across both columns
        Grid.SetColumn(buttonsPanel, 0);
        Grid.SetRow(buttonsPanel, 1);
        mainGrid.Children.Add(buttonsPanel);

        Content = mainGrid;
    }

    private Panel CreateContentAreaPanel()
    {
        var contentPanel = new Panel { Margin = new Thickness(15) };

        var directoriesSettingsPanel = DirectoriesSettingsPanel.Create(_theme, this);
        directoriesSettingsPanel.Bind(Visual.IsVisibleProperty, new Binding("CurrentSettingsViewSection")
        {
            Converter = EnumToBooleanConverter.Instance,
            ConverterParameter = SettingsViewSection.Directories
        });

        var themeSettingsPanel = ThemeSettingsPanel.Create(_theme);
        themeSettingsPanel.Bind(Visual.IsVisibleProperty, new Binding("CurrentSettingsViewSection")
        {
            Converter = EnumToBooleanConverter.Instance,
            ConverterParameter = SettingsViewSection.Theme
        });
        
        var appearanceSettingsPanel = AppearanceSettingsPanel.Create(_theme);
        appearanceSettingsPanel.Bind(Visual.IsVisibleProperty, new Binding("CurrentSettingsViewSection")
        {
            Converter = EnumToBooleanConverter.Instance,
            ConverterParameter = SettingsViewSection.Appearance
        });

        var scrobblingSettingsPanel = ScrobblingSettingsPanel.Create(_theme);
        scrobblingSettingsPanel.Bind(Visual.IsVisibleProperty, new Binding("CurrentSettingsViewSection")
        {
            Converter = EnumToBooleanConverter.Instance,
            ConverterParameter = SettingsViewSection.Scrobbling
        });

        contentPanel.Children.Add(directoriesSettingsPanel);
        contentPanel.Children.Add(themeSettingsPanel);
        contentPanel.Children.Add(appearanceSettingsPanel);
        contentPanel.Children.Add(scrobblingSettingsPanel);

        return contentPanel;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Views\SongMetadataEditorWindow.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Data;
using Avalonia.Layout;
using Avalonia.Media;
using Avalonia.Media.Imaging; // Required for BitmapInterpolationMode
using Sonorize.Models; // For ThemeColors
using Sonorize.ViewModels; // For SongMetadataEditorViewModel

namespace Sonorize.Views;

public class SongMetadataEditorWindow : Window
{
    private readonly ThemeColors _theme;

    public SongMetadataEditorWindow(ThemeColors theme)
    {
        _theme = theme;
        InitializeComponent();
    }

    private void InitializeComponent()
    {
        Title = "Edit Song Metadata";
        Width = 450; MinWidth = 400;
        Height = 430; MinHeight = 380; // Increased height for thumbnail
        WindowStartupLocation = WindowStartupLocation.CenterOwner;
        CanResize = true;
        Background = _theme.B_SlightlyLighterBackground;
        Foreground = _theme.B_TextColor;

        this.DataContextChanged += (sender, args) =>
        {
            if (DataContext is SongMetadataEditorViewModel vm)
            {
                vm.CloseWindowAction = this.Close;
            }
        };

        var mainPanel = new StackPanel { Margin = new Thickness(15), Spacing = 10 };

        // Thumbnail Display and Change Button
        var thumbnailImage = new Image
        {
            Width = 100,
            Height = 100,
            Stretch = Stretch.UniformToFill
            // Removed Background property from Image
        };
        thumbnailImage.Bind(Image.SourceProperty, new Binding("CurrentDisplayThumbnail"));
        RenderOptions.SetBitmapInterpolationMode(thumbnailImage, BitmapInterpolationMode.HighQuality);

        var thumbnailBorder = new Border // Wrap Image in a Border
        {
            Width = 100,
            Height = 100,
            HorizontalAlignment = HorizontalAlignment.Center,
            Margin = new Thickness(0, 0, 0, 5),
            Background = _theme.B_ControlBackgroundColor, // Set Background on the Border
            Child = thumbnailImage
        };
        mainPanel.Children.Add(thumbnailBorder);


        var changeCoverButton = new Button
        {
            Content = "Change Cover",
            HorizontalAlignment = HorizontalAlignment.Center,
            Background = _theme.B_ControlBackgroundColor,
            Foreground = _theme.B_TextColor,
            Padding = new Thickness(10, 5),
            Margin = new Thickness(0, 0, 0, 10)
        };
        changeCoverButton.Bind(Button.CommandProperty, new Binding("ChangeThumbnailCommand"));
        // Pass the window itself as the command parameter for StorageProvider access
        changeCoverButton.CommandParameter = this;
        mainPanel.Children.Add(changeCoverButton);


        // Title
        mainPanel.Children.Add(new TextBlock { Text = "Title:", Foreground = _theme.B_TextColor });
        var titleBox = new TextBox
        {
            Background = _theme.B_ControlBackgroundColor,
            Foreground = _theme.B_TextColor,
            BorderBrush = _theme.B_SecondaryTextColor,
            Watermark = "Song Title"
        };
        titleBox.Bind(TextBox.TextProperty, new Binding("Title", BindingMode.TwoWay));
        mainPanel.Children.Add(titleBox);

        // Artist
        mainPanel.Children.Add(new TextBlock { Text = "Artist:", Foreground = _theme.B_TextColor });
        var artistBox = new TextBox
        {
            Background = _theme.B_ControlBackgroundColor,
            Foreground = _theme.B_TextColor,
            BorderBrush = _theme.B_SecondaryTextColor,
            Watermark = "Artist Name"
        };
        artistBox.Bind(TextBox.TextProperty, new Binding("Artist", BindingMode.TwoWay));
        mainPanel.Children.Add(artistBox);

        // Album
        mainPanel.Children.Add(new TextBlock { Text = "Album:", Foreground = _theme.B_TextColor });
        var albumBox = new TextBox
        {
            Background = _theme.B_ControlBackgroundColor,
            Foreground = _theme.B_TextColor,
            BorderBrush = _theme.B_SecondaryTextColor,
            Watermark = "Album Name"
        };
        albumBox.Bind(TextBox.TextProperty, new Binding("Album", BindingMode.TwoWay));
        mainPanel.Children.Add(albumBox);

        // Buttons
        var buttonPanel = new StackPanel
        {
            Orientation = Orientation.Horizontal,
            HorizontalAlignment = HorizontalAlignment.Right,
            Spacing = 10,
            Margin = new Thickness(0, 15, 0, 0)
        };

        var saveButton = new Button
        {
            Content = "Save",
            Background = _theme.B_AccentColor,
            Foreground = _theme.B_AccentForeground,
            Padding = new Thickness(15, 8),
            CornerRadius = new CornerRadius(3)
        };
        saveButton.Bind(Button.CommandProperty, new Binding("SaveCommand"));

        var cancelButton = new Button
        {
            Content = "Cancel",
            Background = _theme.B_ControlBackgroundColor,
            Foreground = _theme.B_TextColor,
            Padding = new Thickness(15, 8),
            CornerRadius = new CornerRadius(3)
        };
        cancelButton.Bind(Button.CommandProperty, new Binding("CancelCommand"));

        buttonPanel.Children.Add(saveButton);
        buttonPanel.Children.Add(cancelButton);
        mainPanel.Children.Add(buttonPanel);

        Content = mainPanel;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\Application\ApplicationInteractionService.cs">
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Avalonia.Controls;
using Avalonia.Platform.Storage;
using Sonorize.Models;
using Sonorize.ViewModels;

namespace Sonorize.Services;

public class ApplicationInteractionService
{
    private readonly SettingsService _settingsService;
    private readonly SettingsChangeProcessorService _settingsChangeProcessorService;
    private readonly ThemeColors _currentTheme;

    public ApplicationInteractionService(
        SettingsService settingsService,
        SettingsChangeProcessorService settingsChangeProcessorService,
        ThemeColors currentTheme)
    {
        _settingsService = settingsService ?? throw new ArgumentNullException(nameof(settingsService));
        _settingsChangeProcessorService = settingsChangeProcessorService ?? throw new ArgumentNullException(nameof(settingsChangeProcessorService));
        _currentTheme = currentTheme ?? throw new ArgumentNullException(nameof(currentTheme));
    }

    public async Task<(List<string> statusMessages, bool settingsChanged)> HandleOpenSettingsDialogAsync(Window owner)
    {
        var currentSettingsBeforeDialog = _settingsService.LoadSettings();
        var settingsVM = new SettingsViewModel(_settingsService);
        var settingsDialog = new Sonorize.Views.SettingsWindow(_currentTheme) { DataContext = settingsVM };

        await settingsDialog.ShowDialog(owner);

        List<string> statusMessages = [];
        bool overallSettingsChanged = false;

        if (settingsVM.SettingsChanged)
        {
            Debug.WriteLine("[AppInteractionService] Settings changed detected after dialog closed. Processing changes...");
            var newSettingsAfterDialog = _settingsService.LoadSettings(); // Get the latest saved settings

            statusMessages = await _settingsChangeProcessorService.ProcessChangesAndGetStatus(
                currentSettingsBeforeDialog,
                newSettingsAfterDialog
            );
            overallSettingsChanged = true; // Indicate that settings were processed
        }
        else
        {
            Debug.WriteLine("[AppInteractionService] Settings dialog closed, no changes reported by SettingsViewModel.");
        }
        return (statusMessages, overallSettingsChanged);
    }

    public async Task<(bool directoryAddedAndLibraryRefreshNeeded, string statusMessage)> HandleAddMusicDirectoryAsync(Window owner)
    {
        var result = await owner.StorageProvider.OpenFolderPickerAsync(new FolderPickerOpenOptions { Title = "Select Music Directory", AllowMultiple = false });

        if (result == null || result.Count == 0)
        {
            Debug.WriteLine("[AppInteractionService] Folder picker cancelled or returned no results.");
            return (false, "Folder selection cancelled.");
        }

        string? folderPath = null;
        try
        {
            folderPath = Path.GetFullPath(result[0].Path.LocalPath);
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[AppInteractionService] Error getting full path for selected directory: {ex.Message}");
            return (false, "Error getting path for selected directory.");
        }

        if (string.IsNullOrEmpty(folderPath) || !Directory.Exists(folderPath))
        {
            Debug.WriteLine($"[AppInteractionService] Selected directory path is invalid or does not exist: {folderPath}");
            return (false, "Invalid directory selected.");
        }

        var settings = _settingsService.LoadSettings();
        if (!settings.MusicDirectories.Any(d => string.Equals(d, folderPath, StringComparison.OrdinalIgnoreCase)))
        {
            settings.MusicDirectories.Add(folderPath);
            _settingsService.SaveSettings(settings);
            Debug.WriteLine($"[AppInteractionService] Added new directory: {folderPath}. Library refresh needed.");
            return (true, $"Added directory: {Path.GetFileName(folderPath)}. Library refreshing...");
        }
        else
        {
            Debug.WriteLine($"[AppInteractionService] Directory already exists: {folderPath}");
            return (false, "Directory already in library.");
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\Application\ApplicationServicesBootstrapper.cs">
using Sonorize.Models;
using Sonorize.Services.Playback; // Required for PlaybackResourceInterlockService
using Sonorize.ViewModels;

namespace Sonorize.Services;

public class ApplicationServicesBootstrapper
{
    public MainWindowViewModel Bootstrap(SettingsService settingsService, ThemeColors currentCustomTheme)
    {
        // Create all services
        var lastfmAuthenticatorService = new LastfmAuthenticatorService(settingsService);
        var scrobblingService = new ScrobblingService(settingsService, lastfmAuthenticatorService);
        var loopDataService = new LoopDataService();
        var playCountDataService = new PlayCountDataService(); // NEW
        var playbackService = new PlaybackService(scrobblingService, playCountDataService); // MODIFIED
        var defaultIconGenerator = new DefaultIconGenerator();
        var albumArtLoader = new AlbumArtLoader(); // Create AlbumArtLoader
        var thumbnailService = new ThumbnailService(defaultIconGenerator, albumArtLoader); // Pass both dependencies
        var songFactory = new SongFactory(loopDataService, playCountDataService); // MODIFIED
        var musicLibraryService = new MusicLibraryService(loopDataService, thumbnailService, songFactory);
        var waveformService = new WaveformService();
        var songMetadataService = new SongMetadataService();
        var songLoopService = new SongLoopService(loopDataService);

        var playbackResourceInterlockService = new PlaybackResourceInterlockService(playbackService.SessionManager);

        var songEditInteractionService = new SongEditInteractionService(playbackResourceInterlockService, songMetadataService, currentCustomTheme);

        // Create MainWindowViewModel
        var mainWindowViewModel = new MainWindowViewModel(
            settingsService,
            musicLibraryService,
            playbackService,
            currentCustomTheme,
            waveformService,
            loopDataService,
            scrobblingService,
            songMetadataService,
            songEditInteractionService,
            songLoopService);

        return mainWindowViewModel;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\Playback\NAudioEffectsProcessor.cs">
using System;
using System.Diagnostics;
using NAudio.Wave;
using NAudio.Wave.SampleProviders;
using SoundTouch.Net.NAudioSupport;

namespace Sonorize.Services;

public class NAudioEffectsProcessor : IDisposable
{
    private SoundTouchWaveProvider? _soundTouch;
    private SmbPitchShiftingSampleProvider? _pitchShifter;
    private SampleToWaveProvider? _sampleToWaveProvider;

    private ISampleProvider? _outputProvider;

    public ISampleProvider OutputProvider
    {
        get
        {
            if (_outputProvider is null)
            {
                throw new InvalidOperationException("Audio effects processor has not been initialized.");
            }

            return _outputProvider;
        }
    }

    public float Tempo
    {
        get;
        set
        {
            if (float.Abs(field - value) <= float.Epsilon)
            {
                return;
            }

            field = value;

            if (_soundTouch is null)
            {
                return;
            }

            try
            {
                _soundTouch.Tempo = field;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[EffectsProcessor] Error setting SoundTouch Tempo: {ex.Message}");
            }
        }
    } = 1.0f;

    public float PitchSemitones
    {
        get;
        set
        {
            if (float.Abs(field - value) <= float.Epsilon)
            {
                return;
            }

            field = value;

            if (_pitchShifter is null)
            {
                return;
            }
            try
            {
                _pitchShifter.PitchFactor = (float)Math.Pow(2, field / 12.0);
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[EffectsProcessor] Error setting PitchShifter PitchFactor: {ex.Message}");
            }
        }
    } = 0f;

    public NAudioEffectsProcessor()
    {
    }

    public void Initialize(ISampleProvider sourceProvider)
    {
        Dispose(disposing: true);

        ArgumentNullException.ThrowIfNull(sourceProvider);

        try
        {
            ISampleProvider monoSampleProvider = sourceProvider.ToMono();

            _sampleToWaveProvider = new SampleToWaveProvider(monoSampleProvider);

            _soundTouch = new SoundTouchWaveProvider(_sampleToWaveProvider);
            _soundTouch.Tempo = Tempo;
            _soundTouch.Rate = 1.0f;
            _soundTouch.Pitch = 1.0f;

            ISampleProvider soundTouchAsSampleProvider = _soundTouch.ToSampleProvider();

            _pitchShifter = new SmbPitchShiftingSampleProvider(soundTouchAsSampleProvider);
            _pitchShifter.PitchFactor = (float)Math.Pow(2, PitchSemitones / 12.0);

            _outputProvider = _pitchShifter;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[EffectsProcessor] CRITICAL ERROR during effects pipeline initialization: {ex.ToString()}");
            Dispose(disposing: true);
            _outputProvider = null;
            throw;
        }
    }

    public void Dispose()
    {
        Dispose(disposing: true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!disposing)
        {
            return;
        }

        _sampleToWaveProvider = null;
        _soundTouch = null;
        _pitchShifter = null;
        _outputProvider = null;
    }

    ~NAudioEffectsProcessor()
    {
        Dispose(disposing: false);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\Playback\NAudioPipeline.cs">
using System;
using System.Diagnostics;
using System.IO;
using NAudio.Wave;

namespace Sonorize.Services.Playback;

internal class NAudioPipeline : IDisposable
{
    public AudioFileReader AudioReader { get; private set; }
    public NAudioEffectsProcessor EffectsProcessor { get; private set; }
    public IWavePlayer OutputDevice { get; private set; }

    private readonly EventHandler<StoppedEventArgs> _enginePlaybackStoppedHandler;

    public NAudioPipeline(string filePath, float initialRate, float initialPitch, EventHandler<StoppedEventArgs> enginePlaybackStoppedHandler)
    {
        if (string.IsNullOrEmpty(filePath))
        {
            throw new ArgumentNullException(nameof(filePath));
        }

        _enginePlaybackStoppedHandler = enginePlaybackStoppedHandler ?? throw new ArgumentNullException(nameof(enginePlaybackStoppedHandler));
        
        try
        {
            AudioReader = new AudioFileReader(filePath);
            Debug.WriteLine($"[Pipeline] Loaded AudioFileReader. Channels: {AudioReader.WaveFormat.Channels}, SampleRate: {AudioReader.WaveFormat.SampleRate}, Duration: {AudioReader.TotalTime}");

            EffectsProcessor = new NAudioEffectsProcessor();
            EffectsProcessor.Initialize(AudioReader.ToSampleProvider());
            EffectsProcessor.Tempo = initialRate;
            EffectsProcessor.PitchSemitones = initialPitch;
            Debug.WriteLine($"[Pipeline] Effects Processor initialized. Tempo: {EffectsProcessor.Tempo}, Pitch: {EffectsProcessor.PitchSemitones}");

            OutputDevice = new WaveOutEvent();
            OutputDevice.PlaybackStopped += OnOutputDevicePlaybackStopped; // Subscribe to the actual device
            OutputDevice.Init(EffectsProcessor.OutputProvider.ToWaveProvider());
            Debug.WriteLine($"[Pipeline] NAudio pipeline created successfully for: {Path.GetFileName(filePath)}.");
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[Pipeline] CRITICAL ERROR during NAudio pipeline creation for {Path.GetFileName(filePath)}: {ex.ToString()}");
            Dispose(); // Clean up if constructor fails partially
            throw; // Re-throw to allow NAudioPlaybackEngine to handle
        }
    }

    private void OnOutputDevicePlaybackStopped(object? sender, StoppedEventArgs e)
    {
        // Forward the event to the handler provided by NAudioPlaybackEngine
        _enginePlaybackStoppedHandler.Invoke(this, e); // Pass 'this' (NAudioPipeline) as sender, or OutputDevice
    }

    public void Dispose()
    {
        if (OutputDevice is not null)
        {
            OutputDevice.PlaybackStopped -= OnOutputDevicePlaybackStopped;
            OutputDevice.Dispose();
        }
        EffectsProcessor?.Dispose();
        AudioReader?.Dispose();
        Debug.WriteLine("[Pipeline] Disposed NAudioPipeline resources.");
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\Playback\NAudioPlaybackEngine.cs">
using System;
using System.Diagnostics;
using System.IO;
using NAudio.Wave;
using Sonorize.Services.Playback; // Added for NAudioPipeline

namespace Sonorize.Services;

public class NAudioPlaybackEngine : IDisposable
{
    private NAudioPipeline? _pipeline;

    public event EventHandler<StoppedEventArgs>? PlaybackStopped;

    public TimeSpan CurrentPosition
    {
        get => _pipeline?.AudioReader?.CurrentTime ?? TimeSpan.Zero;
        set
        {
            if (_pipeline?.AudioReader is not null) _pipeline.AudioReader.CurrentTime = value;
            else Debug.WriteLine("[Engine] Attempted to set CurrentPosition on null pipeline/audioReader.");
        }
    }

    public TimeSpan CurrentSongDuration => _pipeline?.AudioReader?.TotalTime ?? TimeSpan.Zero;

    public PlaybackStateStatus CurrentPlaybackStatus
    {
        get
        {
            if (_pipeline?.OutputDevice == null) return PlaybackStateStatus.Stopped;
            return _pipeline.OutputDevice.PlaybackState switch
            {
                NAudio.Wave.PlaybackState.Playing => PlaybackStateStatus.Playing,
                NAudio.Wave.PlaybackState.Paused => PlaybackStateStatus.Paused,
                NAudio.Wave.PlaybackState.Stopped => PlaybackStateStatus.Stopped,
                _ => PlaybackStateStatus.Stopped
            };
        }
    }

    public float PlaybackRate
    {
        get => _playbackRate;
        set
        {
            _playbackRate = value;
            if (_pipeline?.EffectsProcessor is not null) _pipeline.EffectsProcessor.Tempo = value;
        }
    }
    private float _playbackRate = 1.0f;

    public float PitchSemitones
    {
        get => _pitchSemitones;
        set
        {
            _pitchSemitones = value;
            if (_pipeline?.EffectsProcessor is not null) _pipeline.EffectsProcessor.PitchSemitones = value;
        }
    }
    private float _pitchSemitones = 0f;


    public NAudioPlaybackEngine()
    {
        Debug.WriteLine("[Engine] Constructor called.");
    }

    public void Load(string filePath)
    {
        Debug.WriteLine($"[Engine] Load called for: {Path.GetFileName(filePath)}");

        if (!File.Exists(filePath))
        {
            Debug.WriteLine($"[Engine] Load failed: File not found at {filePath}");
            throw new FileNotFoundException("Audio file not found.", filePath);
        }

        Dispose(disposing: true); // Dispose existing pipeline first

        try
        {
            // Properties PlaybackRate and PitchSemitones are used by NAudioPipeline constructor
            _pipeline = new NAudioPipeline(filePath, PlaybackRate, PitchSemitones, OnPipelinePlaybackStopped);
            Debug.WriteLine($"[Engine] NAudio pipeline loaded successfully via NAudioPipeline for: {Path.GetFileName(filePath)}.");
        }
        catch (Exception ex)
        {
            // NAudioPipeline constructor re-throws on failure after its own cleanup.
            Debug.WriteLine($"[Engine] CRITICAL ERROR during NAudioPipeline creation for {Path.GetFileName(filePath)}: {ex.ToString()}");
            Dispose(disposing: true); // Ensure engine's _pipeline is null
            throw new Exception($"Failed to load audio pipeline for {Path.GetFileName(filePath)}", ex);
        }
    }

    public void Play()
    {
        Debug.WriteLine("[Engine] Play requested.");
        if (_pipeline?.OutputDevice is not null && (_pipeline.OutputDevice.PlaybackState == NAudio.Wave.PlaybackState.Paused || _pipeline.OutputDevice.PlaybackState == NAudio.Wave.PlaybackState.Stopped))
        {
            Debug.WriteLine("[Engine] Calling device.Play().");
            try
            {
                _pipeline.OutputDevice.Play();
                Debug.WriteLine($"[Engine] Playback started/resumed. State: {CurrentPlaybackStatus}");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[Engine] Error during device.Play(): {ex.Message}");
            }
        }
        else if (_pipeline?.OutputDevice is not null && _pipeline.OutputDevice.PlaybackState == NAudio.Wave.PlaybackState.Playing)
        {
            Debug.WriteLine("[Engine] Already playing. Doing nothing.");
        }
        else
        {
            Debug.WriteLine("[Engine] Cannot Play: Device not initialized via pipeline.");
        }
    }

    public void Pause()
    {
        Debug.WriteLine("[Engine] Pause requested.");
        if (_pipeline?.OutputDevice is not null && _pipeline.OutputDevice.PlaybackState == NAudio.Wave.PlaybackState.Playing)
        {
            Debug.WriteLine("[Engine] Calling device.Pause().");
            try
            {
                _pipeline.OutputDevice.Pause();
                Debug.WriteLine($"[Engine] Playback paused. State: {CurrentPlaybackStatus}");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[Engine] Error during device.Pause(): {ex.Message}");
            }
        }
        else
        {
            Debug.WriteLine($"[Engine] Cannot Pause: Device state is {_pipeline?.OutputDevice?.PlaybackState ?? NAudio.Wave.PlaybackState.Stopped}.");
        }
    }

    public void Stop()
    {
        Debug.WriteLine("[Engine] Stop requested.");
        if (_pipeline?.OutputDevice is not null && _pipeline.OutputDevice.PlaybackState != NAudio.Wave.PlaybackState.Stopped)
        {
            Debug.WriteLine("[Engine] Calling device.Stop().");
            try
            {
                _pipeline.OutputDevice.Stop();
                Debug.WriteLine($"[Engine] Stop initiated. Device state: {_pipeline?.OutputDevice?.PlaybackState}. PlaybackStopped event should follow.");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[Engine] Error during device.Stop(): {ex.Message}. PlaybackStopped event may not fire.");
            }
        }
        else
        {
            Debug.WriteLine("[Engine] Already stopped or not initialized. Doing nothing.");
        }
    }

    public void Seek(TimeSpan position)
    {
        Debug.WriteLine($"[Engine] Seek requested to {position:mm\\:ss\\.ff}.");
        if (_pipeline?.AudioReader is not null)
        {
            try
            {
                _pipeline.AudioReader.CurrentTime = position;
                Debug.WriteLine($"[Engine] Seek successful. Actual position: {_pipeline.AudioReader.CurrentTime:mm\\:ss\\.ff}");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[Engine] Error during audioFileReader.CurrentTime = {position:mm\\:ss\\.ff}: {ex.Message}");
            }
        }
        else
        {
            Debug.WriteLine("[Engine] Cannot Seek: AudioFileReader (via pipeline) not initialized.");
        }
    }

    private void OnPipelinePlaybackStopped(object? sender, StoppedEventArgs e)
    {
        // The sender here will be the NAudioPipeline instance, or its OutputDevice.
        // We trust that NAudioPipeline correctly manages its event subscriptions.
        Debug.WriteLine("[Engine] OnPipelinePlaybackStopped event received from NAudioPipeline.");
        PlaybackStopped?.Invoke(this, e); // Raise engine's own event
    }


    public void Dispose()
    {
        Debug.WriteLine("[Engine] Dispose() called.");
        Dispose(disposing: true);
        GC.SuppressFinalize(this);
        Debug.WriteLine("[Engine] Dispose() completed.");
    }

    protected virtual void Dispose(bool disposing)
    {
        if (disposing)
        {
            if (_pipeline is not null)
            {
                // Unsubscribe from _pipeline events if any were directly subscribed by this class
                // (Currently, NAudioPipeline forwards its OutputDevice.PlaybackStopped to OnPipelinePlaybackStopped,
                // so no direct subscription to _pipeline here that needs unsubscribing).
                _pipeline.Dispose();
                _pipeline = null;
            }
        }
    }

    ~NAudioPlaybackEngine()
    {
        Debug.WriteLine("[Engine] Finalizer called for NAudioPlaybackEngine.");
        Dispose(disposing: false);
        Debug.WriteLine("[Engine] Finalizer completed for NAudioPlaybackEngine.");
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\Playback\PlaybackCompletionHandler.cs">
using System;
using System.Diagnostics;
using Sonorize.Models;
using NAudio.Wave; // Required for StoppedEventArgs

namespace Sonorize.Services.Playback;

public class PlaybackCompletionHandler
{
    private readonly PlaybackSessionManager _sessionManager;
    private readonly ScrobblingService _scrobblingService;

    public PlaybackCompletionHandler(PlaybackSessionManager sessionManager, ScrobblingService scrobblingService)
    {
        _sessionManager = sessionManager ?? throw new ArgumentNullException(nameof(sessionManager));
        _scrobblingService = scrobblingService ?? throw new ArgumentNullException(nameof(scrobblingService));
    }

    public void Handle(
        StoppedEventArgs eventArgs,
        Song? songThatJustStopped, // The song instance whose playback actually stopped
        TimeSpan actualStoppedPosition,
        TimeSpan actualStoppedSongDuration,
        bool wasExplicitlyStopped, // Flag indicating if StopSession(isExplicit: true) was the initiator
        bool isInternalStopForSongChange)
    {
        Debug.WriteLine($"[PlaybackCompletionHandler] Handling playback stop for: {songThatJustStopped?.Title ?? "No Song"}. ExplicitStop: {wasExplicitlyStopped}, InternalChange: {isInternalStopForSongChange}, Error: {eventArgs.Exception is not null}, Pos: {actualStoppedPosition:mm\\:ss\\.ff}, Dur: {actualStoppedSongDuration:mm\\:ss\\.ff}");

        if (eventArgs.Exception is not null)
        {
            _sessionManager.StopUiUpdateMonitor(); // Stop monitor on error
            Debug.WriteLine($"[PlaybackCompletionHandler] Playback stopped due to error: {eventArgs.Exception.Message}. Finalizing state to Stopped.");
            _sessionManager.FinalizeCurrentSong(null);
            _sessionManager.SetPlaybackState(false, PlaybackStateStatus.Stopped);
        }
        else if (wasExplicitlyStopped)
        {
            // This is a "hard stop" initiated by the user or app logic intending to end the session.
            _sessionManager.StopUiUpdateMonitor();
            Debug.WriteLine("[PlaybackCompletionHandler] Playback stopped by explicit user/app command. Finalizing.");
            _sessionManager.FinalizeCurrentSong(null);
            _sessionManager.SetPlaybackState(false, PlaybackStateStatus.Stopped);
        }
        else if (isInternalStopForSongChange)
        {
            // This is an internal, programmatic stop that occurred because a new song is being loaded.
            // The SessionManager is already handling the transition, so there's nothing for the completion handler to do.
            Debug.WriteLine($"[PlaybackCompletionHandler] Playback stopped internally for song change. No action needed here.");
        }
        else // Not explicit, not an internal change, not an error - must be natural completion.
        {
            Debug.WriteLine("[PlaybackCompletionHandler] Playback stopped naturally (end of file).");
            _sessionManager.UpdateStateForNaturalPlaybackEnd();
            _sessionManager.TriggerSessionEndedNaturally(); // This will kick off next track logic.
        }

        _sessionManager.ResetExplicitStopFlag();
        Debug.WriteLine($"[PlaybackCompletionHandler] Handle finishes. Session Song: {_sessionManager.GetCurrentSongForCompletion()?.Title ?? "null"}, IsPlaying: {_sessionManager.IsPlaying}, Status: {_sessionManager.CurrentPlaybackStatus}");
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\Playback\PlaybackEngineCoordinator.cs">
using System;
using System.Diagnostics;
using System.IO;
using NAudio.Wave;
using Sonorize.Models;

namespace Sonorize.Services.Playback;

public class PlaybackEngineCoordinator : IDisposable
{
    private readonly NAudioPlaybackEngine _engineController; // Changed type
    private readonly PlaybackLoopHandler _loopHandler;
    private readonly PlaybackMonitor _playbackMonitor;
    public Song? CurrentSong { get; private set; }
    private bool _disposed = false;

    public event EventHandler<StoppedEventArgs>? EnginePlaybackStopped;
    public event EventHandler<PositionEventArgs>? EnginePositionUpdated;

    public TimeSpan CurrentPosition => _engineController.CurrentPosition;
    public TimeSpan CurrentSongDuration => _engineController.CurrentSongDuration;
    public PlaybackStateStatus CurrentPlaybackStatus => _engineController.CurrentPlaybackStatus;

    public PlaybackEngineCoordinator(NAudioPlaybackEngine engineController, PlaybackLoopHandler loopHandler, PlaybackMonitor playbackMonitor) // Changed type
    {
        _engineController = engineController ?? throw new ArgumentNullException(nameof(engineController));
        _loopHandler = loopHandler ?? throw new ArgumentNullException(nameof(loopHandler));
        _playbackMonitor = playbackMonitor ?? throw new ArgumentNullException(nameof(playbackMonitor));

        _engineController.PlaybackStopped += OnEngineControllerPlaybackStoppedRelay;
        Debug.WriteLine("[PlaybackEngineCoordinator] Initialized.");
    }

    private void OnEngineControllerPlaybackStoppedRelay(object? sender, StoppedEventArgs e)
    {
        EnginePlaybackStopped?.Invoke(this, e);
    }

    private void OnMonitorPositionUpdate(TimeSpan position, TimeSpan duration)
    {
        EnginePositionUpdated?.Invoke(this, new PositionEventArgs(position, duration));
    }

    public void SetSong(Song? song)
    {
        CurrentSong = song;
        _loopHandler.UpdateCurrentSong(song);
        Debug.WriteLine($"[PlaybackEngineCoordinator] SetSong: {song?.Title ?? "null"}");
    }

    public bool Load(string filePath, float rate, float pitch)
    {
        Debug.WriteLine($"[PlaybackEngineCoordinator] Load called for: {Path.GetFileName(filePath)}");
        try
        {
            _engineController.PlaybackRate = rate;
            _engineController.PitchSemitones = pitch;
            _engineController.Load(filePath);
            return true;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[PlaybackEngineCoordinator] Error loading: {ex.Message}");
            return false;
        }
    }

    public void Play(bool startMonitor)
    {
        if (CurrentSong == null)
        {
            Debug.WriteLine("[PlaybackEngineCoordinator] Play called but no current song. Aborting.");
            return;
        }

        TimeSpan initialPosition = _loopHandler.GetInitialPlaybackPosition(_engineController.CurrentSongDuration);
        if (initialPosition > TimeSpan.Zero && initialPosition < _engineController.CurrentSongDuration)
        {
            _engineController.Seek(initialPosition);
        }
        _engineController.Play();
        if (startMonitor)
        {
            _playbackMonitor.Start(CurrentSong, OnMonitorPositionUpdate);
        }
        Debug.WriteLine($"[PlaybackEngineCoordinator] Play initiated for {CurrentSong.Title}. Monitor started: {startMonitor}");
    }

    public void Pause()
    {
        _playbackMonitor.Stop();
        _engineController.Pause();
        Debug.WriteLine("[PlaybackEngineCoordinator] Pause initiated.");
    }

    public void Resume(bool startMonitor)
    {
        if (CurrentSong == null)
        {
            Debug.WriteLine("[PlaybackEngineCoordinator] Resume called but no current song. Aborting.");
            return;
        }
        _engineController.Play(); // NAudio handles resuming from paused or re-playing from stopped if applicable
        if (startMonitor)
        {
            _playbackMonitor.Start(CurrentSong, OnMonitorPositionUpdate);
        }
        Debug.WriteLine($"[PlaybackEngineCoordinator] Resume initiated for {CurrentSong.Title}. Monitor started: {startMonitor}");
    }

    public void Stop()
    {
        _playbackMonitor.Stop();
        _engineController.Stop(); // This will trigger the EnginePlaybackStopped event
        Debug.WriteLine("[PlaybackEngineCoordinator] Stop initiated.");
    }

    public void DisposeCurrentEngineInternals()
    {
        _playbackMonitor.Stop(); // Stop monitor before disposing engine
        _engineController.Dispose(); // Changed from DisposeEngineInternalsOnly
        Debug.WriteLine("[PlaybackEngineCoordinator] Disposed current engine internals.");
    }

    public void Seek(TimeSpan requestedPosition)
    {
        if (CurrentSong == null || _engineController.CurrentSongDuration == TimeSpan.Zero) return;

        TimeSpan targetPosition = _loopHandler.GetAdjustedSeekPosition(requestedPosition, _engineController.CurrentSongDuration);

        var totalMs = _engineController.CurrentSongDuration.TotalMilliseconds;
        var seekMarginMs = totalMs > 200 ? 100 : (totalMs > 0 ? Math.Min(totalMs / 2, 50) : 0);
        var maxSeekablePosition = TimeSpan.FromMilliseconds(totalMs - seekMarginMs);
        if (maxSeekablePosition < TimeSpan.Zero) maxSeekablePosition = TimeSpan.Zero;

        targetPosition = TimeSpan.FromSeconds(Math.Clamp(targetPosition.TotalSeconds, 0, maxSeekablePosition.TotalSeconds));

        _engineController.Seek(targetPosition);
        Debug.WriteLine($"[PlaybackEngineCoordinator] Seek to {targetPosition} initiated.");

        // If not playing, the monitor won't update position, so fire an event manually
        if (_engineController.CurrentPlaybackStatus != PlaybackStateStatus.Playing)
        {
            OnMonitorPositionUpdate(_engineController.CurrentPosition, _engineController.CurrentSongDuration);
        }
    }

    public void UpdateRateAndPitch(float rate, float pitch)
    {
        _engineController.PlaybackRate = rate;
        _engineController.PitchSemitones = pitch;
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (_disposed) return;

        if (disposing)
        {
            Debug.WriteLine("[PlaybackEngineCoordinator] Dispose called.");
            _playbackMonitor?.Dispose();
            if (_engineController is not null)
            {
                _engineController.PlaybackStopped -= OnEngineControllerPlaybackStoppedRelay;
                _engineController.Dispose();
            }
            // _loopHandler is not owned by PlaybackEngineCoordinator, so it's not disposed here.
            // Its lifecycle is managed by PlaybackService.
            Debug.WriteLine("[PlaybackEngineCoordinator] Dispose completed.");
        }
        _disposed = true;
    }

    ~PlaybackEngineCoordinator()
    {
        Dispose(false);
    }
}

// Helper class for event arguments
public class PositionEventArgs(TimeSpan position, TimeSpan duration) : EventArgs
{
    public TimeSpan Position { get; } = position;
    public TimeSpan Duration { get; } = duration;
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\Playback\PlaybackFlowManagerService.cs">
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Sonorize.Models;
using Sonorize.ViewModels;

namespace Sonorize.Services;

public class PlaybackFlowManagerService
{
    private readonly LibraryViewModel _libraryViewModel;
    private readonly PlaybackViewModel _playbackViewModel;
    private readonly PlaybackService _playbackService;
    private readonly NextTrackSelectorService _nextTrackSelectorService;

    public PlaybackFlowManagerService(
        LibraryViewModel libraryViewModel,
        PlaybackViewModel playbackViewModel,
        PlaybackService playbackService,
        NextTrackSelectorService nextTrackSelectorService)
    {
        _libraryViewModel = libraryViewModel ?? throw new System.ArgumentNullException(nameof(libraryViewModel));
        _playbackViewModel = playbackViewModel ?? throw new System.ArgumentNullException(nameof(playbackViewModel));
        _playbackService = playbackService ?? throw new System.ArgumentNullException(nameof(playbackService));
        _nextTrackSelectorService = nextTrackSelectorService ?? throw new System.ArgumentNullException(nameof(nextTrackSelectorService));
    }

    public void HandlePlaybackEndedNaturally()
    {
        Debug.WriteLine("[PlaybackFlowManager] HandlePlaybackEndedNaturally called.");

        Song? currentSong = _libraryViewModel.SelectedSong;
        List<Song> currentList = [.. _libraryViewModel.FilteredSongs];
        RepeatMode repeatMode = _playbackViewModel.ModeControls.RepeatMode; // Corrected access
        bool shuffleEnabled = _playbackViewModel.ModeControls.ShuffleEnabled; // Corrected access

        Song? nextSong = _nextTrackSelectorService.GetNextSong(currentSong, currentList, repeatMode, shuffleEnabled);

        if (nextSong is not null)
        {
            Debug.WriteLine($"[PlaybackFlowManager] Next song determined: {nextSong.Title}. Setting Library.SelectedSong.");
            _libraryViewModel.SelectedSong = nextSong;
        }
        else
        {
            Debug.WriteLine("[PlaybackFlowManager] No next song determined. Calling PlaybackService.Stop().");
            _playbackService.Stop();
        }

        Debug.WriteLine("[PlaybackFlowManager] HandlePlaybackEndedNaturally completed.");
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\Playback\PlaybackInfrastructureProvider.cs">
using System;
using System.Diagnostics;

namespace Sonorize.Services.Playback;

public class PlaybackInfrastructureProvider : IDisposable
{
    public NAudioPlaybackEngine EngineController { get; } // Changed type
    public PlaybackMonitor Monitor { get; }
    public PlaybackEngineCoordinator Coordinator { get; }

    private bool _disposed = false;

    public PlaybackInfrastructureProvider(PlaybackLoopHandler loopHandler)
    {
        ArgumentNullException.ThrowIfNull(loopHandler);

        EngineController = new NAudioPlaybackEngine(); // Changed instantiation
        Monitor = new PlaybackMonitor(EngineController, loopHandler);
        Coordinator = new PlaybackEngineCoordinator(EngineController, loopHandler, Monitor);

        Debug.WriteLine("[PlaybackInfrastructureProvider] Initialized and components created.");
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (_disposed)
        {
            return;
        }

        if (disposing)
        {
            Debug.WriteLine("[PlaybackInfrastructureProvider] Disposing components.");
            Coordinator?.Dispose();
            // EngineController is disposed by Coordinator if Coordinator owns it,
            // or needs to be disposed here if not fully owned by Coordinator.
            // Given Coordinator takes it, Coordinator should dispose it.
            // If EngineController was created and owned here, then: EngineController?.Dispose();
            // Current Coordinator.Dispose() disposes its _engineController.
        }

        _disposed = true;

        Debug.WriteLine("[PlaybackInfrastructureProvider] Dispose finished.");
    }

    ~PlaybackInfrastructureProvider()
    {
        Dispose(false);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\Playback\PlaybackLoopHandler.cs">
using System;
using System.Diagnostics;
using Sonorize.Models;

namespace Sonorize.Services;

/// <summary>
/// Handles loop region logic for playback, including checking for loop boundaries
/// during playback and adjusting seek positions.
/// </summary>
public class PlaybackLoopHandler : IDisposable // Implementing IDisposable for consistency, though no explicit unmanaged resources are held here.
{
    private readonly PlaybackService _playbackService; // Reference back to the PlaybackService
    private Song? _currentSong; // Keep a reference to the current song

    public PlaybackLoopHandler(PlaybackService playbackService)
    {
        _playbackService = playbackService ?? throw new ArgumentNullException(nameof(playbackService));
        Debug.WriteLine("[LoopHandler] Constructor called.");
        // No need to subscribe to PlaybackService events here; PlaybackService pushes data via method calls.
    }

    /// <summary>
    /// Updates the internal reference to the current song.
    /// Called by PlaybackService when CurrentSong changes.
    /// </summary>
    /// <param name="song">The new current song, or null.</param>
    internal void UpdateCurrentSong(Song? song)
    {
        _currentSong = song;
        Debug.WriteLine($"[LoopHandler] CurrentSong updated to: {_currentSong?.Title ?? "null"}");
        // The handler doesn't need to manage song.IsLoopActive persistence; that's handled by the ViewModel.
        // It just needs to *read* the Song's SavedLoop and IsLoopActive properties.
    }

    /// <summary>
    /// Checks if the current position is within an active loop region and triggers a seek if the end is reached.
    /// Called periodically by the PlaybackService UI update timer.
    /// </summary>
    /// <param name="currentPosition">The current playback position.</param>
    /// <param name="totalDuration">The total duration of the song.</param>
    internal void CheckForLoopSeek(TimeSpan currentPosition, TimeSpan totalDuration)
    {
        // Ensure we have a song, it has a saved loop, and the loop is active
        if (_currentSong?.SavedLoop is not null && _currentSong.IsLoopActive)
        {
            var loop = _currentSong.SavedLoop;

            // Ensure loop end is after loop start and valid within total time
            if (loop.End > loop.Start && loop.End <= totalDuration)
            {
                // Check if current position is at or past the loop end
                // Using a small tolerance (e.g., 50ms) to trigger seek slightly before the exact end,
                // but ensure it's not extremely close to the *total* song duration.
                TimeSpan seekThreshold = loop.End - TimeSpan.FromMilliseconds(50);
                if (currentPosition >= seekThreshold && currentPosition < totalDuration - TimeSpan.FromMilliseconds(200))
                {
                    Debug.WriteLine($"[LoopHandler] Loop active & end reached ({currentPosition:mm\\:ss\\.ff} >= {seekThreshold:mm\\:ss\\.ff}) within file ({totalDuration:mm\\:ss\\.ff}). Requesting seek to loop start: {loop.Start:mm\\:ss\\.ff}");
                    // Request seek back to the loop start via the PlaybackService
                    // This call will come back into PlaybackService.Seek, which will use GetAdjustedSeekPosition,
                    // but since the target is *exactly* loop.Start, GetAdjustedSeekPosition should return loop.Start.
                    _playbackService.Seek(loop.Start);
                    // Note: The Seek method itself has a tolerance to prevent seeking if already very close.
                    // If currentPosition is already at or very near loop.Start (e.g., due to seek tolerance issues),
                    // this check might not trigger a redundant seek.
                }
                // If currentPosition is >= loop.End but also very close to totalDuration,
                // we let the natural end-of-file event trigger (handled by PlaybackService).
            }
            else if (_currentSong.IsLoopActive)
            {
                Debug.WriteLine($"[LoopHandler] Loop active for {_currentSong.Title} but invalid region ({loop.Start:mm\\:ss\\.ff} - {loop.End:mm\\:ss\\.ff}). Loop will not function.");
            }
        }
    }

    /// <summary>
    /// Adjusts a requested seek position based on the currently active loop region.
    /// Called by PlaybackService before performing a seek.
    /// </summary>
    /// <param name="requestedPosition">The position requested by the caller (e.g., UI slider, previous/next logic).</param>
    /// <param name="totalDuration">The total duration of the song.</param>
    /// <returns>The adjusted position, potentially snapped to the loop start.</returns>
    internal TimeSpan GetAdjustedSeekPosition(TimeSpan requestedPosition, TimeSpan totalDuration)
    {
        TimeSpan targetPosition = requestedPosition;

        // Apply loop region constraints if an active loop is defined for the current song.
        // If seeking *into* an active loop from *outside* its start or after its end, snap to start.
        // If seeking *within* an active loop, allow it.
        if (_currentSong?.SavedLoop is not null && _currentSong.IsLoopActive)
        {
            var loop = _currentSong.SavedLoop;
            Debug.WriteLine($"[LoopHandler] GetAdjustedSeekPosition: Active loop detected [{loop.Start:mm\\:ss\\.ff}-{loop.End:mm\\:ss\\.ff}). Requested: {requestedPosition:mm\\:ss\\.ff}");

            // Ensure loop end is after loop start and valid within total time
            if (loop.End > loop.Start && loop.End <= totalDuration)
            {
                // If the target position is outside the loop's bounds [loop.Start, loop.End),
                // snap the target position to the loop's start time.
                if (targetPosition < loop.Start || targetPosition >= loop.End)
                {
                    Debug.WriteLine($"[LoopHandler] GetAdjustedSeekPosition: Target {targetPosition:mm\\:ss\\.ff} is outside loop bounds. Snapping to loop start: {loop.Start:mm\\:ss\\.ff}.");
                    targetPosition = loop.Start;
                }
                // If targetPosition is within [loop.Start, loop.End), allow normal seek within the loop.
                else
                {
                    Debug.WriteLine($"[LoopHandler] GetAdjustedSeekPosition: Target {targetPosition:mm\\:ss\\.ff} is within loop bounds. Allowing seek.");
                }
            }
            else if (_currentSong.IsLoopActive)
            {
                Debug.WriteLine($"[LoopHandler] GetAdjustedSeekPosition: Loop active but invalid region ({loop.Start:mm\\:ss\\.ff} - {loop.End:mm\\:ss\\.ff}). Not applying loop seek constraints.");
            }
        }
        else
        {
            Debug.WriteLine("[LoopHandler] GetAdjustedSeekPosition: No active loop. No adjustment needed.");
        }

        return targetPosition;
    }

    /// <summary>
    /// Determines the initial playback position when a new song is loaded.
    /// Returns the loop start if a loop is active, otherwise returns TimeSpan.Zero.
    /// Called by PlaybackService.Play().
    /// </summary>
    /// <param name="totalDuration">The total duration of the song.</param>
    /// <returns>The initial playback position.</returns>
    internal TimeSpan GetInitialPlaybackPosition(TimeSpan totalDuration)
    {
        if (_currentSong?.SavedLoop is not null && _currentSong.IsLoopActive)
        {
            var loop = _currentSong.SavedLoop;
            // Ensure loop start is valid before returning it
            if (loop.Start >= TimeSpan.Zero && loop.Start < totalDuration)
            {
                Debug.WriteLine($"[LoopHandler] GetInitialPlaybackPosition: Active loop found. Starting at loop start: {loop.Start:mm\\:ss\\.ff}");
                return loop.Start;
            }
            else
            {
                Debug.WriteLine($"[LoopHandler] GetInitialPlaybackPosition: Active loop found, but loop start is invalid ({loop.Start >= totalDuration}). Starting from beginning.");
                return TimeSpan.Zero;
            }
        }
        Debug.WriteLine("[LoopHandler] GetInitialPlaybackPosition: No active loop. Starting from beginning.");
        return TimeSpan.Zero; // Start from the beginning if no active loop
    }


    public void Dispose()
    {
        Debug.WriteLine("[LoopHandler] Dispose() called.");
        // This class doesn't currently hold any resources that need explicit disposal.
        // Nullifying the song reference for cleanliness.
        _currentSong = null;
        Debug.WriteLine("[LoopHandler] Dispose() completed.");
    }

    // Finalizer not strictly needed as no unmanaged resources are held,
    // but included for consistency if needed later.
    ~PlaybackLoopHandler()
    {
        Debug.WriteLine("[LoopHandler] Finalizer called.");
        Dispose(false);
        Debug.WriteLine("[LoopHandler] Finalizer completed.");
    }
    // Protected virtual Dispose is standard pattern, though not strictly needed if no unmanaged resources
    protected virtual void Dispose(bool disposing)
    {
        // No specific managed or unmanaged resources to free here.
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\Playback\PlaybackMonitor.cs">
using System;
using System.Diagnostics;
using System.Threading;
using Avalonia.Threading;
using Sonorize.Models;

namespace Sonorize.Services.Playback;

public class PlaybackMonitor : IDisposable
{
    private readonly NAudioPlaybackEngine _engineController; // Changed type
    private readonly PlaybackLoopHandler _loopHandler;
    private Timer? _monitorTimer;
    private Song? _songBeingMonitored;
    private Action<TimeSpan, TimeSpan>? _positionUpdateAction;
    private int _notPlayingCounter;

    private const int MonitorIntervalMilliseconds = 100;
    private const int NotPlayingToleranceTicks = 5; // 5 * 100ms = 500ms tolerance


    public PlaybackMonitor(NAudioPlaybackEngine engineController, PlaybackLoopHandler loopHandler) // Changed type
    {
        _engineController = engineController ?? throw new ArgumentNullException(nameof(engineController));
        _loopHandler = loopHandler ?? throw new ArgumentNullException(nameof(loopHandler));
        Debug.WriteLine("[PlaybackMonitor] Initialized.");
    }

    public void Start(Song? songToMonitor, Action<TimeSpan, TimeSpan> positionUpdateAction)
    {
        Stop();

        _songBeingMonitored = songToMonitor;
        _positionUpdateAction = positionUpdateAction ?? throw new ArgumentNullException(nameof(positionUpdateAction));
        _notPlayingCounter = 0;


        if (_songBeingMonitored is null)
        {
            Debug.WriteLine("[PlaybackMonitor] Start called, but songToMonitor is null. Monitoring will not proceed effectively.");
            // It might still run the timer but the callback will likely stop it.
        }

        _monitorTimer = new Timer(MonitorCallback, null, TimeSpan.Zero, TimeSpan.FromMilliseconds(MonitorIntervalMilliseconds));
        Debug.WriteLine($"[PlaybackMonitor] Started monitoring for: {_songBeingMonitored?.Title ?? "No Song"}");
    }

    public void Stop()
    {
        if (_monitorTimer is not null)
        {
            _monitorTimer.Change(Timeout.Infinite, Timeout.Infinite);
            _monitorTimer.Dispose();
            _monitorTimer = null;
            Debug.WriteLine($"[PlaybackMonitor] Stopped monitoring for: {_songBeingMonitored?.Title ?? "Previously Monitored Song"}");
        }
        _songBeingMonitored = null; // Clear the song being monitored
        _positionUpdateAction = null; // Clear the callback
    }

    private void MonitorCallback(object? state)
    {
        Song? localSongBeingMonitored = _songBeingMonitored; // Capture for thread safety
        Action<TimeSpan, TimeSpan>? localPositionUpdateAction = _positionUpdateAction; // Capture for thread safety

        if (localSongBeingMonitored is null || localPositionUpdateAction is null)
        {
            Debug.WriteLine("[PlaybackMonitor Callback] Song or position update action is null. Stopping timer.");
            Dispatcher.UIThread.InvokeAsync(Stop); // Stop on UI thread to ensure proper disposal if needed
            return;
        }

        // This check should be done on the UI thread if it involves UI-bound properties like PlaybackService.CurrentSong
        // However, here we are just checking against the _songBeingMonitored which was set at Start()
        // The critical part is that the PlaybackEngineController is still for this song.
        // PlaybackService's CurrentSong might change, causing this monitor to be stopped externally.

        if (_engineController.CurrentPlaybackStatus != PlaybackStateStatus.Playing)
        {
            _notPlayingCounter++;
            if (_notPlayingCounter > NotPlayingToleranceTicks)
            {
                Debug.WriteLine($"[PlaybackMonitor Callback] Engine not playing for {NotPlayingToleranceTicks} ticks (State: {_engineController.CurrentPlaybackStatus}). Stopping monitoring for '{localSongBeingMonitored.Title}'.");
                Dispatcher.UIThread.InvokeAsync(Stop);
            }
            return;
        }

        _notPlayingCounter = 0; // Reset counter if playing


        Dispatcher.UIThread.InvokeAsync(() =>
        {
            // Re-check conditions on UI thread before acting, in case state changed during invoke
            if (_songBeingMonitored != localSongBeingMonitored || _positionUpdateAction != localPositionUpdateAction || _engineController.CurrentPlaybackStatus != PlaybackStateStatus.Playing)
            {
                // If the song being monitored has changed since the callback was scheduled, or monitor was stopped.
                return;
            }

            var currentAudioTime = TimeSpan.Zero;
            var songDuration = TimeSpan.Zero;

            try
            {
                currentAudioTime = _engineController.CurrentPosition;
                songDuration = _engineController.CurrentSongDuration;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[PlaybackMonitor] Error getting EngineController.CurrentPosition/Duration in timer callback for '{localSongBeingMonitored.Title}': {ex.Message}. Stopping timer.");
                Stop(); // Stop self
                return;
            }

            localPositionUpdateAction(currentAudioTime, songDuration);
            _loopHandler.CheckForLoopSeek(currentAudioTime, songDuration);
        });
    }

    public void Dispose()
    {
        Debug.WriteLine("[PlaybackMonitor] Dispose called.");
        Stop(); // Ensure timer is stopped and disposed
        GC.SuppressFinalize(this);
        Debug.WriteLine("[PlaybackMonitor] Dispose finished.");
    }

    ~PlaybackMonitor()
    {
        Debug.WriteLine("[PlaybackMonitor] Finalizer called.");
        Dispose(); // Call the same dispose logic
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\Playback\PlaybackResourceInterlockService.cs">
using System;
using System.Diagnostics;
using Sonorize.Models;

namespace Sonorize.Services.Playback;

public class PlaybackResourceInterlockService
{
    private readonly PlaybackSessionManager _sessionManager;

    public PlaybackResourceInterlockService(PlaybackSessionManager sessionManager)
    {
        _sessionManager = sessionManager ?? throw new ArgumentNullException(nameof(sessionManager));
        Debug.WriteLine("[PlaybackResourceInterlockService] Initialized.");
    }

    public (bool WasPlaying, TimeSpan Position)? PrepareForExternalOperation(Song song)
    {
        if (song is null)
        {
            Debug.WriteLine("[InterlockService] PrepareForExternalOperation: Song is null. No action.");
            return null;
        }

        if (_sessionManager.CurrentSong != song)
        {
            Debug.WriteLine($"[InterlockService] PrepareForExternalOperation: Song '{song.Title}' is not the current song ('{_sessionManager.CurrentSong?.Title}'). No action taken.");
            return null;
        }

        bool wasPlaying = _sessionManager.IsPlaying;
        TimeSpan position = _sessionManager.CurrentPosition;

        Debug.WriteLine($"[InterlockService] Preparing for external operation on '{song.Title}'. WasPlaying: {wasPlaying}, Position: {position}. Forcing engine release.");
        _sessionManager.ForceReleaseEngineForCurrentSong();

        return (wasPlaying, position);
    }

    public bool ResumeAfterExternalOperation(Song song, TimeSpan position, bool play)
    {
        if (song is null)
        {
            Debug.WriteLine("[InterlockService] ResumeAfterExternalOperation: Song is null. Cannot resume.");
            return false;
        }

        Debug.WriteLine($"[InterlockService] Resuming after external operation for '{song.Title}'. Position: {position}, Play: {play}. Forcing reload.");
        return _sessionManager.ForceReloadAndPlayEngine(song, position, play);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\Playback\PlaybackService.cs">
using System;
using System.ComponentModel;
using System.Diagnostics;
using Sonorize.Models;
using Sonorize.Services.Playback;
using Sonorize.ViewModels; // For ViewModelBase, if still needed (likely)

namespace Sonorize.Services;

public enum PlaybackStateStatus { Stopped, Playing, Paused } // This enum might be better placed in a shared Models namespace if used by ViewModels too

public class PlaybackService : ViewModelBase, IDisposable
{
    private readonly PlaybackSessionManager _sessionManager;
    private readonly PlaybackLoopHandler _loopHandler; // Keep loop handler if it needs PlaybackService context
    private readonly ScrobblingService _scrobblingService; // Added to perform final scrobble

    // Properties that mirror PlaybackSessionManager's state
    public Song? CurrentSong => _sessionManager.CurrentSong;
    public bool HasCurrentSong => _sessionManager.HasCurrentSong;
    public bool IsPlaying => _sessionManager.IsPlaying;
    public PlaybackStateStatus CurrentPlaybackStatus => _sessionManager.CurrentPlaybackStatus;
    public TimeSpan CurrentPosition => _sessionManager.CurrentPosition;
    public double CurrentPositionSeconds => _sessionManager.CurrentPositionSeconds;
    public TimeSpan CurrentSongDuration => _sessionManager.CurrentSongDuration;
    public double CurrentSongDurationSeconds => _sessionManager.CurrentSongDurationSeconds;

    public float PlaybackRate
    {
        get => _sessionManager.PlaybackRate;
        set => _sessionManager.PlaybackRate = value;
    }

    public float PitchSemitones
    {
        get => _sessionManager.PitchSemitones;
        set => _sessionManager.PitchSemitones = value;
    }

    public event EventHandler? PlaybackEndedNaturally
    {
        add => _sessionManager.SessionEndedNaturally += value;
        remove => _sessionManager.SessionEndedNaturally -= value;
    }

    // Expose PlaybackSessionManager for PlaybackResourceInterlockService
    internal PlaybackSessionManager SessionManager => _sessionManager;


    public PlaybackService(ScrobblingService scrobblingService, PlayCountDataService playCountDataService)
    {
        Debug.WriteLine("[PlaybackService] Constructor called.");
        _scrobblingService = scrobblingService;
        _loopHandler = new PlaybackLoopHandler(this);
        _sessionManager = new PlaybackSessionManager(scrobblingService, _loopHandler, playCountDataService);
        _sessionManager.PropertyChanged += SessionManager_PropertyChanged;
    }

    private void SessionManager_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        OnPropertyChanged(e.PropertyName);
        if (e.PropertyName == nameof(PlaybackSessionManager.CurrentSong))
        {
            OnPropertyChanged(nameof(HasCurrentSong));
        }
    }

    public void Play(Song song)
    {
        Debug.WriteLine($"[PlaybackService facade] Play requested for: {(song?.Title ?? "null song")}");
        _sessionManager.StartNewSession(song);
    }

    public void Pause()
    {
        Debug.WriteLine($"[PlaybackService facade] Pause requested.");
        _sessionManager.PauseSession();
    }

    public void Resume()
    {
        Debug.WriteLine($"[PlaybackService facade] Resume requested.");
        _sessionManager.ResumeSession();
    }

    public void Stop()
    {
        Debug.WriteLine("[PlaybackService facade] Public Stop() called.");
        _sessionManager.StopSession(isExplicit: true);
    }

    public void Seek(TimeSpan requestedPosition)
    {
        if (CurrentSong == null || CurrentSongDuration == TimeSpan.Zero)
        {
            Debug.WriteLine($"[PlaybackService facade] Seek ignored: No current song or duration is zero.");
            return;
        }
        _sessionManager.SeekSession(requestedPosition);
    }

    internal void PerformSeekInternal(TimeSpan position)
    {
        Seek(position);
    }


    public void Dispose()
    {
        Debug.WriteLine("[PlaybackService] Dispose() called on shutdown.");

        if (_sessionManager is not null)
        {
            _sessionManager.PropertyChanged -= SessionManager_PropertyChanged;
            _sessionManager.Dispose();
        }
        _loopHandler?.Dispose();
        GC.SuppressFinalize(this);
        Debug.WriteLine("[PlaybackService] Dispose() completed.");
    }

    ~PlaybackService()
    {
        Dispose();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\Playback\PlaybackSessionLoader.cs">
using System;
using System.Diagnostics;
using System.IO;
using Sonorize.Models;

namespace Sonorize.Services.Playback;

public class PlaybackSessionLoader
{
    private readonly PlaybackEngineCoordinator _playbackEngineCoordinator;
    private readonly PlaybackSessionState _sessionState;
    private readonly ScrobblingService _scrobblingService;

    public PlaybackSessionLoader(
        PlaybackEngineCoordinator playbackEngineCoordinator,
        PlaybackSessionState sessionState,
        ScrobblingService scrobblingService)
    {
        _playbackEngineCoordinator = playbackEngineCoordinator ?? throw new ArgumentNullException(nameof(playbackEngineCoordinator));
        _sessionState = sessionState ?? throw new ArgumentNullException(nameof(sessionState));
        _scrobblingService = scrobblingService ?? throw new ArgumentNullException(nameof(scrobblingService));
    }

    public bool LoadNewSession(Song song)
    {
        Debug.WriteLine($"[PlaybackSessionLoader] LoadNewSession for: {song.Title}");
        _sessionState.CurrentSong = song;
        _playbackEngineCoordinator.SetSong(song);

        try
        {
            if (!_playbackEngineCoordinator.Load(song.FilePath, _sessionState.PlaybackRate, _sessionState.PitchSemitones))
            {
                Debug.WriteLine($"[PlaybackSessionLoader] EngineCoordinator.Load failed for {song.Title}.");
                _sessionState.CurrentSong = null; // Clear song on failure
                return false;
            }
            UpdateSessionTimingsPostLoad();
            _playbackEngineCoordinator.Play(startMonitor: true);
            _sessionState.IsPlaying = true;
            _sessionState.CurrentPlaybackStatus = PlaybackStateStatus.Playing;
            _ = _scrobblingService.UpdateNowPlayingAsync(song);
            return true;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[PlaybackSessionLoader] Exception during LoadNewSession for '{song.FilePath}': {ex}");
            if (_sessionState.CurrentSong is not null) _playbackEngineCoordinator.Stop(); // Ensure engine is stopped if partially loaded
            _sessionState.CurrentSong = null;
            return false;
        }
    }

    public bool ReloadSession(Song song, TimeSpan position, bool shouldBePlaying)
    {
        Debug.WriteLine($"[PlaybackSessionLoader] ReloadSession for: {song.Title}, Position: {position}, ShouldPlay: {shouldBePlaying}");
        _sessionState.CurrentSong = song;
        _playbackEngineCoordinator.SetSong(song);

        try
        {
            if (!_playbackEngineCoordinator.Load(song.FilePath, _sessionState.PlaybackRate, _sessionState.PitchSemitones))
            {
                Debug.WriteLine($"[PlaybackSessionLoader] EngineCoordinator.Load failed during ReloadSession for {song.Title}.");
                _sessionState.CurrentSong = null;
                _sessionState.IsPlaying = false;
                _sessionState.CurrentPlaybackStatus = PlaybackStateStatus.Stopped;
                return false;
            }

            UpdateSessionTimingsPostLoad(position);
            _playbackEngineCoordinator.Seek(position);

            if (shouldBePlaying)
            {
                _playbackEngineCoordinator.Play(startMonitor: true);
                _sessionState.IsPlaying = true;
                _sessionState.CurrentPlaybackStatus = PlaybackStateStatus.Playing;
                _ = _scrobblingService.UpdateNowPlayingAsync(song);
            }
            else
            {
                _sessionState.IsPlaying = false;
                _sessionState.CurrentPlaybackStatus = PlaybackStateStatus.Paused; // Or Stopped if preferred when not playing
            }
            return true;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[PlaybackSessionLoader] Exception during ReloadSession for '{song.FilePath}': {ex}");
            _sessionState.CurrentSong = null;
            _sessionState.IsPlaying = false;
            _sessionState.CurrentPlaybackStatus = PlaybackStateStatus.Stopped;
            return false;
        }
    }

    private void UpdateSessionTimingsPostLoad(TimeSpan? initialPosition = null)
    {
        _sessionState.CurrentPosition = initialPosition ?? TimeSpan.Zero;
        _sessionState.CurrentSongDuration = _playbackEngineCoordinator.CurrentSongDuration;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\Playback\PlaybackSessionManager.cs">
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using NAudio.Wave; // For StoppedEventArgs
using Sonorize.Models;

namespace Sonorize.Services.Playback;

public class PlaybackSessionManager : INotifyPropertyChanged, IDisposable
{
    private readonly PlaybackLoopHandler _loopHandler;
    private readonly PlaybackCompletionHandler _completionHandler;
    private readonly ScrobblingService _scrobblingService;
    private readonly PlaybackSessionState _sessionState;
    private readonly PlayCountDataService _playCountDataService;

    private PlaybackInfrastructureProvider? _currentInfrastructure;
    private bool _hasBeenScrobbledThisSession = false; // New flag for threshold-based scrobbling
    private bool _hasBeenCountedAsPlayedThisSession = false;


    // Delegated Properties to PlaybackSessionState
    public Song? CurrentSong => _sessionState.CurrentSong;
    public bool HasCurrentSong => _sessionState.HasCurrentSong;
    public bool IsPlaying => _sessionState.IsPlaying;
    public PlaybackStateStatus CurrentPlaybackStatus => _sessionState.CurrentPlaybackStatus;
    public TimeSpan CurrentPosition => _sessionState.CurrentPosition;
    public double CurrentPositionSeconds => _sessionState.CurrentPositionSeconds;
    public TimeSpan CurrentSongDuration => _sessionState.CurrentSongDuration;
    public double CurrentSongDurationSeconds => _sessionState.CurrentSongDurationSeconds;

    public float PlaybackRate
    {
        get => _sessionState.PlaybackRate;
        set
        {
            if (_sessionState.PlaybackRate == value) return;
            _sessionState.PlaybackRate = value;
            _currentInfrastructure?.Coordinator.UpdateRateAndPitch(value, PitchSemitones);
        }
    }

    public float PitchSemitones
    {
        get => _sessionState.PitchSemitones;
        set
        {
            if (_sessionState.PitchSemitones == value) return;
            _sessionState.PitchSemitones = value;
            _currentInfrastructure?.Coordinator.UpdateRateAndPitch(PlaybackRate, value);
        }
    }

    private volatile bool _explicitStopRequested = false;

    public event PropertyChangedEventHandler? PropertyChanged;
    public event EventHandler? SessionEndedNaturally;

    public PlaybackSessionManager(ScrobblingService scrobblingService, PlaybackLoopHandler loopHandler, PlayCountDataService playCountDataService)
    {
        _scrobblingService = scrobblingService ?? throw new ArgumentNullException(nameof(scrobblingService));
        _loopHandler = loopHandler ?? throw new ArgumentNullException(nameof(loopHandler));
        _playCountDataService = playCountDataService ?? throw new ArgumentNullException(nameof(playCountDataService));
        _sessionState = new PlaybackSessionState();
        _sessionState.PropertyChanged += SessionState_PropertyChanged;
        _completionHandler = new PlaybackCompletionHandler(this, _scrobblingService);
        Debug.WriteLine("[PlaybackSessionManager] Initialized.");
    }

    private void SessionState_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        OnPropertyChanged(e.PropertyName!);
    }

    private void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }

    public bool StartNewSession(Song song)
    {
        Debug.WriteLine($"[SessionManager] StartNewSession requested for: {(song?.Title ?? "null song")}");

        // --- Step 1: Detach and schedule the stop for the old infrastructure ---
        var oldInfrastructure = _currentInfrastructure;
        if (oldInfrastructure is not null)
        {
            // Detach main handlers so they don't fire for the old instance anymore
            oldInfrastructure.Coordinator.EnginePlaybackStopped -= OnEngineCoordinatorPlaybackStopped;
            oldInfrastructure.Coordinator.EnginePositionUpdated -= OnEngineCoordinatorPositionUpdated;

            // Capture the complete state of the outgoing song
            var songThatStopped = oldInfrastructure.Coordinator.CurrentSong;
            var positionThatStopped = oldInfrastructure.Coordinator.CurrentPosition;
            var durationThatStopped = oldInfrastructure.Coordinator.CurrentSongDuration;

            Debug.WriteLine($"[SessionManager] Scheduling stop for previous song '{songThatStopped?.Title}' at {positionThatStopped}.");

            // Attach a new, one-time handler to the old infrastructure.
            // This closure captures the song's final state and will execute when the old engine finally stops.
            oldInfrastructure.Coordinator.EnginePlaybackStopped += (s, e) =>
            {
                Debug.WriteLine($"[SessionManager] One-time stop handler fired for old song: '{songThatStopped?.Title}'.");
                _completionHandler.Handle(e, songThatStopped, positionThatStopped, durationThatStopped, wasExplicitlyStopped: false, isInternalStopForSongChange: true);
                oldInfrastructure.Dispose(); // Clean up the old infrastructure completely.
            };
            oldInfrastructure.Coordinator.Stop();
        }

        // --- Step 2: Validate new song ---
        if (song == null || string.IsNullOrEmpty(song.FilePath) || !File.Exists(song.FilePath))
        {
            Debug.WriteLine("[SessionManager] New song is null or invalid. Session will be stopped.");
            FinalizeCurrentSong(null);
            return false;
        }

        // --- Step 3: Create and start the new infrastructure ---
        try
        {
            _hasBeenScrobbledThisSession = false; // Reset scrobble flag for the new session.
            _hasBeenCountedAsPlayedThisSession = false;
            _currentInfrastructure = new PlaybackInfrastructureProvider(_loopHandler);
            _currentInfrastructure.Coordinator.EnginePlaybackStopped += OnEngineCoordinatorPlaybackStopped;
            _currentInfrastructure.Coordinator.EnginePositionUpdated += OnEngineCoordinatorPositionUpdated;

            var sessionLoader = new PlaybackSessionLoader(_currentInfrastructure.Coordinator, _sessionState, _scrobblingService);
            bool result = sessionLoader.LoadNewSession(song);
            if (!result)
            {
                _currentInfrastructure.Dispose();
                _currentInfrastructure = null;
                FinalizeCurrentSong(null);
            }
            return result;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[SessionManager] CRITICAL: Exception creating new playback infrastructure: {ex}");
            _currentInfrastructure?.Dispose();
            _currentInfrastructure = null;
            FinalizeCurrentSong(null);
            return false;
        }
    }

    public void PauseSession()
    {
        if (IsPlaying)
        {
            _currentInfrastructure?.Coordinator.Pause();
            SetPlaybackState(false, PlaybackStateStatus.Paused);
        }
    }

    public void ResumeSession()
    {
        if (CurrentSong == null) return;
        if (CurrentPlaybackStatus == PlaybackStateStatus.Paused)
        {
            _currentInfrastructure?.Coordinator.Resume(startMonitor: true);
            SetPlaybackState(true, PlaybackStateStatus.Playing);
            _ = _scrobblingService.UpdateNowPlayingAsync(CurrentSong);
        }
        else if (CurrentPlaybackStatus == PlaybackStateStatus.Stopped)
        {
            var sessionLoader = new PlaybackSessionLoader(_currentInfrastructure!.Coordinator, _sessionState, _scrobblingService);
            sessionLoader.ReloadSession(CurrentSong, CurrentPosition, true);
        }
    }

    public void StopSession(bool isExplicit)
    {
        _explicitStopRequested = isExplicit;
        if (CurrentPlaybackStatus != PlaybackStateStatus.Stopped)
        {
            _currentInfrastructure?.Coordinator.Stop();
        }
        else if (isExplicit)
        {
            _completionHandler.Handle(new StoppedEventArgs(), CurrentSong, this.CurrentPosition, this.CurrentSongDuration, _explicitStopRequested, false);
        }
    }

    public void SeekSession(TimeSpan requestedPosition)
    {
        if (CurrentSong == null || CurrentSongDuration == TimeSpan.Zero) return;
        _currentInfrastructure?.Coordinator.Seek(requestedPosition);
    }

    internal void ForceReleaseEngineForCurrentSong()
    {
        if (CurrentSong == null) return;
        _currentInfrastructure?.Coordinator.DisposeCurrentEngineInternals();
        SetPlaybackState(false, PlaybackStateStatus.Stopped);
    }

    internal bool ForceReloadAndPlayEngine(Song song, TimeSpan position, bool shouldBePlaying)
    {
        _explicitStopRequested = false;
        if (_currentInfrastructure == null)
        {
            Debug.WriteLine("[SessionManager] ForceReloadAndPlayEngine: No current infrastructure. Creating new one.");
            _currentInfrastructure = new PlaybackInfrastructureProvider(_loopHandler);
            _currentInfrastructure.Coordinator.EnginePlaybackStopped += OnEngineCoordinatorPlaybackStopped;
            _currentInfrastructure.Coordinator.EnginePositionUpdated += OnEngineCoordinatorPositionUpdated;
        }
        var sessionLoader = new PlaybackSessionLoader(_currentInfrastructure.Coordinator, _sessionState, _scrobblingService);
        return sessionLoader.ReloadSession(song, position, shouldBePlaying);
    }

    private void OnEngineCoordinatorPositionUpdated(object? sender, PositionEventArgs e)
    {
        if (sender != _currentInfrastructure?.Coordinator)
        {
            return;
        }

        _sessionState.CurrentPosition = e.Position;
        _sessionState.CurrentSongDuration = e.Duration;

        if (CurrentSong is not null)
        {
            bool playbackThresholdMet = _scrobblingService.ShouldScrobble(CurrentSong, e.Position);

            // Scrobble-on-threshold logic
            if (!_hasBeenScrobbledThisSession && playbackThresholdMet)
            {
                Debug.WriteLine($"[SessionManager] Scrobble threshold met for '{CurrentSong.Title}'. Sending permanent scrobble now.");
                _ = _scrobblingService.ScrobbleAsync(CurrentSong, DateTime.UtcNow); // Fire and forget
                _hasBeenScrobbledThisSession = true;
            }

            // Play count logic
            if (!_hasBeenCountedAsPlayedThisSession && playbackThresholdMet)
            {
                Debug.WriteLine($"[SessionManager] Play count threshold met for '{CurrentSong.Title}'. Incrementing count.");
                _playCountDataService.IncrementPlayCount(CurrentSong.FilePath);
                CurrentSong.PlayCount++; // Update the live model
                _hasBeenCountedAsPlayedThisSession = true;
            }
        }
    }

    private void OnEngineCoordinatorPlaybackStopped(object? sender, StoppedEventArgs e)
    {
        // This handler is now ONLY for the CURRENT session.
        // Stops from song transitions are handled by the one-time lambda in StartNewSession.
        if (sender != _currentInfrastructure?.Coordinator)
        {
            Debug.WriteLine("[SessionManager] Received a stop event from a stale/old infrastructure. Ignoring.");
            return;
        }

        _completionHandler.Handle(e, CurrentSong, this.CurrentPosition, this.CurrentSongDuration, _explicitStopRequested, isInternalStopForSongChange: false);
    }

    // Methods called by PlaybackCompletionHandler
    internal void StopUiUpdateMonitor()
    {
        _currentInfrastructure?.Monitor.Stop();
    }

    internal void UpdateStateForNaturalPlaybackEnd()
    {
        SetPlaybackState(false, PlaybackStateStatus.Stopped);
    }

    internal void FinalizeCurrentSong(Song? song)
    {
        _sessionState.CurrentSong = song;
        if (song == null) _sessionState.ResetToDefault();
        _currentInfrastructure?.Coordinator.SetSong(song);
    }

    internal Song? GetCurrentSongForCompletion() => CurrentSong;

    internal void SetPlaybackState(bool isPlaying, PlaybackStateStatus status)
    {
        _sessionState.IsPlaying = isPlaying;
        _sessionState.CurrentPlaybackStatus = status;
    }

    internal void TriggerSessionEndedNaturally()
    {
        SessionEndedNaturally?.Invoke(this, EventArgs.Empty);
    }

    internal void ResetExplicitStopFlag()
    {
        _explicitStopRequested = false;
    }

    public void Dispose()
    {
        Debug.WriteLine("[PlaybackSessionManager] Dispose called.");
        if (_sessionState is not null) _sessionState.PropertyChanged -= SessionState_PropertyChanged;
        _currentInfrastructure?.Dispose();
        _currentInfrastructure = null;
        GC.SuppressFinalize(this);
        Debug.WriteLine("[PlaybackSessionManager] Dispose completed.");
    }

    ~PlaybackSessionManager()
    {
        Dispose();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\Playback\PlaybackSessionState.cs">
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using Sonorize.Models;

namespace Sonorize.Services.Playback;

public class PlaybackSessionState : INotifyPropertyChanged
{
    public event PropertyChangedEventHandler? PropertyChanged;

    private Song? _currentSong;
    public Song? CurrentSong
    {
        get => _currentSong;
        set
        {
            if (SetProperty(ref _currentSong, value))
            {
                OnPropertyChanged(nameof(HasCurrentSong)); // Dependent property
            }
        }
    }

    public bool HasCurrentSong => CurrentSong is not null;

    private bool _isPlaying;
    public bool IsPlaying { get => _isPlaying; set => SetProperty(ref _isPlaying, value); }

    private PlaybackStateStatus _currentPlaybackStatus = PlaybackStateStatus.Stopped;
    public PlaybackStateStatus CurrentPlaybackStatus { get => _currentPlaybackStatus; set => SetProperty(ref _currentPlaybackStatus, value); }

    public TimeSpan CurrentPosition
    {
        get;
        set
        {
            if (SetProperty(ref field, value))
            {
                OnPropertyChanged(nameof(CurrentPositionSeconds)); // Dependent property
            }
        }
    }
    public double CurrentPositionSeconds => CurrentPosition.TotalSeconds;

    public TimeSpan CurrentSongDuration
    {
        get;
        set
        {
            if (SetProperty(ref field, value))
            {
                OnPropertyChanged(nameof(CurrentSongDurationSeconds)); // Dependent property
            }
        }
    }
    public double CurrentSongDurationSeconds => CurrentSongDuration.TotalSeconds > 0 ? CurrentSongDuration.TotalSeconds : 1.0;

    public float PlaybackRate { get; set => SetProperty(ref field, value); } = 1.0f;
    public float PitchSemitones { get; set => SetProperty(ref field, value); } = 0f;

    protected bool SetProperty<T>(ref T field, T value, [CallerMemberName] string? propertyName = null)
    {
        if (EqualityComparer<T>.Default.Equals(field, value)) return false;
        field = value;
        OnPropertyChanged(propertyName);
        return true;
    }

    protected void OnPropertyChanged([CallerMemberName] string? propertyName = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }

    public void ResetToDefault()
    {
        CurrentSong = null;
        IsPlaying = false;
        CurrentPlaybackStatus = PlaybackStateStatus.Stopped;
        CurrentPosition = TimeSpan.Zero;
        CurrentSongDuration = TimeSpan.Zero;
        // PlaybackRate and PitchSemitones might retain their last set values or reset too,
        // depending on desired behavior. For now, assume they persist unless explicitly changed.
        // If they should reset:
        // PlaybackRate = 1.0f;
        // PitchSemitones = 0f;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\Settings\SettingsChangeProcessorService.cs">
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;
using Sonorize.Models;
using Sonorize.ViewModels; // Required for LibraryViewModel

namespace Sonorize.Services;

public class SettingsChangeProcessorService
{
    private readonly LibraryViewModel _libraryViewModel;
    private readonly ScrobblingService _scrobblingService;

    public SettingsChangeProcessorService(LibraryViewModel libraryViewModel, ScrobblingService scrobblingService)
    {
        _libraryViewModel = libraryViewModel ?? throw new System.ArgumentNullException(nameof(libraryViewModel));
        _scrobblingService = scrobblingService ?? throw new System.ArgumentNullException(nameof(scrobblingService));
    }

    public async Task<List<string>> ProcessChangesAndGetStatus(AppSettings oldSettings, AppSettings newSettings)
    {
        List<string> statusMessages = [];

        // Directory changes
        bool dirsActuallyChanged = !oldSettings.MusicDirectories.SequenceEqual(newSettings.MusicDirectories);
        if (dirsActuallyChanged)
        {
            Debug.WriteLine("[SettingsChangeProcessor] Music directories changed. Reloading library.");
            await _libraryViewModel.LoadLibraryAsync();
            // Status text during library loading is handled by LibraryViewModel/MusicLibraryService
        }

        // Theme changes
        bool themeActuallyChanged = oldSettings.PreferredThemeFileName != newSettings.PreferredThemeFileName;
        if (themeActuallyChanged)
        {
            Debug.WriteLine("[SettingsChangeProcessor] Theme changed. Restart recommended.");
            statusMessages.Add("Theme changed. Restart Sonorize for full effect.");
        }

        // Scrobbling settings changes
        bool scrobbleSettingsActuallyChanged =
            oldSettings.LastfmScrobblingEnabled != newSettings.LastfmScrobblingEnabled ||
            oldSettings.LastfmUsername != newSettings.LastfmUsername ||
            oldSettings.LastfmPassword != newSettings.LastfmPassword || // Used for change detection only
            oldSettings.LastfmSessionKey != newSettings.LastfmSessionKey || // If session key is cleared/changed directly
            oldSettings.ScrobbleThresholdPercentage != newSettings.ScrobbleThresholdPercentage ||
            oldSettings.ScrobbleThresholdAbsoluteSeconds != newSettings.ScrobbleThresholdAbsoluteSeconds;

        if (scrobbleSettingsActuallyChanged)
        {
            Debug.WriteLine("[SettingsChangeProcessor] Scrobbling settings changed. Refreshing ScrobblingService.");
            _scrobblingService.RefreshSettings(); // This will re-evaluate credentials and session key

            // Provide feedback based on the new state of scrobbling AFTER refresh
            _scrobblingService.RefreshSettings(); // Call refresh again to ensure service state is based on latest
            if (_scrobblingService.IsScrobblingEnabled && _scrobblingService.AreCredentialsEffectivelyConfigured)
            {
                // Check if already added "Theme changed..." to avoid overwriting it with a less critical message
                if (!statusMessages.Any(m => m.Contains("Theme changed")))
                {
                    statusMessages.Add("Scrobbling enabled and configured.");
                }
                else
                {
                    // Append if theme change message exists
                    var themeMsgIndex = statusMessages.FindIndex(m => m.Contains("Theme changed"));
                    if (themeMsgIndex != -1) statusMessages[themeMsgIndex] += " Scrobbling enabled.";
                    else statusMessages.Add("Scrobbling enabled and configured.");
                }
            }
            else if (_scrobblingService.IsScrobblingEnabled && !_scrobblingService.AreCredentialsEffectivelyConfigured)
            {
                if (!statusMessages.Any(m => m.Contains("Theme changed")))
                {
                    statusMessages.Add("Scrobbling enabled, but not configured. Check settings.");
                }
                else
                {
                    var themeMsgIndex = statusMessages.FindIndex(m => m.Contains("Theme changed"));
                    if (themeMsgIndex != -1) statusMessages[themeMsgIndex] += " Scrobbling enabled (check config).";
                    else statusMessages.Add("Scrobbling enabled, but not configured. Check settings.");
                }
            }
            else if (!_scrobblingService.IsScrobblingEnabled && oldSettings.LastfmScrobblingEnabled)
            {
                if (!statusMessages.Any(m => m.Contains("Theme changed")))
                {
                    statusMessages.Add("Scrobbling disabled.");
                }
                else
                {
                    var themeMsgIndex = statusMessages.FindIndex(m => m.Contains("Theme changed"));
                    if (themeMsgIndex != -1) statusMessages[themeMsgIndex] += " Scrobbling disabled.";
                    else statusMessages.Add("Scrobbling disabled.");
                }

            }
        }

        // If no specific messages were generated but changes happened, ensure status bar updates.
        // This is implicitly handled if statusMessages is empty, MainWindowViewModel calls UpdateStatusBarText().

        return statusMessages;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\Settings\SettingsPersistenceManager.cs">
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Sonorize.Models;
using Sonorize.Services;
using Sonorize.ViewModels.Settings;

namespace Sonorize.ViewModels;

public class SettingsPersistenceManager
{
    private readonly SettingsService _settingsService;

    public SettingsPersistenceManager(SettingsService settingsService)
    {
        _settingsService = settingsService ?? throw new System.ArgumentNullException(nameof(settingsService));
    }

    public bool ApplyAndSaveChanges(
        AppSettings settingsOnDisk,
        MusicDirectoriesSettingsViewModel musicDirectoriesSettings,
        ThemeSettingsViewModel themeSettings,
        LastfmSettingsViewModel lastfmSettings,
        AppearanceSettingsViewModel appearanceSettings)
    {
        AppSettings newSettingsToSave = new();

        // Preserve settings not managed by SettingsViewModel's UI by copying from disk state
        newSettingsToSave.LibraryViewModePreference = settingsOnDisk.LibraryViewModePreference;
        newSettingsToSave.ArtistViewModePreference = settingsOnDisk.ArtistViewModePreference;
        newSettingsToSave.AlbumViewModePreference = settingsOnDisk.AlbumViewModePreference;
        newSettingsToSave.PlaylistViewModePreference = settingsOnDisk.PlaylistViewModePreference;
        newSettingsToSave.LastfmSessionKey = settingsOnDisk.LastfmSessionKey;

        bool actualChangesMade = false;

        // Music Directories
        if (musicDirectoriesSettings.HasChangesFromInitialState)
        {
            newSettingsToSave.MusicDirectories = new List<string>(musicDirectoriesSettings.MusicDirectories);
            actualChangesMade = true;
            Debug.WriteLine($"[SettingsPersistence] Music directories changed. Count: {newSettingsToSave.MusicDirectories.Count}");
        }
        else
        {
            newSettingsToSave.MusicDirectories = new List<string>(settingsOnDisk.MusicDirectories);
        }

        // Theme
        if (themeSettings.HasChangesFromInitialState)
        {
            newSettingsToSave.PreferredThemeFileName = themeSettings.SelectedThemeFile;
            actualChangesMade = true;
            Debug.WriteLine($"[SettingsPersistence] Theme changed to: {themeSettings.SelectedThemeFile}");
        }
        else
        {
            newSettingsToSave.PreferredThemeFileName = settingsOnDisk.PreferredThemeFileName;
        }
        
        // Appearance
        if (appearanceSettings.HasChangesFromInitialState)
        {
            appearanceSettings.UpdateAppSettings(newSettingsToSave);
            actualChangesMade = true;
            Debug.WriteLine($"[SettingsPersistence] Appearance settings changed.");
        }
        else
        {
            newSettingsToSave.ArtistGridViewImageType = settingsOnDisk.ArtistGridViewImageType;
            newSettingsToSave.AlbumGridViewImageType = settingsOnDisk.AlbumGridViewImageType;
            newSettingsToSave.PlaylistGridViewImageType = settingsOnDisk.PlaylistGridViewImageType;
        }

        // Last.fm Settings - Compare UI state against disk state for change detection
        bool lastfmChanged = settingsOnDisk.LastfmScrobblingEnabled != lastfmSettings.LastfmScrobblingEnabled ||
                             settingsOnDisk.LastfmUsername != lastfmSettings.LastfmUsername ||
                             !string.IsNullOrEmpty(lastfmSettings.LastfmPassword) ||
                             settingsOnDisk.ScrobbleThresholdPercentage != lastfmSettings.ScrobbleThresholdPercentage ||
                             settingsOnDisk.ScrobbleThresholdAbsoluteSeconds != lastfmSettings.ScrobbleThresholdAbsoluteSeconds;
        
        if (lastfmChanged) actualChangesMade = true;
        
        lastfmSettings.UpdateAppSettings(newSettingsToSave);
        if (lastfmChanged)
        {
            Debug.WriteLine($"[SettingsPersistence] Last.fm settings potentially updated in newSettingsToSave: " +
                            $"Scrobbling={newSettingsToSave.LastfmScrobblingEnabled}, " +
                            $"User={newSettingsToSave.LastfmUsername}, " +
                            $"PassLen={(newSettingsToSave.LastfmPassword?.Length ?? 0)}, " +
                            $"Thresh%={newSettingsToSave.ScrobbleThresholdPercentage}, " +
                            $"ThreshAbsSec={newSettingsToSave.ScrobbleThresholdAbsoluteSeconds}");
        }


        if (actualChangesMade)
        {
            _settingsService.SaveSettings(newSettingsToSave);
            Debug.WriteLine("[SettingsPersistence] Actual changes detected and settings saved.");
            return true;
        }

        Debug.WriteLine("[SettingsPersistence] No actual changes to persist.");
        return false;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Services\Settings\SettingsService.cs">
using System;
using System.IO;
using System.Text.Json;
using Sonorize.Models;

namespace Sonorize.Services;

public class SettingsService
{
    private readonly string _settingsFilePath;

    public SettingsService()
    {
        var baseDirectory = AppContext.BaseDirectory;
        var dataDirectory = Path.Combine(baseDirectory, "Data");
        Directory.CreateDirectory(dataDirectory); // Ensure directory exists
        _settingsFilePath = Path.Combine(dataDirectory, "settings.json");
    }

    public AppSettings LoadSettings()
    {
        try
        {
            if (File.Exists(_settingsFilePath))
            {
                var json = File.ReadAllText(_settingsFilePath);
                return JsonSerializer.Deserialize<AppSettings>(json) ?? new AppSettings();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading settings: {ex.Message}");
            // Fallback to default settings
        }
        return new AppSettings();
    }

    public void SaveSettings(AppSettings settings)
    {
        try
        {
            var json = JsonSerializer.Serialize(settings, new JsonSerializerOptions { WriteIndented = true });
            File.WriteAllText(_settingsFilePath, json);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error saving settings: {ex.Message}");
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\LibraryManagement\ArtistAlbumCollectionManager.cs">
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using Avalonia.Media.Imaging;
using Sonorize.Models;
using Sonorize.Services;
using Sonorize.Utils; // For AlbumArtistTupleComparer

namespace Sonorize.ViewModels.LibraryManagement;

public class ArtistAlbumCollectionManager
{
    private readonly ObservableCollection<ArtistViewModel> _artistsCollection;
    private readonly ObservableCollection<AlbumViewModel> _albumsCollection;
    private readonly MusicLibraryService _musicLibraryService; // For default thumbnail

    public ArtistAlbumCollectionManager(
        ObservableCollection<ArtistViewModel> artistsCollection,
        ObservableCollection<AlbumViewModel> albumsCollection,
        MusicLibraryService musicLibraryService)
    {
        _artistsCollection = artistsCollection ?? throw new ArgumentNullException(nameof(artistsCollection));
        _albumsCollection = albumsCollection ?? throw new ArgumentNullException(nameof(albumsCollection));
        _musicLibraryService = musicLibraryService ?? throw new ArgumentNullException(nameof(musicLibraryService));
    }

    public void PopulateCollections(IEnumerable<Song> allSongs)
    {
        _artistsCollection.Clear();
        var uniqueArtistNames = allSongs
            .Where(s => !string.IsNullOrWhiteSpace(s.Artist))
            .Select(s => s.Artist!)
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .OrderBy(a => a, StringComparer.OrdinalIgnoreCase)
            .ToList();

        Bitmap? defaultSongThumbnail = _musicLibraryService.GetDefaultThumbnail();
        foreach (string? artistName in uniqueArtistNames)
        {
            var artistVM = new ArtistViewModel { Name = artistName };
            var songsByArtist = allSongs.Where(s => s.Artist?.Equals(artistName, StringComparison.OrdinalIgnoreCase) ?? false).ToList();
            artistVM.SongCount = songsByArtist.Count;

            List<Bitmap?> songThumbnailsForGrid = new(new Bitmap?[4]);
            List<Bitmap?> distinctSongThumbs = songsByArtist
                .Select(s => s.Thumbnail ?? defaultSongThumbnail)
                .Where(t => t != null)
                .Distinct()
                .Take(4)
                .ToList();

            for (int i = 0; i < distinctSongThumbs.Count; i++)
            {
                songThumbnailsForGrid[i] = distinctSongThumbs[i];
            }

            artistVM.SongThumbnailsForGrid = songThumbnailsForGrid;
            artistVM.Thumbnail = songThumbnailsForGrid.FirstOrDefault(t => t != null) ?? defaultSongThumbnail;

            _artistsCollection.Add(artistVM);
        }

        _albumsCollection.Clear();
        Func<Song, (string Album, string Artist)> keySelector = s => (s.Album?.Trim() ?? string.Empty, s.Artist?.Trim() ?? string.Empty);
        var uniqueAlbumsData = allSongs
            .Where(s => !string.IsNullOrWhiteSpace(s.Album) && !string.IsNullOrWhiteSpace(s.Artist))
            .GroupBy(keySelector, AlbumArtistTupleComparer.Instance)
            .Select(g => new
            {
                AlbumTitle = g.Key.Album,
                ArtistName = g.Key.Artist,
                SongsInAlbum = g.ToList()
            })
            .OrderBy(a => a.ArtistName, StringComparer.OrdinalIgnoreCase).ThenBy(a => a.AlbumTitle, StringComparer.OrdinalIgnoreCase)
            .ToList();

        foreach (var albumData in uniqueAlbumsData)
        {
            AlbumViewModel albumVM = new()
            {
                Title = albumData.AlbumTitle,
                Artist = albumData.ArtistName,
                SongCount = albumData.SongsInAlbum.Count
            };

            List<Bitmap?> songThumbnailsForGrid = new(new Bitmap?[4]);
            List<Bitmap?> distinctSongThumbs = albumData.SongsInAlbum
                                                 .Select(s => s.Thumbnail ?? defaultSongThumbnail)
                                                 .Distinct()
                                                 .Take(4)
                                                 .ToList();

            for (int i = 0; i < distinctSongThumbs.Count; i++)
            {
                songThumbnailsForGrid[i] = distinctSongThumbs[i];
            }

            albumVM.SongThumbnailsForGrid = songThumbnailsForGrid;
            albumVM.RepresentativeThumbnail = songThumbnailsForGrid.FirstOrDefault(t => t is not null) ?? defaultSongThumbnail;

            _albumsCollection.Add(albumVM);
        }
    }

    public void UpdateCollectionsForSongThumbnail(Song updatedSong, IEnumerable<Song> allSongs)
    {
        // Update ArtistViewModel
        var artistVM = _artistsCollection.FirstOrDefault(a => a.Name == updatedSong.Artist);
        if (artistVM is not null)
        {
            var songsByArtist = allSongs.Where(s => s.Artist?.Equals(artistVM.Name, StringComparison.OrdinalIgnoreCase) ?? false).ToList();
            Bitmap? defaultIcon = _musicLibraryService.GetDefaultThumbnail();

            List<Bitmap?> newGridThumbnails = new(new Bitmap?[4]);
            List<Bitmap?> distinctThumbs = songsByArtist
                .Select(s => s.Thumbnail ?? defaultIcon)
                .Where(t => t != null)
                .Distinct()
                .Take(4)
                .ToList();

            for (int i = 0; i < distinctThumbs.Count; i++)
            {
                newGridThumbnails[i] = distinctThumbs[i];
            }

            if (!artistVM.SongThumbnailsForGrid.SequenceEqual(newGridThumbnails))
            {
                artistVM.SongThumbnailsForGrid = newGridThumbnails;
            }

            Bitmap? newRepresentativeThumbnail = newGridThumbnails.FirstOrDefault(t => t != null) ?? defaultIcon;
            if (artistVM.Thumbnail != newRepresentativeThumbnail)
            {
                artistVM.Thumbnail = newRepresentativeThumbnail;
            }
        }

        // Update AlbumViewModel
        var albumVM = _albumsCollection.FirstOrDefault(al => al.Title == updatedSong.Album && al.Artist == updatedSong.Artist);
        if (albumVM is not null)
        {
            var songsInAlbum = allSongs.Where(s => (s.Album?.Equals(albumVM.Title, StringComparison.OrdinalIgnoreCase) ?? false) &&
                                                    (s.Artist?.Equals(albumVM.Artist, StringComparison.OrdinalIgnoreCase) ?? false))
                                         .ToList();

            Bitmap? defaultSongThumbnail = _musicLibraryService.GetDefaultThumbnail();
            List<Bitmap?> newSongThumbnailsForGrid = new List<Bitmap?>(new Bitmap?[4]);
            List<Bitmap?> distinctSongThumbs = songsInAlbum
                                                 .Select(s => s.Thumbnail ?? defaultSongThumbnail)
                                                 .Distinct()
                                                 .Take(4)
                                                 .ToList();

            for (int i = 0; i < distinctSongThumbs.Count; i++)
            {
                newSongThumbnailsForGrid[i] = distinctSongThumbs[i];
            }

            // Check if the grid thumbnails actually changed before assigning to avoid unnecessary UI updates.
            if (!albumVM.SongThumbnailsForGrid.SequenceEqual(newSongThumbnailsForGrid))
            {
                albumVM.SongThumbnailsForGrid = newSongThumbnailsForGrid;
            }

            Bitmap? newRepresentativeThumbnail = newSongThumbnailsForGrid.FirstOrDefault(t => t is not null) ?? defaultSongThumbnail;
            if (albumVM.RepresentativeThumbnail != newRepresentativeThumbnail)
            {
                albumVM.RepresentativeThumbnail = newRepresentativeThumbnail;
            }
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\LibraryManagement\AutoPlaylistManager.cs">
using System;
using System.Collections.Generic;
using System.Linq;
using Avalonia.Media.Imaging;
using Sonorize.Models;
using Sonorize.Services;

namespace Sonorize.ViewModels.LibraryManagement;

public class AutoPlaylistManager
{
    private readonly AutoPlaylistGeneratorService _generator = new();
    private readonly PlaylistCollectionManager _playlistCollectionManager;
    private readonly SongListManager _songListManager;
    private readonly MusicLibraryService _musicLibraryService;

    public AutoPlaylistManager(
        PlaylistCollectionManager playlistCollectionManager,
        SongListManager songListManager,
        MusicLibraryService musicLibraryService)
    {
        _playlistCollectionManager = playlistCollectionManager ?? throw new ArgumentNullException(nameof(playlistCollectionManager));
        _songListManager = songListManager ?? throw new ArgumentNullException(nameof(songListManager));
        _musicLibraryService = musicLibraryService ?? throw new ArgumentNullException(nameof(musicLibraryService));
    }

    public List<Playlist> GenerateInitialAutoPlaylists(IEnumerable<Song> allSongs)
    {
        return _generator.GenerateAll(allSongs);
    }

    public void RefreshAutoPlaylists()
    {
        var allSongs = _songListManager.GetAllSongsReadOnly();
        var newAutoPlaylists = _generator.GenerateAll(allSongs);

        var newAutoPlaylistVMs = newAutoPlaylists
            .Select(p => new PlaylistViewModel(p, _musicLibraryService.GetDefaultThumbnail()))
            .ToList();

        _playlistCollectionManager.UpdateAutoPlaylists(newAutoPlaylistVMs);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\LibraryManagement\LibraryComponentProvider.cs">
using Sonorize.Services;

namespace Sonorize.ViewModels.LibraryManagement;

public class LibraryComponentProvider
{
    public LibraryGroupingsViewModel Groupings { get; }
    public LibraryFilterStateManager FilterState { get; }
    public SongListManager SongList { get; }
    public LibraryDataOrchestrator DataOrchestrator { get; }
    public LibraryStatusTextGenerator StatusTextGenerator { get; }
    public AutoPlaylistManager AutoPlaylistManager { get; }

    private readonly SongFilteringService _songFilteringService;

    public LibraryComponentProvider(MusicLibraryService musicLibraryService, SettingsService settingsService)
    {
        Groupings = new(musicLibraryService);
        FilterState = new();
        _songFilteringService = new();
        SongList = new(_songFilteringService);
        AutoPlaylistManager = new AutoPlaylistManager(Groupings.PlaylistManager, SongList, musicLibraryService);
        DataOrchestrator = new(musicLibraryService, Groupings.ArtistAlbumManager, settingsService, AutoPlaylistManager);
        StatusTextGenerator = new();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\LibraryManagement\LibraryDataOrchestrator.cs">
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;
using Avalonia.Threading;
using Sonorize.Models;
using Sonorize.Services;

namespace Sonorize.ViewModels.LibraryManagement;

public class LibraryDataOrchestrator
{
    private readonly MusicLibraryService _musicLibraryService;
    private readonly ArtistAlbumCollectionManager _artistAlbumManager;
    private readonly SettingsService _settingsService;
    private readonly AutoPlaylistManager _autoPlaylistManager;

    public LibraryDataOrchestrator(
        MusicLibraryService musicLibraryService,
        ArtistAlbumCollectionManager artistAlbumManager,
        SettingsService settingsService,
        AutoPlaylistManager autoPlaylistManager)
    {
        _musicLibraryService = musicLibraryService ?? throw new ArgumentNullException(nameof(musicLibraryService));
        _artistAlbumManager = artistAlbumManager ?? throw new ArgumentNullException(nameof(artistAlbumManager));
        _settingsService = settingsService ?? throw new ArgumentNullException(nameof(settingsService));
        _autoPlaylistManager = autoPlaylistManager ?? throw new ArgumentNullException(nameof(autoPlaylistManager));
    }

    public async Task<(List<Song> Songs, List<Playlist> Playlists)> LoadAndProcessLibraryDataAsync(Action<string> statusUpdateCallback)
    {
        var rawSongs = new List<Song>();

        AppSettings settings = _settingsService.LoadSettings();
        if (!settings.MusicDirectories.Any())
        {
            await Dispatcher.UIThread.InvokeAsync(() => statusUpdateCallback("No music directories configured."));
            return (rawSongs, new List<Playlist>());
        }

        try
        {
            // Phase 1: Load raw song metadata and thumbnails
            await _musicLibraryService.LoadMusicFromDirectoriesAsync(
                settings.MusicDirectories,
                song =>
                {
                    rawSongs.Add(song);
                },
                status => Dispatcher.UIThread.InvokeAsync(() => statusUpdateCallback(status))
            );

            // Phase 2: Load Playlists using the fully gathered rawSongs list
            await Dispatcher.UIThread.InvokeAsync(() => statusUpdateCallback($"Found {rawSongs.Count} songs. Scanning for playlists..."));
            var filePlaylists = await _musicLibraryService.LoadPlaylistsAsync(settings.MusicDirectories, rawSongs);

            // Phase 2.5: Generate Auto-Playlists
            var autoPlaylists = _autoPlaylistManager.GenerateInitialAutoPlaylists(rawSongs);

            // Combine all playlists, auto-playlists first
            var allPlaylists = autoPlaylists.Concat(filePlaylists).ToList();

            // Phase 3: Populate Artist and Album collections
            await Dispatcher.UIThread.InvokeAsync(() =>
            {
                _artistAlbumManager.PopulateCollections(rawSongs);
            });

            return (rawSongs, allPlaylists);
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[LibraryDataOrchestrator] Error loading and processing library data: {ex}");
            await Dispatcher.UIThread.InvokeAsync(() => statusUpdateCallback("Error loading music library."));
            return (new List<Song>(), new List<Playlist>());
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\LibraryManagement\LibraryDisplayModeService.cs">
using System;
using System.ComponentModel;
using System.Windows.Input;
using Sonorize.Models;
using Sonorize.Services;

namespace Sonorize.ViewModels.LibraryManagement;

public class LibraryDisplayModeService : ViewModelBase
{
    private readonly SettingsService _settingsService;

    private SongDisplayMode _libraryViewMode;
    public SongDisplayMode LibraryViewMode
    {
        get => _libraryViewMode;
        private set // Setter is private, changes are made via command
        {
            if (SetProperty(ref _libraryViewMode, value))
            {
                SavePreference(nameof(AppSettings.LibraryViewModePreference), value.ToString());
            }
        }
    }

    private SongDisplayMode _artistViewMode;
    public SongDisplayMode ArtistViewMode
    {
        get => _artistViewMode;
        private set
        {
            if (SetProperty(ref _artistViewMode, value))
            {
                SavePreference(nameof(AppSettings.ArtistViewModePreference), value.ToString());
            }
        }
    }

    private SongDisplayMode _albumViewMode;
    public SongDisplayMode AlbumViewMode
    {
        get => _albumViewMode;
        private set
        {
            if (SetProperty(ref _albumViewMode, value))
            {
                SavePreference(nameof(AppSettings.AlbumViewModePreference), value.ToString());
            }
        }
    }
    
    private SongDisplayMode _playlistViewMode;
    public SongDisplayMode PlaylistViewMode
    {
        get => _playlistViewMode;
        private set
        {
            if (SetProperty(ref _playlistViewMode, value))
            {
                SavePreference(nameof(AppSettings.PlaylistViewModePreference), value.ToString());
            }
        }
    }

    public GridViewImageType ArtistGridDisplayType { get; private set; }
    public GridViewImageType AlbumGridDisplayType { get; private set; }
    public GridViewImageType PlaylistGridDisplayType { get; private set; }

    public ICommand SetDisplayModeCommand { get; }

    public LibraryDisplayModeService(SettingsService settingsService)
    {
        _settingsService = settingsService ?? throw new ArgumentNullException(nameof(settingsService));
        LoadDisplayPreferences();

        SetDisplayModeCommand = new RelayCommand(
            param =>
            {
                if (param is not (string targetView, SongDisplayMode mode))
                {
                    return;
                }

                switch (targetView)
                {
                    case "Library": LibraryViewMode = mode; break;
                    case "Artists": ArtistViewMode = mode; break;
                    case "Albums": AlbumViewMode = mode; break;
                    case "Playlists": PlaylistViewMode = mode; break;
                }
            },
            _ => true // Command is always executable
        );
    }

    public void ReloadDisplayPreferences()
    {
        LoadDisplayPreferences();
    }

    private void LoadDisplayPreferences()
    {
        AppSettings settings = _settingsService.LoadSettings();
        _libraryViewMode = Enum.TryParse<SongDisplayMode>(settings.LibraryViewModePreference, out var libMode) ? libMode : SongDisplayMode.Detailed;
        _artistViewMode = Enum.TryParse<SongDisplayMode>(settings.ArtistViewModePreference, out var artMode) ? artMode : SongDisplayMode.Detailed;
        _albumViewMode = Enum.TryParse<SongDisplayMode>(settings.AlbumViewModePreference, out var albMode) ? albMode : SongDisplayMode.Detailed;
        _playlistViewMode = Enum.TryParse<SongDisplayMode>(settings.PlaylistViewModePreference, out var playMode) ? playMode : SongDisplayMode.Detailed;
        
        ArtistGridDisplayType = Enum.TryParse<GridViewImageType>(settings.ArtistGridViewImageType, out var artistGridType) ? artistGridType : GridViewImageType.Composite;
        AlbumGridDisplayType = Enum.TryParse<GridViewImageType>(settings.AlbumGridViewImageType, out var albumGridType) ? albumGridType : GridViewImageType.Composite;
        PlaylistGridDisplayType = Enum.TryParse<GridViewImageType>(settings.PlaylistGridViewImageType, out var playlistGridType) ? playlistGridType : GridViewImageType.Composite;

        // Initial OnPropertyChanged for any subscribers after loading
        OnPropertyChanged(nameof(LibraryViewMode));
        OnPropertyChanged(nameof(ArtistViewMode));
        OnPropertyChanged(nameof(AlbumViewMode));
        OnPropertyChanged(nameof(PlaylistViewMode));
        OnPropertyChanged(nameof(ArtistGridDisplayType));
        OnPropertyChanged(nameof(AlbumGridDisplayType));
        OnPropertyChanged(nameof(PlaylistGridDisplayType));
    }

    private void SavePreference(string preferenceKey, string value)
    {
        AppSettings settings = _settingsService.LoadSettings();
        var prop = typeof(AppSettings).GetProperty(preferenceKey);
        if (prop != null && prop.CanWrite)
        {
            prop.SetValue(settings, value, null);
        }
        _settingsService.SaveSettings(settings);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\LibraryManagement\LibraryFilterStateManager.cs">
using System;
using Sonorize.Models; // For ArtistViewModel, AlbumViewModel

namespace Sonorize.ViewModels.LibraryManagement;

public class LibraryFilterStateManager : ViewModelBase
{
    private string _searchQuery = string.Empty;
    public string SearchQuery
    {
        get => _searchQuery;
        set
        {
            if (SetProperty(ref _searchQuery, value))
            {
                // Direct search query input might clear artist/album selections
                // or this can be handled by LibraryViewModel reacting to this change.
                // For now, assume direct search query changes don't auto-clear selected artist/album.
                // LibraryViewModel's ApplyFilter logic will decide precedence.
                FilterCriteriaChanged?.Invoke(this, EventArgs.Empty);
            }
        }
    }

    private ArtistViewModel? _selectedArtist;
    public ArtistViewModel? SelectedArtist
    {
        get => _selectedArtist;
        set
        {
            if (SetProperty(ref _selectedArtist, value))
            {
                if (_selectedArtist is not null)
                {
                    // When an artist is selected, update SearchQuery and clear SelectedAlbum
                    _searchQuery = _selectedArtist.Name ?? string.Empty; // Avoid raising SearchQuery's own event storm
                    OnPropertyChanged(nameof(SearchQuery)); // Manually notify SearchQuery changed
                    SelectedAlbum = null; // This will trigger its own PropertyChanged and subsequently FilterCriteriaChanged
                    RequestTabSwitchToLibrary?.Invoke(this, EventArgs.Empty);
                }
                FilterCriteriaChanged?.Invoke(this, EventArgs.Empty);
            }
        }
    }

    private PlaylistViewModel? _selectedPlaylist;
    public PlaylistViewModel? SelectedPlaylist
    {
        get => _selectedPlaylist;
        set
        {
            if (SetProperty(ref _selectedPlaylist, value))
            {
                if (_selectedPlaylist is not null)
                {
                    SearchQuery = string.Empty;
                    OnPropertyChanged(nameof(SearchQuery));
                    SelectedArtist = null;
                    SelectedAlbum = null;
                    RequestTabSwitchToLibrary?.Invoke(this, EventArgs.Empty);
                }
                FilterCriteriaChanged?.Invoke(this, EventArgs.Empty);
            }
        }
    }

    private AlbumViewModel? _selectedAlbum;
    public AlbumViewModel? SelectedAlbum
    {
        get => _selectedAlbum;
        set
        {
            if (SetProperty(ref _selectedAlbum, value))
            {
                if (_selectedAlbum is not null)
                {
                    // When an album is selected, update SearchQuery and clear SelectedArtist
                    _searchQuery = _selectedAlbum.Title ?? string.Empty; // Avoid raising SearchQuery's own event storm
                    OnPropertyChanged(nameof(SearchQuery)); // Manually notify SearchQuery changed
                    SelectedArtist = null; // This will trigger its own PropertyChanged and subsequently FilterCriteriaChanged
                    RequestTabSwitchToLibrary?.Invoke(this, EventArgs.Empty);
                }
                FilterCriteriaChanged?.Invoke(this, EventArgs.Empty);
            }
        }
    }

    public event EventHandler? FilterCriteriaChanged;
    public event EventHandler? RequestTabSwitchToLibrary;

    public void ClearSelectionsAndSearch()
    {
        // Suppress individual notifications if setting multiple properties
        bool changed = false;
        if (_selectedArtist is not null) { _selectedArtist = null; OnPropertyChanged(nameof(SelectedArtist)); changed = true; }
        if (_selectedAlbum is not null) { _selectedAlbum = null; OnPropertyChanged(nameof(SelectedAlbum)); changed = true; }
        if (_selectedPlaylist is not null) { _selectedPlaylist = null; OnPropertyChanged(nameof(SelectedPlaylist)); changed = true; }
        if (!string.IsNullOrEmpty(_searchQuery)) { _searchQuery = string.Empty; OnPropertyChanged(nameof(SearchQuery)); changed = true; }

        if (changed)
        {
            FilterCriteriaChanged?.Invoke(this, EventArgs.Empty);
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\LibraryManagement\LibraryGroupingsViewModel.cs">
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using Sonorize.Models;
using Sonorize.Services;

namespace Sonorize.ViewModels.LibraryManagement;

public class LibraryGroupingsViewModel : ViewModelBase
{
    private readonly ArtistAlbumCollectionManager _artistAlbumManager;
    private readonly MusicLibraryService _musicLibraryService;
    private readonly PlaylistCollectionManager _playlistManager;

    internal ArtistAlbumCollectionManager ArtistAlbumManager => _artistAlbumManager;
    internal PlaylistCollectionManager PlaylistManager => _playlistManager;

    public ObservableCollection<ArtistViewModel> Artists { get; } = [];
    public ObservableCollection<AlbumViewModel> Albums { get; } = [];
    public ObservableCollection<PlaylistViewModel> Playlists { get; } = [];

    public LibraryGroupingsViewModel(MusicLibraryService musicLibraryService)
    {
        _musicLibraryService = musicLibraryService ?? throw new ArgumentNullException(nameof(musicLibraryService));
        _artistAlbumManager = new ArtistAlbumCollectionManager(Artists, Albums, _musicLibraryService);
        _playlistManager = new PlaylistCollectionManager(Playlists, _musicLibraryService);
    }

    public void PopulateCollections(IEnumerable<Song> allSongs)
    {
        _artistAlbumManager.PopulateCollections(allSongs);
    }

    public void PopulatePlaylistCollection(IEnumerable<Playlist> allPlaylists)
    {
        _playlistManager.PopulateCollection(allPlaylists);
    }

    public void HandleSongThumbnailUpdate(Song updatedSong, IEnumerable<Song> allSongs)
    {
        // This method will be called on the UI thread by LibraryViewModel
        _artistAlbumManager.UpdateCollectionsForSongThumbnail(updatedSong, allSongs);
        _playlistManager.HandleSongThumbnailUpdate(updatedSong);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\LibraryManagement\LibraryLoadProcess.cs">
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Avalonia.Threading;
using Sonorize.Models;

namespace Sonorize.ViewModels.LibraryManagement;

public class LibraryLoadProcess
{
    private readonly LibraryComponentProvider _components;
    private readonly Action _applyFilterDelegate;
    private readonly Action _updateStatusBarTextDelegate;
    private readonly Action<bool> _setLoadingFlagDelegate;
    private readonly Action<string> _setStatusTextDelegate;
    private readonly Dispatcher _uiDispatcher;

    public LibraryLoadProcess(
        LibraryComponentProvider components,
        Action applyFilterDelegate,
        Action updateStatusBarTextDelegate,
        Action<bool> setLoadingFlagDelegate,
        Action<string> setStatusTextDelegate,
        Dispatcher uiDispatcher)
    {
        _components = components ?? throw new ArgumentNullException(nameof(components));
        _applyFilterDelegate = applyFilterDelegate ?? throw new ArgumentNullException(nameof(applyFilterDelegate));
        _updateStatusBarTextDelegate = updateStatusBarTextDelegate ?? throw new ArgumentNullException(nameof(updateStatusBarTextDelegate));
        _setLoadingFlagDelegate = setLoadingFlagDelegate ?? throw new ArgumentNullException(nameof(setLoadingFlagDelegate));
        _setStatusTextDelegate = setStatusTextDelegate ?? throw new ArgumentNullException(nameof(setStatusTextDelegate));
        _uiDispatcher = uiDispatcher ?? throw new ArgumentNullException(nameof(uiDispatcher));
    }

    public async Task ExecuteLoadAsync()
    {
        _setLoadingFlagDelegate(true);
        _components.FilterState.ClearSelectionsAndSearch();

        await _uiDispatcher.InvokeAsync(() =>
        {
            _components.SongList.ClearAllSongs();
            _components.Groupings.Artists.Clear();
            _components.Groupings.Albums.Clear();
            _components.Groupings.Playlists.Clear();
            _setStatusTextDelegate("Preparing to load music...");
        });
        
        Action<string> statusUpdateCallback = status => _setStatusTextDelegate(status);

        var (allLoadedSongsFromOrchestrator, allLoadedPlaylistsFromOrchestrator) = await _components.DataOrchestrator.LoadAndProcessLibraryDataAsync(statusUpdateCallback);
        _components.SongList.SetAllSongs(allLoadedSongsFromOrchestrator);

        await _uiDispatcher.InvokeAsync(() =>
        {
            _components.Groupings.PopulateCollections(_components.SongList.GetAllSongsReadOnly());
            _components.Groupings.PopulatePlaylistCollection(allLoadedPlaylistsFromOrchestrator);
            _applyFilterDelegate();
        });

        _setLoadingFlagDelegate(false);
        _updateStatusBarTextDelegate();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\LibraryManagement\LibraryStatusTextGenerator.cs">
using System.Linq;
using Sonorize.Models;
using Sonorize.Services; // For AppSettings in case it's needed indirectly

namespace Sonorize.ViewModels.LibraryManagement;

public class LibraryStatusTextGenerator
{
    public string GenerateStatusText(
        bool isLoadingLibrary,
        int allSongsCount,
        int filteredSongsCount,
        ArtistViewModel? selectedArtist,
        AlbumViewModel? selectedAlbum,
        PlaylistViewModel? selectedPlaylist,
        string? searchQuery,
        SettingsService settingsService)
    {
        if (isLoadingLibrary)
        {
            return "Loading library...";
        }

        if (allSongsCount == 0)
        {
            AppSettings settings = settingsService.LoadSettings();
            if (!settings.MusicDirectories.Any())
            {
                return "Library empty. Add directories via File menu.";
            }
            else
            {
                return "No songs found in configured directories.";
            }
        }

        // Playlist selection takes precedence for status text
        if (selectedPlaylist?.Name is not null)
        {
            return $"Showing playlist '{selectedPlaylist.Name}': {filteredSongsCount} songs.";
        }
        // Album selection takes precedence for status text
        if (selectedAlbum?.Title is not null && selectedAlbum.Artist is not null)
        {
            return $"Showing songs from {selectedAlbum.Title} by {selectedAlbum.Artist}: {filteredSongsCount} of {allSongsCount} total songs.";
        }
        // Then artist selection
        else if (selectedArtist?.Name is not null)
        {
            return $"Showing songs by {selectedArtist.Name}: {filteredSongsCount} of {allSongsCount} total songs.";
        }
        else if (!string.IsNullOrWhiteSpace(searchQuery))
        {
            return $"{filteredSongsCount} of {allSongsCount} songs matching search.";
        }
        else // No specific view, no search query - showing all songs
        {
            return $"{allSongsCount} songs in library.";
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\LibraryManagement\PlaylistCollectionManager.cs">
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using Avalonia.Media.Imaging;
using Sonorize.Models;
using Sonorize.Services;
using System;
using System.Diagnostics;

namespace Sonorize.ViewModels.LibraryManagement;

public class PlaylistCollectionManager
{
    private readonly ObservableCollection<PlaylistViewModel> _playlistsCollection;
    private readonly MusicLibraryService _musicLibraryService;

    public PlaylistCollectionManager(ObservableCollection<PlaylistViewModel> playlistsCollection, MusicLibraryService musicLibraryService)
    {
        _playlistsCollection = playlistsCollection;
        _musicLibraryService = musicLibraryService;
    }

    public void PopulateCollection(IEnumerable<Playlist> allPlaylists)
    {
        _playlistsCollection.Clear();
        var defaultIcon = _musicLibraryService.GetDefaultThumbnail();

        // Sort auto-playlists first, then sort alphabetically within each group
        var sortedPlaylists = allPlaylists
            .OrderByDescending(p => p.IsAutoPlaylist)
            .ThenBy(p => p.Name, StringComparer.OrdinalIgnoreCase);

        foreach (var playlist in sortedPlaylists)
        {
            _playlistsCollection.Add(new PlaylistViewModel(playlist, defaultIcon));
        }
    }

    public void UpdateAutoPlaylists(IEnumerable<PlaylistViewModel> newAutoPlaylists)
    {
        Debug.WriteLine("[PlaylistCollectionManager] Updating auto-playlists.");
        // Remove existing auto-playlists
        var existingAutoPlaylists = _playlistsCollection.Where(p => p.IsAutoPlaylist).ToList();
        foreach (var p in existingAutoPlaylists)
        {
            _playlistsCollection.Remove(p);
        }

        // Insert new ones at the top, respecting their own order
        var sortedNewPlaylists = newAutoPlaylists
            .OrderByDescending(p => p.PlaylistModel.IsAutoPlaylist) // Should all be true, but for safety
            .ThenBy(p => p.PlaylistModel.Name, StringComparer.OrdinalIgnoreCase)
            .ToList();

        for (int i = 0; i < sortedNewPlaylists.Count; i++)
        {
            _playlistsCollection.Insert(i, sortedNewPlaylists[i]);
        }
        Debug.WriteLine($"[PlaylistCollectionManager] Finished updating auto-playlists. Total playlists: {_playlistsCollection.Count}");
    }

    public void HandleSongThumbnailUpdate(Song updatedSong)
    {
        // Find all playlists containing this song
        var affectedPlaylists = _playlistsCollection
            .Where(pvm => pvm.PlaylistModel.Songs.Contains(updatedSong));

        foreach (var playlistVM in affectedPlaylists)
        {
            playlistVM.RecalculateThumbnails();
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\LibraryManagement\SongFilteringService.cs">
using System;
using System.Collections.Generic;
using System.Linq;
using Sonorize.Models;

namespace Sonorize.ViewModels.LibraryManagement;

public class SongFilteringService
{
    public IEnumerable<Song> ApplyFilter(
        IEnumerable<Song> allSongs,
        string? searchQuery,
        ArtistViewModel? selectedArtist,
        AlbumViewModel? selectedAlbum,
        PlaylistViewModel? selectedPlaylist)
    {
        IEnumerable<Song> songsToFilter = allSongs;

        // Priority:
        // 1. If a playlist is selected, show its songs.
        // 2. Else if an album is selected, filter by album (and its artist).
        // 3. Else if an artist is selected, filter by artist.
        // 4. Else if a search query is present, filter by query.
        // 5. Else, show all songs (after ordering).

        bool specificPlaylistSelected = selectedPlaylist is not null;
        bool specificAlbumSelected = selectedAlbum?.Title is not null && selectedAlbum.Artist is not null;
        bool specificArtistSelected = selectedArtist?.Name is not null;

        if (specificPlaylistSelected)
        {
            // Playlist songs are already in order. Don't sort them.
            return selectedPlaylist!.PlaylistModel.Songs;
        }
        else if (specificAlbumSelected)
        {
            songsToFilter = songsToFilter.Where(s =>
                (s.Album?.Equals(selectedAlbum!.Title, StringComparison.OrdinalIgnoreCase) ?? false) &&
                (s.Artist?.Equals(selectedAlbum!.Artist, StringComparison.OrdinalIgnoreCase) ?? false));
        }
        else if (specificArtistSelected)
        {
            songsToFilter = songsToFilter.Where(s =>
                s.Artist?.Equals(selectedArtist!.Name, StringComparison.OrdinalIgnoreCase) ?? false);
        }
        else if (!string.IsNullOrWhiteSpace(searchQuery))
        {
            string query = searchQuery.ToLowerInvariant().Trim();
            songsToFilter = songsToFilter.Where(s =>
                (s.Title?.ToLowerInvariant().Contains(query, StringComparison.InvariantCultureIgnoreCase) ?? false) ||
                (s.Artist?.ToLowerInvariant().Contains(query, StringComparison.InvariantCultureIgnoreCase) ?? false) ||
                (s.Album?.ToLowerInvariant().Contains(query, StringComparison.InvariantCultureIgnoreCase) ?? false));
        }

        return songsToFilter.OrderBy(s => s.Title, StringComparer.OrdinalIgnoreCase);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\LibraryManagement\SongListManager.cs">
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using Sonorize.Models;

namespace Sonorize.ViewModels.LibraryManagement;

public class SongListManager : ViewModelBase
{
    private readonly SongFilteringService _songFilteringService;
    private List<Song> _allSongs = new(); // Master list

    public ObservableCollection<Song> FilteredSongs { get; } = new();

    public Song? SelectedSong
    {
        get;
        set
        {
            if (SetProperty(ref field, value))
            {
                // Consumers (like TrackNavigationManager via LibraryViewModel)
                // will be notified of this change.
            }
        }
    }

    public SongListManager(SongFilteringService songFilteringService)
    {
        _songFilteringService = songFilteringService ?? throw new ArgumentNullException(nameof(songFilteringService));
    }

    public void SetAllSongs(IEnumerable<Song> songs)
    {
        _allSongs = new List<Song>(songs);
        // Typically, after setting all songs, a filter application would follow.
        // This can be triggered by the caller (LibraryViewModel).
        OnPropertyChanged(nameof(AllSongsCount)); // For any internal/debug use
    }

    public void ClearAllSongs()
    {
        _allSongs.Clear();
        FilteredSongs.Clear();
        SelectedSong = null; // This will notify
        OnPropertyChanged(nameof(AllSongsCount));
    }

    public int AllSongsCount => _allSongs.Count;

    public void ApplyFilter(string? searchQuery, ArtistViewModel? selectedArtist, AlbumViewModel? selectedAlbum, PlaylistViewModel? selectedPlaylist)
    {
        var currentSelectedSongBeforeFilter = SelectedSong;

        FilteredSongs.Clear();
        var filtered = _songFilteringService.ApplyFilter(
            _allSongs,
            searchQuery,
            selectedArtist,
            selectedAlbum,
            selectedPlaylist);

        foreach (var song in filtered)
        {
            FilteredSongs.Add(song);
        }

        // Preserve selection if possible
        if (currentSelectedSongBeforeFilter is not null && FilteredSongs.Contains(currentSelectedSongBeforeFilter))
        {
            SelectedSong = currentSelectedSongBeforeFilter; // No change notification if it's the same instance
        }
        else if (currentSelectedSongBeforeFilter is not null)
        {
            Debug.WriteLine($"[SongListManager] Selected song '{currentSelectedSongBeforeFilter.Title}' is no longer in the filtered list. Clearing selection.");
            SelectedSong = null; // Notify that selection is cleared
        }
        else if (SelectedSong is not null) // If there was a selection but it's no longer valid (e.g. currentSelectedSongBeforeFilter was null, but SelectedSong somehow had a value from previous invalid state)
        {
            SelectedSong = null; // Ensure selection is cleared and notified
        }
        // If currentSelectedSongBeforeFilter was null and SelectedSong is also null, no change, no notification.

        OnPropertyChanged(nameof(FilteredSongs)); // Notify that the collection content has changed (though individual adds also notify)
    }

    // Provides access to the master list for services like ArtistAlbumCollectionManager
    public IReadOnlyList<Song> GetAllSongsReadOnly() => _allSongs.AsReadOnly();
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\LibraryManagement\TrackNavigationManager.cs">
using System;
using System.Collections.ObjectModel; // For ObservableCollection
using System.Diagnostics;
using System.Linq;
using System.Windows.Input;
using Sonorize.Models;

namespace Sonorize.ViewModels.LibraryManagement;

public class TrackNavigationManager : ViewModelBase // Inherit for RelayCommand's RaiseCanExecuteChanged if needed
{
    private readonly ObservableCollection<Song> _filteredSongs;
    private Song? _selectedSong;

    public Song? SelectedSong
    {
        get => _selectedSong;
        set
        {
            // This setter is crucial. It's what the LibraryViewModel will call.
            // Or, LibraryViewModel could expose its SelectedSong and FilteredSongs
            // and this manager could observe them. For direct control, LibraryViewModel calls this.
            if (SetProperty(ref _selectedSong, value))
            {
                RaiseCanExecuteChangedForAllCommands();
            }
        }
    }

    public ICommand PreviousTrackCommand { get; }
    public ICommand NextTrackCommand { get; }

    public TrackNavigationManager(ObservableCollection<Song> filteredSongs)
    {
        _filteredSongs = filteredSongs ?? throw new ArgumentNullException(nameof(filteredSongs));
        _filteredSongs.CollectionChanged += (s, e) => RaiseCanExecuteChangedForAllCommands();

        PreviousTrackCommand = new RelayCommand(ExecutePreviousTrack, CanExecutePreviousTrack);
        NextTrackCommand = new RelayCommand(ExecuteNextTrack, CanExecuteNextTrack);
    }

    // This method will be called by LibraryViewModel when its SelectedSong changes
    public void UpdateSelectedSong(Song? newSelectedSong)
    {
        if (_selectedSong != newSelectedSong)
        {
            _selectedSong = newSelectedSong; // Update internal state
            RaiseCanExecuteChangedForAllCommands(); // Update command states
        }
    }


    private void ExecutePreviousTrack(object? parameter)
    {
        if (_selectedSong == null || !_filteredSongs.Any()) return;
        int currentIndex = _filteredSongs.IndexOf(_selectedSong);
        if (currentIndex > 0)
        {
            SelectedSong = _filteredSongs[currentIndex - 1]; // This will trigger property changed & command updates
            Debug.WriteLine($"[TrackNavManager] Moved to previous track: {SelectedSong.Title}");
        }
        else
        {
            Debug.WriteLine("[TrackNavManager] Already at the first track.");
        }
    }

    private bool CanExecutePreviousTrack(object? parameter)
    {
        if (_selectedSong == null || !_filteredSongs.Any()) return false;
        return _filteredSongs.IndexOf(_selectedSong) > 0;
    }

    private void ExecuteNextTrack(object? parameter)
    {
        if (_selectedSong == null || !_filteredSongs.Any()) return;
        int currentIndex = _filteredSongs.IndexOf(_selectedSong);
        if (currentIndex < _filteredSongs.Count - 1 && currentIndex != -1)
        {
            SelectedSong = _filteredSongs[currentIndex + 1]; // This will trigger property changed & command updates
            Debug.WriteLine($"[TrackNavManager] Moved to next track: {SelectedSong.Title}");
        }
        else if (currentIndex != -1)
        {
            Debug.WriteLine("[TrackNavManager] Already at the last track.");
        }
        else
        {
            Debug.WriteLine("[TrackNavManager] Selected song not found in filtered list.");
        }
    }

    private bool CanExecuteNextTrack(object? parameter)
    {
        if (_selectedSong == null || !_filteredSongs.Any()) return false;
        int currentIndex = _filteredSongs.IndexOf(_selectedSong);
        return currentIndex != -1 && currentIndex < _filteredSongs.Count - 1;
    }

    private void RaiseCanExecuteChangedForAllCommands()
    {
        (PreviousTrackCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (NextTrackCommand as RelayCommand)?.RaiseCanExecuteChanged();
    }

    // Optional: Expose an event if LibraryViewModel needs to react to selection changes from this manager
    // public event Action<Song?>? ManagedSelectionChanged;
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\Loop\ActiveLoopViewModel.cs">
using System;
using System.ComponentModel;
using System.Windows.Input;
using Avalonia.Threading;
using Sonorize.Models;
using Sonorize.Services;

namespace Sonorize.ViewModels;

public class ActiveLoopViewModel : ViewModelBase, IDisposable
{
    private readonly PlaybackService _playbackService;
    private readonly SongLoopService _songLoopService;
    private Song? _currentSongInternal;

    public string ActiveLoopDisplayText
    {
        get;
        private set => SetProperty(ref field, value);
    } = "No loop defined.";

    private bool _isLoopActive;
    public bool IsLoopActive
    {
        get => _isLoopActive;
        set
        {
            if (!SetProperty(ref _isLoopActive, value) || _currentSongInternal == null)
            {
                return;
            }

            _songLoopService.SetLoopActiveState(_currentSongInternal, value);
        }
    }

    public ICommand ToggleLoopActiveCommand { get; }

    public ActiveLoopViewModel(PlaybackService playbackService, SongLoopService songLoopService)
    {
        _playbackService = playbackService ?? throw new ArgumentNullException(nameof(playbackService));
        _songLoopService = songLoopService ?? throw new ArgumentNullException(nameof(songLoopService));

        ToggleLoopActiveCommand = new RelayCommand(ExecuteToggleLoopActive, CanExecuteToggleLoopActive);

        _playbackService.PropertyChanged += PlaybackService_PropertyChanged;
        UpdateInternalSongReference(_playbackService.CurrentSong);
    }

    private void PlaybackService_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName == nameof(PlaybackService.CurrentSong))
        {
            Dispatcher.UIThread.InvokeAsync(() =>
            {
                UpdateInternalSongReference(_playbackService.CurrentSong);
            });
        }
    }

    private void UpdateInternalSongReference(Song? newSong)
    {
        if (_currentSongInternal == newSong) return;

        if (_currentSongInternal is not null)
        {
            _currentSongInternal.PropertyChanged -= CurrentSong_PropertyChanged;
        }

        _currentSongInternal = newSong;

        if (_currentSongInternal is not null)
        {
            _currentSongInternal.PropertyChanged += CurrentSong_PropertyChanged;
        }
        RefreshStateFromCurrentSong();
    }

    private void CurrentSong_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (sender is Song song && song == _currentSongInternal)
        {
            if (e.PropertyName == nameof(Song.SavedLoop) || e.PropertyName == nameof(Song.IsLoopActive))
            {
                Dispatcher.UIThread.InvokeAsync(RefreshStateFromCurrentSong);
            }
        }
    }

    private void RefreshStateFromCurrentSong()
    {
        if (_currentSongInternal?.SavedLoop is not null)
        {
            var loop = _currentSongInternal.SavedLoop;
            string activeStatus = _currentSongInternal.IsLoopActive ? " (Active)" : " (Inactive)";
            ActiveLoopDisplayText = $"Loop: {loop.Start:mm\\:ss\\.f} - {loop.End:mm\\:ss\\.f}{activeStatus}";

            if (IsLoopActive != _currentSongInternal.IsLoopActive)
            {
                // Directly set backing field to avoid re-triggering service call if model initiated change
                SetProperty(ref _isLoopActive, _currentSongInternal.IsLoopActive, nameof(IsLoopActive));
            }
        }
        else
        {
            ActiveLoopDisplayText = "No loop defined.";
            if (IsLoopActive) // Ensure UI binding is false if no loop
            {
                SetProperty(ref _isLoopActive, false, nameof(IsLoopActive));
            }
        }
        (ToggleLoopActiveCommand as RelayCommand)?.RaiseCanExecuteChanged();
    }

    private void ExecuteToggleLoopActive(object? parameter)
    {
        if ((_currentSongInternal?.SavedLoop) == null)
        {
            return;
        }

        IsLoopActive = !IsLoopActive; // Setter will call SongLoopService
    }

    private bool CanExecuteToggleLoopActive(object? parameter)
    {
        return _currentSongInternal?.SavedLoop is not null;
    }

    public void Dispose()
    {
        _playbackService.PropertyChanged -= PlaybackService_PropertyChanged;
        if (_currentSongInternal is not null)
        {
            _currentSongInternal.PropertyChanged -= CurrentSong_PropertyChanged;
        }
        _currentSongInternal = null;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\Loop\LoopCandidateViewModel.cs">
using System;
using System.ComponentModel;
using System.Windows.Input;
using Sonorize.Models;
using Sonorize.Services; // For PlaybackService (to get CurrentPosition)

namespace Sonorize.ViewModels;

public class LoopCandidateViewModel : ViewModelBase
{
    private readonly PlaybackService _playbackService;
    private readonly Func<Song?> _getCurrentSongCallback; // To check if a song is loaded

    private TimeSpan? _newLoopStartCandidate;
    public TimeSpan? NewLoopStartCandidate
    {
        get => _newLoopStartCandidate;
        set
        {
            if (SetProperty(ref _newLoopStartCandidate, value))
            {
                OnPropertyChanged(nameof(NewLoopStartCandidateDisplay));
                // Notify parent VM or raise an event if CanSave in parent depends on this directly
                ParentLoopEditor?.RaiseCanSaveLoopRegionChanged();
            }
        }
    }

    private TimeSpan? _newLoopEndCandidate;
    public TimeSpan? NewLoopEndCandidate
    {
        get => _newLoopEndCandidate;
        set
        {
            if (SetProperty(ref _newLoopEndCandidate, value))
            {
                OnPropertyChanged(nameof(NewLoopEndCandidateDisplay));
                ParentLoopEditor?.RaiseCanSaveLoopRegionChanged();
            }
        }
    }

    public string NewLoopStartCandidateDisplay => NewLoopStartCandidate.HasValue ? $"{NewLoopStartCandidate.Value:mm\\:ss\\.ff}" : "Not set";
    public string NewLoopEndCandidateDisplay => NewLoopEndCandidate.HasValue ? $"{NewLoopEndCandidate.Value:mm\\:ss\\.ff}" : "Not set";

    public ICommand CaptureLoopStartCandidateCommand { get; }
    public ICommand CaptureLoopEndCandidateCommand { get; }

    // Reference to parent to notify about changes affecting CanSaveLoopRegion
    // This is a simple way; alternatively, events could be used.
    internal LoopEditorViewModel? ParentLoopEditor { get; set; }


    public LoopCandidateViewModel(PlaybackService playbackService, Func<Song?> getCurrentSongCallback)
    {
        _playbackService = playbackService ?? throw new ArgumentNullException(nameof(playbackService));
        _getCurrentSongCallback = getCurrentSongCallback ?? throw new ArgumentNullException(nameof(getCurrentSongCallback));

        CaptureLoopStartCandidateCommand = new RelayCommand(
            _ => NewLoopStartCandidate = _playbackService.CurrentPosition,
            CanCaptureLoopPoint);

        CaptureLoopEndCandidateCommand = new RelayCommand(
            _ => NewLoopEndCandidate = _playbackService.CurrentPosition,
            CanCaptureLoopPoint);

        _playbackService.PropertyChanged += PlaybackService_PropertyChanged;
    }

    private void PlaybackService_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName == nameof(PlaybackService.CurrentPlaybackStatus) || e.PropertyName == nameof(PlaybackService.CurrentSong))
        {
            RaiseCaptureCommandsCanExecuteChanged();
        }
    }

    private bool CanCaptureLoopPoint(object? _) =>
        _getCurrentSongCallback() is not null &&
        _playbackService.CurrentPlaybackStatus != PlaybackStateStatus.Stopped;

    public void RaiseCaptureCommandsCanExecuteChanged()
    {
        (CaptureLoopStartCandidateCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (CaptureLoopEndCandidateCommand as RelayCommand)?.RaiseCanExecuteChanged();
    }

    public void ClearCandidates()
    {
        NewLoopStartCandidate = null;
        NewLoopEndCandidate = null;
    }

    public void Dispose()
    {
        _playbackService.PropertyChanged -= PlaybackService_PropertyChanged;
        ParentLoopEditor = null; // Clear reference
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\Loop\LoopEditorViewModel.cs">
using System;
using System.Diagnostics;
using System.Windows.Input;
using Avalonia.Threading; // Required for Dispatcher
using Sonorize.Models;
using Sonorize.Services;

namespace Sonorize.ViewModels;

public class LoopEditorViewModel : ViewModelBase, IDisposable
{
    private readonly PlaybackService _playbackService;
    private readonly SongLoopService _songLoopService;
    private Song? _currentSongInternal; // Holds the Song instance from PlaybackService.CurrentSong

    public LoopCandidateViewModel CandidateLoop { get; }
    public ActiveLoopViewModel ActiveLoop { get; } // New child ViewModel

    public bool CanSaveLoopRegion => _currentSongInternal is not null
                                     && CandidateLoop.NewLoopStartCandidate.HasValue
                                     && CandidateLoop.NewLoopEndCandidate.HasValue
                                     && CandidateLoop.NewLoopEndCandidate.Value > CandidateLoop.NewLoopStartCandidate.Value
                                     && _currentSongInternal.Duration.TotalSeconds > 0
                                     && CandidateLoop.NewLoopEndCandidate.Value <= _currentSongInternal.Duration
                                     && CandidateLoop.NewLoopStartCandidate.Value >= TimeSpan.Zero;

    public ICommand CaptureLoopStartCandidateCommand => CandidateLoop.CaptureLoopStartCandidateCommand;
    public ICommand CaptureLoopEndCandidateCommand => CandidateLoop.CaptureLoopEndCandidateCommand;

    public ICommand SaveLoopCommand { get; }
    public ICommand ClearLoopCommand { get; }
    public ICommand WaveformSeekCommand { get; }


    public LoopEditorViewModel(PlaybackService playbackService, LoopDataService loopDataService, SongLoopService songLoopService)
    {
        _playbackService = playbackService;
        _songLoopService = songLoopService;

        CandidateLoop = new LoopCandidateViewModel(playbackService, () => _currentSongInternal);
        CandidateLoop.ParentLoopEditor = this; // For CanSaveLoopRegion updates

        ActiveLoop = new ActiveLoopViewModel(playbackService, songLoopService); // Instantiate new child

        SaveLoopCommand = new RelayCommand(SaveLoopAction, _ => CanSaveLoopRegion);
        ClearLoopCommand = new RelayCommand(ClearSavedLoopAction, _ => _currentSongInternal?.SavedLoop is not null);
        WaveformSeekCommand = new RelayCommand(
            timeSpanObj => { if (timeSpanObj is TimeSpan ts && _currentSongInternal is not null) _playbackService.Seek(ts); },
            _ => _currentSongInternal is not null);

        _playbackService.PropertyChanged += PlaybackService_PropertyChanged;
        UpdateStateForCurrentSong(_playbackService.CurrentSong); // Initial state update
    }

    internal void RaiseCanSaveLoopRegionChanged()
    {
        OnPropertyChanged(nameof(CanSaveLoopRegion));
        (SaveLoopCommand as RelayCommand)?.RaiseCanExecuteChanged();
    }

    private void PlaybackService_PropertyChanged(object? sender, System.ComponentModel.PropertyChangedEventArgs e)
    {
        Dispatcher.UIThread.InvokeAsync(() =>
        {
            switch (e.PropertyName)
            {
                case nameof(PlaybackService.CurrentSong):
                    Debug.WriteLine($"[LoopEdVM] PlaybackService.CurrentSong changed to: {_playbackService.CurrentSong?.Title ?? "null"}. Updating loop editor state.");
                    if (_currentSongInternal is not null)
                    {
                        _currentSongInternal.PropertyChanged -= CurrentSong_PropertyChanged;
                    }
                    _currentSongInternal = _playbackService.CurrentSong;
                    if (_currentSongInternal is not null)
                    {
                        _currentSongInternal.PropertyChanged += CurrentSong_PropertyChanged;
                    }
                    UpdateStateForCurrentSong(_currentSongInternal);
                    break;
                case nameof(PlaybackService.CurrentPosition):
                case nameof(PlaybackService.CurrentSongDuration):
                    RaiseCanSaveLoopRegionChanged();
                    CandidateLoop.RaiseCaptureCommandsCanExecuteChanged();
                    // ActiveLoopViewModel handles its own display text update
                    break;
                case nameof(PlaybackService.CurrentPlaybackStatus):
                    CandidateLoop.RaiseCaptureCommandsCanExecuteChanged();
                    break;
            }
            RaiseMainLoopCommandsCanExecuteChanged();
        });
    }

    private void CurrentSong_PropertyChanged(object? sender, System.ComponentModel.PropertyChangedEventArgs e)
    {
        Dispatcher.UIThread.InvokeAsync(() =>
        {
            if (sender is Song song && song == _currentSongInternal)
            {
                if (e.PropertyName == nameof(Song.SavedLoop))
                {
                    Debug.WriteLine($"[LoopEdVM] CurrentSong.SavedLoop changed for {song.Title}. Updating loop editor state.");
                    UpdateStateForCurrentSong(song);
                }
                // IsLoopActive changes are handled by ActiveLoopViewModel directly
            }
        });
    }

    private void UpdateStateForCurrentSong(Song? song)
    {
        Debug.WriteLine($"[LoopEdVM] UpdateStateForCurrentSong called for: {song?.Title ?? "null"}");
        if (song?.SavedLoop is not null)
        {
            CandidateLoop.NewLoopStartCandidate = song.SavedLoop.Start;
            CandidateLoop.NewLoopEndCandidate = song.SavedLoop.End;
        }
        else
        {
            CandidateLoop.ClearCandidates();
        }
        // ActiveLoopViewModel refreshes its state independently based on PlaybackService.CurrentSong and model changes.
        RaiseCanSaveLoopRegionChanged();
        RaiseMainLoopCommandsCanExecuteChanged();
        CandidateLoop.RaiseCaptureCommandsCanExecuteChanged();
    }

    private void SaveLoopAction(object? param)
    {
        var currentSong = _currentSongInternal;
        if (!CanSaveLoopRegion || currentSong == null || !CandidateLoop.NewLoopStartCandidate.HasValue || !CandidateLoop.NewLoopEndCandidate.HasValue)
        {
            Debug.WriteLine("[LoopEdVM] SaveLoopAction skipped: conditions not met.");
            return;
        }

        TimeSpan start = CandidateLoop.NewLoopStartCandidate.Value;
        TimeSpan end = CandidateLoop.NewLoopEndCandidate.Value;

        bool shouldBeActive = (currentSong.SavedLoop is not null && currentSong.IsLoopActive) || currentSong.SavedLoop == null;

        _songLoopService.SaveLoop(currentSong, start, end, shouldBeActive);
        // ActiveLoopViewModel and LoopEditorViewModel will react to Song model PropertyChanged events
    }

    private void ClearSavedLoopAction(object? param)
    {
        var currentSong = _currentSongInternal;
        if (currentSong is not null)
        {
            _songLoopService.ClearLoop(currentSong);
        }
        // ActiveLoopViewModel and LoopEditorViewModel will react to Song model PropertyChanged events
    }

    public void RaiseMainLoopCommandsCanExecuteChanged()
    {
        (SaveLoopCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (ClearLoopCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (WaveformSeekCommand as RelayCommand)?.RaiseCanExecuteChanged();
        // ToggleLoopActiveCommand is now in ActiveLoopViewModel
    }

    public void Dispose()
    {
        if (_currentSongInternal is not null)
        {
            _currentSongInternal.PropertyChanged -= CurrentSong_PropertyChanged;
        }
        _playbackService.PropertyChanged -= PlaybackService_PropertyChanged;
        CandidateLoop.Dispose();
        CandidateLoop.ParentLoopEditor = null;
        ActiveLoop.Dispose();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\MainWindow\MainWindowInteractionCoordinator.cs">
using System;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;
using Avalonia.Controls;
using Sonorize.Models;
using Sonorize.Services;

namespace Sonorize.ViewModels.MainWindow;

public class MainWindowInteractionCoordinator
{
    private readonly Func<Window?> _getOwnerViewFunc;
    private readonly LibraryViewModel _libraryViewModel;
    private readonly AdvancedPanelViewModel _advancedPanelViewModel;
    private readonly ApplicationWorkflowManager _workflowManager;
    private readonly SongEditInteractionService _songEditInteractionService;
    private readonly Action _raiseAllCommandsCanExecuteChangedCallback;

    public MainWindowInteractionCoordinator(
        Func<Window?> getOwnerViewFunc,
        LibraryViewModel libraryViewModel,
        AdvancedPanelViewModel advancedPanelViewModel,
        ApplicationWorkflowManager workflowManager,
        SongEditInteractionService songEditInteractionService,
        Action raiseAllCommandsCanExecuteChangedCallback)
    {
        _getOwnerViewFunc = getOwnerViewFunc ?? throw new ArgumentNullException(nameof(getOwnerViewFunc));
        _libraryViewModel = libraryViewModel ?? throw new ArgumentNullException(nameof(libraryViewModel));
        _advancedPanelViewModel = advancedPanelViewModel ?? throw new ArgumentNullException(nameof(advancedPanelViewModel));
        _workflowManager = workflowManager ?? throw new ArgumentNullException(nameof(workflowManager));
        _songEditInteractionService = songEditInteractionService ?? throw new ArgumentNullException(nameof(songEditInteractionService));
        _raiseAllCommandsCanExecuteChangedCallback = raiseAllCommandsCanExecuteChangedCallback ?? throw new ArgumentNullException(nameof(raiseAllCommandsCanExecuteChangedCallback));
    }

    public async Task<(string[] StatusMessages, bool SettingsChanged)> CoordinateAndProcessSettingsAsync()
    {
        Window? owner = _getOwnerViewFunc();
        if (owner == null || _libraryViewModel.IsLoadingLibrary)
        {
            return (["Cannot open settings: No owner window or library is loading."], false);
        }

        _advancedPanelViewModel.IsVisible = false;

        var (statusMessages, settingsChanged) = await _workflowManager.HandleOpenSettingsDialogAsync(owner);

        _raiseAllCommandsCanExecuteChangedCallback();
        return (statusMessages.ToArray(), settingsChanged);
    }
    
    public async Task<(bool RefreshedNeeded, string StatusMessage)> CoordinateAddMusicDirectoryAsync()
    {
        Window? owner = _getOwnerViewFunc();
        if (owner == null || _libraryViewModel.IsLoadingLibrary)
        {
            return (false, "Cannot add directory: No owner window or library is loading.");
        }
        _advancedPanelViewModel.IsVisible = false;

        var (directoryAdded, statusMessage) = await _workflowManager.HandleAddMusicDirectoryAsync(owner);

        _raiseAllCommandsCanExecuteChangedCallback();
        return (directoryAdded, statusMessage);
    }

    public async Task<string> CoordinateEditSongMetadataAsync(Song? songToEdit)
    {
        if (songToEdit == null)
        {
            Debug.WriteLine("[InteractionCoordinator] EditSongMetadata: songToEdit is null.");
            return "No song selected to edit.";
        }

        Window? ownerWindow = _getOwnerViewFunc();
        if (ownerWindow == null)
        {
            Debug.WriteLine("[InteractionCoordinator] EditSongMetadata: Owner window is not set.");
            return "Error: Cannot open editor, main window context lost.";
        }

        _advancedPanelViewModel.IsVisible = false;

        var (metadataSaved, statusMessage) = await _songEditInteractionService.HandleEditSongMetadataAsync(songToEdit, ownerWindow);

        _raiseAllCommandsCanExecuteChangedCallback();
        return statusMessage;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\MainWindow\MainWindowViewModel.cs">
using System;
using System.Collections.Generic; // Added for List<string>
using System.ComponentModel;
using System.Diagnostics;
using System.IO; // Required for Path.GetFullPath, Directory.Exists
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Input;
using Avalonia.Controls;
// Removed: using Avalonia.Platform.Storage; // No longer directly used here for Application.Current
using Avalonia.Threading;
using Sonorize.Models;
using Sonorize.Services;
// Removed: using Sonorize.ViewModels.Status; // StatusBarTextProvider usage moved
using Sonorize.ViewModels.LibraryManagement; // Required for LibraryDisplayModeService
using Sonorize.ViewModels.MainWindow; // Added for MainWindowInteractionCoordinator

namespace Sonorize.ViewModels;

public class MainWindowViewModel : ViewModelBase, IDisposable
{
    private readonly MainWindowComponentsManager _componentsManager;
    private Window? _ownerView;

    // Expose Services needed by views or bindings if not through child VMs
    public PlaybackService PlaybackService => _componentsManager.PlaybackServiceProperty; // Exposed from ComponentsManager
    public ThemeColors CurrentTheme { get; }

    // Expose the child ViewModels from ComponentsManager
    public LibraryViewModel Library => _componentsManager.Library;
    public LoopEditorViewModel LoopEditor => _componentsManager.LoopEditor;
    public PlaybackViewModel Playback => _componentsManager.Playback;
    public AdvancedPanelViewModel AdvancedPanel => _componentsManager.AdvancedPanel;

    public string StatusBarText { get => field; set => SetProperty(ref field, value); } = "Welcome to Sonorize!";

    private int _activeTabIndex;
    public int ActiveTabIndex
    {
        get => _activeTabIndex;
        set
        {
            if (SetProperty(ref _activeTabIndex, value))
            {
                // Playlist tab is index 3
                if (_activeTabIndex == 3)
                {
                    Library.RefreshAutoPlaylists();
                }
            }
        }
    }

    public bool IsLoadingLibrary => Library.IsLoadingLibrary;

    public bool IsAdvancedPanelVisible
    {
        get => AdvancedPanel.IsVisible;
        set
        {
            if (AdvancedPanel.IsVisible != value)
            {
                AdvancedPanel.IsVisible = value;
                OnPropertyChanged(); // AdvancedPanel will also raise its own, this is for MainWindowViewModel bindings
            }
        }
    }
    public ICommand ToggleAdvancedPanelCommand => AdvancedPanel.ToggleVisibilityCommand;

    public ICommand LoadInitialDataCommand { get; }
    public ICommand OpenSettingsCommand { get; }
    public ICommand ExitCommand { get; }
    public ICommand AddDirectoryAndRefreshCommand { get; }
    public ICommand OpenEditSongMetadataDialogCommand { get; }

    public MainWindowViewModel(
        SettingsService settingsService,
        MusicLibraryService musicLibraryService,
        PlaybackService playbackService,
        ThemeColors theme,
        WaveformService waveformService,
        LoopDataService loopDataService,
        ScrobblingService scrobblingService,
        SongMetadataService songMetadataService,
        SongEditInteractionService songEditInteractionService,
        SongLoopService songLoopService)
    {
        CurrentTheme = theme; // Store theme directly

        _componentsManager = new MainWindowComponentsManager(
            this, // Pass self as parent
            settingsService,
            musicLibraryService,
            playbackService, // Pass the service instance
            theme,
            waveformService,
            loopDataService,
            scrobblingService,
            songMetadataService,
            songEditInteractionService,
            songLoopService,
            () => _ownerView,
            RaiseAllCommandsCanExecuteChanged,
            UpdateStatusBarText,
            (propertyName) => OnPropertyChanged(propertyName)
        );

        // Commands that interact with components managed by _componentsManager
        LoadInitialDataCommand = new RelayCommand(async _ => await Library.LoadLibraryAsync(),
            _ => !Library.IsLoadingLibrary && (Playback.WaveformDisplay == null || !Playback.WaveformDisplay.IsWaveformLoading));
        OpenSettingsCommand = new RelayCommand(async _ => await OpenSettingsDialogAsync(),
            _ => !Library.IsLoadingLibrary && (Playback.WaveformDisplay == null || !Playback.WaveformDisplay.IsWaveformLoading));

        // Correctly handle exit by closing the window, which triggers the disposal chain.
        ExitCommand = new RelayCommand(_ => _ownerView?.Close(), _ => _ownerView is not null);

        AddDirectoryAndRefreshCommand = new RelayCommand(async _ => await AddMusicDirectoryAndRefreshAsync(),
            _ => !Library.IsLoadingLibrary && (Playback.WaveformDisplay == null || !Playback.WaveformDisplay.IsWaveformLoading));
        OpenEditSongMetadataDialogCommand = new RelayCommand(async song => await HandleOpenEditSongMetadataDialogAsync(song), CanOpenEditSongMetadataDialog);

        Dispatcher.UIThread.InvokeAsync(UpdateAllUIDependentStates);
    }

    public void SetOwnerView(Window ownerView)
    {
        _ownerView = ownerView;
        // Re-evaluate CanExecute for commands that depend on the owner view.
        (ExitCommand as RelayCommand)?.RaiseCanExecuteChanged();
    }

    // PlaybackService_PlaybackEndedNaturally is now handled within MainWindowComponentsManager via its WorkflowManager

    private void UpdateAllUIDependentStates()
    {
        OnPropertyChanged(nameof(IsLoadingLibrary));
        // Properties of child VMs (Playback.CurrentSong etc.) will notify through their own INPC.
        // MainWindowViewModel itself doesn't need to raise OnPropertyChanged for them unless it has direct proxy properties.
        // However, if bindings are to "Playback.CurrentSong" directly from MainWindowViewModel's XAML, they will work.
        // Let's ensure relevant top-level states that might affect commands are refreshed.
        OnPropertyChanged(nameof(IsAdvancedPanelVisible));
        OnPropertyChanged(nameof(ActiveTabIndex));

        UpdateStatusBarText();
        RaiseAllCommandsCanExecuteChanged();
    }

    public void RaiseAllCommandsCanExecuteChanged()
    {
        Dispatcher.UIThread.InvokeAsync(() =>
        {
            (LoadInitialDataCommand as RelayCommand)?.RaiseCanExecuteChanged();
            (OpenSettingsCommand as RelayCommand)?.RaiseCanExecuteChanged();
            (ExitCommand as RelayCommand)?.RaiseCanExecuteChanged();
            (AddDirectoryAndRefreshCommand as RelayCommand)?.RaiseCanExecuteChanged();
            (OpenEditSongMetadataDialogCommand as RelayCommand)?.RaiseCanExecuteChanged();

            // Child VMs manage their own command executability updates based on their state.
            // If MainWindowViewModel needs to explicitly trigger updates in child VMs' commands:
            Library.RaiseLibraryCommandsCanExecuteChanged();
            Playback.RaisePlaybackCommandCanExecuteChanged();
            LoopEditor.RaiseMainLoopCommandsCanExecuteChanged();
            // AdvancedPanel's ToggleVisibilityCommand CanExecute will be updated by AdvancedPanelViewModel itself.
        });
    }

    private void UpdateStatusBarText()
    {
        Dispatcher.UIThread.InvokeAsync(() =>
        {
            // WorkflowManager is now accessed via _componentsManager
            StatusBarText = _componentsManager.WorkflowManager.GetCurrentStatusText(LoopEditor);
        });
    }

    private async Task OpenSettingsDialogAsync()
    {
        // InteractionCoordinator is accessed via _componentsManager
        var (statusMessages, settingsChanged) = await _componentsManager.InteractionCoordinator.CoordinateAndProcessSettingsAsync();
        if (settingsChanged)
        {
            Library.LibraryDisplayModeService.ReloadDisplayPreferences();
            if (statusMessages.Any())
            {
                StatusBarText = string.Join(" | ", statusMessages);
            }
            else
            {
                UpdateStatusBarText();
            }
        }
    }

    private async Task AddMusicDirectoryAndRefreshAsync()
    {
        // InteractionCoordinator is accessed via _componentsManager
        var (refreshNeeded, statusMessage) = await _componentsManager.InteractionCoordinator.CoordinateAddMusicDirectoryAsync();
        StatusBarText = statusMessage;

        if (refreshNeeded)
        {
            await Library.LoadLibraryAsync(); // Library is from _componentsManager
        }
        else if (string.IsNullOrEmpty(statusMessage)) // If no specific message (e.g. "already exists")
        {
            UpdateStatusBarText();
        }
    }

    private async Task HandleOpenEditSongMetadataDialogAsync(object? songObject)
    {
        // InteractionCoordinator is accessed via _componentsManager
        string statusMessage = await _componentsManager.InteractionCoordinator.CoordinateEditSongMetadataAsync(songObject as Song);
        StatusBarText = statusMessage;
        if (string.IsNullOrEmpty(statusMessage)) // Ensure status bar updates if no message
        {
            UpdateStatusBarText();
        }
    }

    private bool CanOpenEditSongMetadataDialog(object? songObject)
    {
        return songObject is Song && !Library.IsLoadingLibrary && (Playback.WaveformDisplay == null || !Playback.WaveformDisplay.IsWaveformLoading);
    }

    public void Dispose()
    {
        _componentsManager?.Dispose();
        _ownerView = null;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\MainWindow\MainWindowViewModelOrchestrator.cs">
using System;
using System.ComponentModel;
using Sonorize.ViewModels;

namespace Sonorize.ViewModels;

public class MainWindowViewModelOrchestrator : IDisposable
{
    private readonly LibraryViewModel _libraryViewModel;
    private readonly PlaybackViewModel _playbackViewModel;
    private readonly AdvancedPanelViewModel _advancedPanelViewModel;

    private readonly Action _raiseAllCommandsCanExecuteChangedCallback;
    private readonly Action _updateStatusBarTextCallback;
    private readonly Action<string> _notifyMainWindowVMPropertyChangedCallback;

    public MainWindowViewModelOrchestrator(
        LibraryViewModel libraryViewModel,
        PlaybackViewModel playbackViewModel,
        AdvancedPanelViewModel advancedPanelViewModel,
        Action raiseAllCommandsCanExecuteChangedCallback,
        Action updateStatusBarTextCallback,
        Action<string> notifyMainWindowVMPropertyChangedCallback)
    {
        _libraryViewModel = libraryViewModel ?? throw new ArgumentNullException(nameof(libraryViewModel));
        _playbackViewModel = playbackViewModel ?? throw new ArgumentNullException(nameof(playbackViewModel));
        _advancedPanelViewModel = advancedPanelViewModel ?? throw new ArgumentNullException(nameof(advancedPanelViewModel));
        _raiseAllCommandsCanExecuteChangedCallback = raiseAllCommandsCanExecuteChangedCallback ?? throw new ArgumentNullException(nameof(raiseAllCommandsCanExecuteChangedCallback));
        _updateStatusBarTextCallback = updateStatusBarTextCallback ?? throw new ArgumentNullException(nameof(updateStatusBarTextCallback));
        _notifyMainWindowVMPropertyChangedCallback = notifyMainWindowVMPropertyChangedCallback ?? throw new ArgumentNullException(nameof(notifyMainWindowVMPropertyChangedCallback));

        SubscribeToEvents();
    }

    private void SubscribeToEvents()
    {
        _libraryViewModel.PropertyChanged += Library_PropertyChanged;
        _playbackViewModel.PropertyChanged += Playback_PropertyChanged;
        if (_playbackViewModel.ModeControls is not null)
        {
            _playbackViewModel.ModeControls.PropertyChanged += PlaybackModeControls_PropertyChanged;
        }
        if (_playbackViewModel.WaveformDisplay is not null)
        {
            _playbackViewModel.WaveformDisplay.PropertyChanged += PlaybackWaveformDisplay_PropertyChanged;
        }
        _advancedPanelViewModel.PropertyChanged += AdvancedPanel_PropertyChanged;
    }

    private void UnsubscribeFromEvents()
    {
        _libraryViewModel.PropertyChanged -= Library_PropertyChanged;
        _playbackViewModel.PropertyChanged -= Playback_PropertyChanged;
        if (_playbackViewModel.ModeControls is not null)
        {
            _playbackViewModel.ModeControls.PropertyChanged -= PlaybackModeControls_PropertyChanged;
        }
        if (_playbackViewModel.WaveformDisplay is not null)
        {
            _playbackViewModel.WaveformDisplay.PropertyChanged -= PlaybackWaveformDisplay_PropertyChanged;
        }
        _advancedPanelViewModel.PropertyChanged -= AdvancedPanel_PropertyChanged;
    }

    private void PlaybackWaveformDisplay_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName == nameof(WaveformDisplayViewModel.IsWaveformLoading))
        {
            _raiseAllCommandsCanExecuteChangedCallback();
        }
    }

    private void AdvancedPanel_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName == nameof(AdvancedPanelViewModel.IsVisible))
        {
            _notifyMainWindowVMPropertyChangedCallback(nameof(MainWindowViewModel.IsAdvancedPanelVisible));
            _raiseAllCommandsCanExecuteChangedCallback();
        }
    }

    private void Library_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        switch (e.PropertyName)
        {
            case nameof(LibraryViewModel.SelectedSong):
                _raiseAllCommandsCanExecuteChangedCallback();
                break;
            case nameof(LibraryViewModel.IsLoadingLibrary):
                _notifyMainWindowVMPropertyChangedCallback(nameof(MainWindowViewModel.IsLoadingLibrary));
                _raiseAllCommandsCanExecuteChangedCallback();
                _updateStatusBarTextCallback();
                break;
            case nameof(LibraryViewModel.LibraryStatusText):
                _updateStatusBarTextCallback();
                break;
        }
    }

    private void Playback_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        switch (e.PropertyName)
        {
            case nameof(PlaybackViewModel.CurrentSong):
                _notifyMainWindowVMPropertyChangedCallback(nameof(MainWindowViewModel.Playback.CurrentSong)); // Or just rely on MainWindowViewModel.Playback being the source
                _notifyMainWindowVMPropertyChangedCallback(nameof(MainWindowViewModel.Playback.HasCurrentSong));
                _raiseAllCommandsCanExecuteChangedCallback();
                _updateStatusBarTextCallback();
                _notifyMainWindowVMPropertyChangedCallback(nameof(MainWindowViewModel.Playback.CurrentTimeDisplay));
                _notifyMainWindowVMPropertyChangedCallback(nameof(MainWindowViewModel.Playback.TotalTimeDisplay));
                break;
            case nameof(PlaybackViewModel.CurrentPlaybackStatus):
                _notifyMainWindowVMPropertyChangedCallback(nameof(MainWindowViewModel.Playback.CurrentPlaybackStatus));
                _notifyMainWindowVMPropertyChangedCallback(nameof(MainWindowViewModel.Playback.IsPlaying));
                _updateStatusBarTextCallback();
                _raiseAllCommandsCanExecuteChangedCallback();
                break;
            case nameof(PlaybackViewModel.CurrentPosition):
                _notifyMainWindowVMPropertyChangedCallback(nameof(MainWindowViewModel.Playback.CurrentPosition));
                _notifyMainWindowVMPropertyChangedCallback(nameof(MainWindowViewModel.Playback.CurrentPositionSeconds));
                _notifyMainWindowVMPropertyChangedCallback(nameof(MainWindowViewModel.Playback.CurrentTimeDisplay));
                break;
            case nameof(PlaybackViewModel.CurrentSongDuration):
                _notifyMainWindowVMPropertyChangedCallback(nameof(MainWindowViewModel.Playback.CurrentSongDuration));
                _notifyMainWindowVMPropertyChangedCallback(nameof(MainWindowViewModel.Playback.CurrentSongDurationSeconds));
                _notifyMainWindowVMPropertyChangedCallback(nameof(MainWindowViewModel.Playback.TotalTimeDisplay));
                _raiseAllCommandsCanExecuteChangedCallback();
                break;
        }
    }

    private void PlaybackModeControls_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        switch (e.PropertyName)
        {
            case nameof(PlaybackModeViewModel.ShuffleEnabled):
            case nameof(PlaybackModeViewModel.RepeatMode):
                _playbackViewModel.RaisePlaybackCommandCanExecuteChanged(); // PlaybackVM raises its own commands
                _updateStatusBarTextCallback();
                break;
        }
    }

    public void Dispose()
    {
        UnsubscribeFromEvents();
        GC.SuppressFinalize(this);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\Settings\AppearanceSettingsViewModel.cs">
using System;
using Sonorize.Models;
using Sonorize.Services;

namespace Sonorize.ViewModels.Settings
{
    public class AppearanceSettingsViewModel : ViewModelBase
    {
        private readonly Action _notifyParentSettingsChanged;

        public GridViewImageType ArtistGridType { get; set; }
        public GridViewImageType AlbumGridType { get; set; }
        public GridViewImageType PlaylistGridType { get; set; }

        private readonly GridViewImageType _initialArtistGridType;
        private readonly GridViewImageType _initialAlbumGridType;
        private readonly GridViewImageType _initialPlaylistGridType;
        
        public bool IsArtistGridSingle
        {
            get => ArtistGridType == GridViewImageType.Single;
            set { if (value && ArtistGridType != GridViewImageType.Single) { ArtistGridType = GridViewImageType.Single; OnAppearanceChanged(); } }
        }
        public bool IsArtistGridComposite
        {
            get => ArtistGridType == GridViewImageType.Composite;
            set { if (value && ArtistGridType != GridViewImageType.Composite) { ArtistGridType = GridViewImageType.Composite; OnAppearanceChanged(); } }
        }

        public bool IsAlbumGridSingle
        {
            get => AlbumGridType == GridViewImageType.Single;
            set { if (value && AlbumGridType != GridViewImageType.Single) { AlbumGridType = GridViewImageType.Single; OnAppearanceChanged(); } }
        }
        public bool IsAlbumGridComposite
        {
            get => AlbumGridType == GridViewImageType.Composite;
            set { if (value && AlbumGridType != GridViewImageType.Composite) { AlbumGridType = GridViewImageType.Composite; OnAppearanceChanged(); } }
        }

        public bool IsPlaylistGridSingle
        {
            get => PlaylistGridType == GridViewImageType.Single;
            set { if (value && PlaylistGridType != GridViewImageType.Single) { PlaylistGridType = GridViewImageType.Single; OnAppearanceChanged(); } }
        }
        public bool IsPlaylistGridComposite
        {
            get => PlaylistGridType == GridViewImageType.Composite;
            set { if (value && PlaylistGridType != GridViewImageType.Composite) { PlaylistGridType = GridViewImageType.Composite; OnAppearanceChanged(); } }
        }

        public bool HasChangesFromInitialState => _initialArtistGridType != ArtistGridType ||
                                                  _initialAlbumGridType != AlbumGridType ||
                                                  _initialPlaylistGridType != PlaylistGridType;

        public AppearanceSettingsViewModel(AppSettings settings, Action notifyParentSettingsChanged)
        {
            _notifyParentSettingsChanged = notifyParentSettingsChanged ?? throw new ArgumentNullException(nameof(notifyParentSettingsChanged));
            
            _initialArtistGridType = Enum.TryParse<GridViewImageType>(settings.ArtistGridViewImageType, out var agt) ? agt : GridViewImageType.Composite;
            _initialAlbumGridType = Enum.TryParse<GridViewImageType>(settings.AlbumGridViewImageType, out var alhgt) ? alhgt : GridViewImageType.Composite;
            _initialPlaylistGridType = Enum.TryParse<GridViewImageType>(settings.PlaylistGridViewImageType, out var pgt) ? pgt : GridViewImageType.Composite;

            ArtistGridType = _initialArtistGridType;
            AlbumGridType = _initialAlbumGridType;
            PlaylistGridType = _initialPlaylistGridType;
        }

        private void OnAppearanceChanged()
        {
            OnPropertyChanged(nameof(IsArtistGridSingle));
            OnPropertyChanged(nameof(IsArtistGridComposite));
            OnPropertyChanged(nameof(IsAlbumGridSingle));
            OnPropertyChanged(nameof(IsAlbumGridComposite));
            OnPropertyChanged(nameof(IsPlaylistGridSingle));
            OnPropertyChanged(nameof(IsPlaylistGridComposite));
            OnPropertyChanged(nameof(HasChangesFromInitialState));
            _notifyParentSettingsChanged();
        }

        public void UpdateAppSettings(AppSettings settings)
        {
            settings.ArtistGridViewImageType = ArtistGridType.ToString();
            settings.AlbumGridViewImageType = AlbumGridType.ToString();
            settings.PlaylistGridViewImageType = PlaylistGridType.ToString();
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\Settings\MusicDirectoriesSettingsViewModel.cs">
using Avalonia.Controls;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Input;
using Avalonia.Platform.Storage;

namespace Sonorize.ViewModels;

public class MusicDirectoriesSettingsViewModel : ViewModelBase
{
    private readonly Action _notifyParentSettingsChanged;

    public ObservableCollection<string> MusicDirectories { get; }
    public List<string> InitialMusicDirectories { get; }

    public string? SelectedDirectory
    {
        get;
        set
        {
            if (SetProperty(ref field, value))
            {
                (RemoveDirectoryCommand as RelayCommand)?.RaiseCanExecuteChanged();
            }
        }
    }

    public ICommand AddDirectoryCommand { get; }
    public ICommand RemoveDirectoryCommand { get; }

    public bool CanRemoveDirectory => SelectedDirectory is not null;

    // This property can be used by the parent to quickly check if this specific section has changes
    // compared to its initial state when the settings dialog was opened.
    public bool HasChangesFromInitialState => !InitialMusicDirectories.SequenceEqual(MusicDirectories);

    public MusicDirectoriesSettingsViewModel(IEnumerable<string> initialDirs, Action notifyParentSettingsChanged)
    {
        _notifyParentSettingsChanged = notifyParentSettingsChanged ?? throw new ArgumentNullException(nameof(notifyParentSettingsChanged));
        InitialMusicDirectories = new List<string>(initialDirs);
        MusicDirectories = new ObservableCollection<string>(initialDirs);

        AddDirectoryCommand = new RelayCommand(async owner => await AddDirectoryAsync(owner as Window));
        RemoveDirectoryCommand = new RelayCommand(RemoveSelectedDirectoryAction, _ => CanRemoveDirectory);

        MusicDirectories.CollectionChanged += (s, e) => {
            _notifyParentSettingsChanged(); // Notify parent that some UI interaction happened
            OnPropertyChanged(nameof(HasChangesFromInitialState)); // Notify that this section's state might have changed
        };
    }

    private async Task AddDirectoryAsync(Window? owner)
    {
        if (owner?.StorageProvider == null)
        {
            Debug.WriteLine("[MusicDirSettingsVM] StorageProvider is not available for AddDirectory.");
            return;
        }

        var options = new FolderPickerOpenOptions
        {
            Title = "Select Music Directory",
            AllowMultiple = false
        };

        var result = await owner.StorageProvider.OpenFolderPickerAsync(options);

        if (result?.Count > 0)
        {
            var folder = result.FirstOrDefault();
            if (folder == null) return;

            string? path = null;
            try
            {
                // Attempt to get a usable local path
                if (folder.Path.IsAbsoluteUri) path = folder.Path.LocalPath;
                else path = folder.Name; // Fallback or handle relative paths if necessary

                if (!string.IsNullOrEmpty(path))
                {
                    path = Path.GetFullPath(path); // Normalize
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[MusicDirSettingsVM] Error processing path {folder.Path}: {ex.Message}");
                // Optionally inform user about path issue
                return;
            }

            if (!string.IsNullOrEmpty(path) && Directory.Exists(path) && !MusicDirectories.Contains(path))
            {
                MusicDirectories.Add(path); // Triggers CollectionChanged
            }
            else if (!string.IsNullOrEmpty(path) && !Directory.Exists(path))
            {
                Debug.WriteLine($"[MusicDirSettingsVM] Selected path does not exist or is not a directory: {path}");
                // Optionally inform user
            }
        }
    }

    private void RemoveSelectedDirectoryAction(object? parameter)
    {
        if (SelectedDirectory is null)
        {
            return;
        }

        MusicDirectories.Remove(SelectedDirectory); // Triggers CollectionChanged
        SelectedDirectory = null; // Triggers PropertyChanged for UI
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\Settings\SettingsViewModel.cs">
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Input;
using Avalonia.Controls;
// Removed: using Avalonia.Platform.Storage; // No longer directly used here
using Sonorize.Models; // Required for AppSettings type
using Sonorize.Services;
using Sonorize.ViewModels.Settings;

namespace Sonorize.ViewModels;

public enum SettingsViewSection
{
    Directories,
    Theme,
    Appearance,
    Scrobbling
}

public class SettingsViewModel : ViewModelBase
{
    private readonly SettingsService _settingsService;
    private readonly SettingsPersistenceManager _settingsPersistenceManager;

    public MusicDirectoriesSettingsViewModel MusicDirectoriesSettings { get; }
    public ThemeSettingsViewModel ThemeSettings { get; }
    public AppearanceSettingsViewModel AppearanceSettings { get; }
    public LastfmSettingsViewModel LastfmSettings { get; }


    public bool SettingsChanged { get; private set; } = false;

    private SettingsViewSection _currentSettingsViewSection = SettingsViewSection.Directories;
    public SettingsViewSection CurrentSettingsViewSection
    {
        get => _currentSettingsViewSection;
        set => SetProperty(ref _currentSettingsViewSection, value);
    }

    public ICommand SaveAndCloseCommand { get; }
    public ICommand ShowDirectoriesSettingsCommand { get; }
    public ICommand ShowThemeSettingsCommand { get; }
    public ICommand ShowAppearanceSettingsCommand { get; }
    public ICommand ShowScrobblingSettingsCommand { get; }


    public SettingsViewModel(SettingsService settingsService)
    {
        _settingsService = settingsService;
        _settingsPersistenceManager = new SettingsPersistenceManager(settingsService);

        var settings = _settingsService.LoadSettings();

        MusicDirectoriesSettings = new MusicDirectoriesSettingsViewModel(settings.MusicDirectories, MarkSettingsChanged);

        var themeServiceForChild = new ThemeService(settings.PreferredThemeFileName);
        ThemeSettings = new ThemeSettingsViewModel(settings.PreferredThemeFileName, themeServiceForChild, MarkSettingsChanged);
        
        AppearanceSettings = new AppearanceSettingsViewModel(settings, MarkSettingsChanged);

        LastfmSettings = new LastfmSettingsViewModel();
        LastfmSettings.LoadFromSettings(settings);
        LastfmSettings.PropertyChanged += (s, e) => MarkSettingsChanged();


        SettingsChanged = false; // Initial state is unchanged

        SaveAndCloseCommand = new RelayCommand(SaveSettings);

        ShowDirectoriesSettingsCommand = new RelayCommand(_ => CurrentSettingsViewSection = SettingsViewSection.Directories);
        ShowThemeSettingsCommand = new RelayCommand(_ => CurrentSettingsViewSection = SettingsViewSection.Theme);
        ShowAppearanceSettingsCommand = new RelayCommand(_ => CurrentSettingsViewSection = SettingsViewSection.Appearance);
        ShowScrobblingSettingsCommand = new RelayCommand(_ => CurrentSettingsViewSection = SettingsViewSection.Scrobbling);
    }

    private void MarkSettingsChanged()
    {
        if (SettingsChanged)
        {
            return;
        }

        SettingsChanged = true;
        Debug.WriteLine("[SettingsVM] Settings marked as changed (UI interaction or child VM).");
    }

    private void SaveSettings(object? parameter)
    {
        AppSettings settingsOnDisk = _settingsService.LoadSettings();

        bool changesPersisted = _settingsPersistenceManager.ApplyAndSaveChanges(
            settingsOnDisk,
            this.MusicDirectoriesSettings,
            this.ThemeSettings,
            this.LastfmSettings,
            this.AppearanceSettings
        );

        if (changesPersisted)
        {
            this.SettingsChanged = true;
            Debug.WriteLine("[SettingsVM] Changes were persisted by SettingsPersistenceManager.");
        }
        else
        {
            this.SettingsChanged = false;
            Debug.WriteLine("[SettingsVM] No changes were persisted by SettingsPersistenceManager.");
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\ViewModels\Settings\ThemeSettingsViewModel.cs">
using System;
using System.Collections.ObjectModel;
using System.Linq;
using Sonorize.Services; // For ThemeService

namespace Sonorize.ViewModels;

public class ThemeSettingsViewModel : ViewModelBase
{
    private readonly ThemeService _themeService;
    private readonly Action _notifyParentSettingsChanged;

    public ObservableCollection<string> AvailableThemes { get; } = new();

    public string? SelectedThemeFile
    {
        get;
        set
        {
            if (!SetProperty(ref field, value))
            {
                return;
            }

            _notifyParentSettingsChanged();
            OnPropertyChanged(nameof(HasChangesFromInitialState));
        }
    }

    public string InitialSelectedThemeFile { get; }

    public bool HasChangesFromInitialState => InitialSelectedThemeFile != SelectedThemeFile;

    public ThemeSettingsViewModel(string? initialSelectedTheme, ThemeService themeService, Action notifyParentSettingsChanged)
    {
        _themeService = themeService ?? throw new ArgumentNullException(nameof(themeService));
        _notifyParentSettingsChanged = notifyParentSettingsChanged ?? throw new ArgumentNullException(nameof(notifyParentSettingsChanged));

        InitialSelectedThemeFile = initialSelectedTheme ?? ThemeService.DefaultThemeFileName;

        foreach (var themeFile in _themeService.GetAvailableThemeFiles())
        {
            AvailableThemes.Add(themeFile);
        }

        SelectedThemeFile = InitialSelectedThemeFile;
        if (!AvailableThemes.Contains(SelectedThemeFile) && AvailableThemes.Any())
        {
            SelectedThemeFile = AvailableThemes.First(); // Fallback if preferred theme not found
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Views\MainWindow\MainWindowComponentsManager.cs">
using System;
using System.ComponentModel;
using Avalonia.Controls;
using Sonorize.Models;
using Sonorize.Services;
using Sonorize.ViewModels.LibraryManagement; // Required for LibraryDisplayModeService

namespace Sonorize.ViewModels.MainWindow;

public class MainWindowComponentsManager : IDisposable
{
    // Keep direct service references if they are passed to multiple components
    // or if MainWindowViewModel needs them directly (though preferably through properties here)
    private readonly SettingsService _settingsService;
    private readonly MusicLibraryService _musicLibraryService;
    // PlaybackService is now a property for MainWindowViewModel to expose
    public PlaybackService PlaybackServiceProperty { get; }
    private readonly ThemeColors _currentTheme;
    private readonly WaveformService _waveformService;
    private readonly LoopDataService _loopDataService;
    public ScrobblingService ScrobblingServiceProperty { get; } // Exposed for MainWindowViewModel
    private readonly SongMetadataService _songMetadataService;
    private readonly SongEditInteractionService _songEditInteractionService;
    private readonly SongLoopService _songLoopService;

    public LibraryViewModel Library { get; }
    public PlaybackViewModel Playback { get; }
    public LoopEditorViewModel LoopEditor { get; }
    public AdvancedPanelViewModel AdvancedPanel { get; }
    public LibraryDisplayModeService LibraryDisplayModeService { get; }
    public ApplicationWorkflowManager WorkflowManager { get; }
    public MainWindowInteractionCoordinator InteractionCoordinator { get; }
    public MainWindowViewModelOrchestrator ViewModelOrchestrator { get; }

    public MainWindowComponentsManager(
        MainWindowViewModel parentMainWindowViewModel,
        SettingsService settingsService,
        MusicLibraryService musicLibraryService,
        PlaybackService playbackService, // Renamed for clarity from _playbackService
        ThemeColors currentTheme,
        WaveformService waveformService,
        LoopDataService loopDataService,
        ScrobblingService scrobblingService,
        SongMetadataService songMetadataService,
        SongEditInteractionService songEditInteractionService,
        SongLoopService songLoopService,
        Func<Window?> getOwnerViewFunc,
        Action raiseAllCommandsCanExecuteChangedCallback,
        Action updateStatusBarTextCallback,
        Action<string> notifyMainWindowVMPropertyChangedCallback)
    {
        _settingsService = settingsService;
        _musicLibraryService = musicLibraryService;
        PlaybackServiceProperty = playbackService; // Store the passed service
        _currentTheme = currentTheme;
        _waveformService = waveformService;
        _loopDataService = loopDataService;
        ScrobblingServiceProperty = scrobblingService; // Store the passed service
        _songMetadataService = songMetadataService;
        _songEditInteractionService = songEditInteractionService;
        _songLoopService = songLoopService;

        LibraryDisplayModeService = new LibraryDisplayModeService(_settingsService);
        // Pass parentMainWindowViewModel to LibraryViewModel as per its constructor
        Library = new LibraryViewModel(parentMainWindowViewModel, _settingsService, _musicLibraryService, _loopDataService, LibraryDisplayModeService);
        Playback = new PlaybackViewModel(PlaybackServiceProperty, _waveformService); // Use the stored PlaybackService
        LoopEditor = new LoopEditorViewModel(PlaybackServiceProperty, _loopDataService, _songLoopService); // Use stored PlaybackService
        AdvancedPanel = new AdvancedPanelViewModel(Playback, Library);

        WorkflowManager = new ApplicationWorkflowManager(
            _settingsService,
            ScrobblingServiceProperty, // Use stored ScrobblingService
            _currentTheme,
            Library,
            Playback,
            PlaybackServiceProperty, // Use stored PlaybackService
            _loopDataService);

        InteractionCoordinator = new MainWindowInteractionCoordinator(
            getOwnerViewFunc,
            Library,
            AdvancedPanel,
            WorkflowManager,
            _songEditInteractionService,
            raiseAllCommandsCanExecuteChangedCallback
        );

        ViewModelOrchestrator = new MainWindowViewModelOrchestrator(
            Library,
            Playback,
            AdvancedPanel,
            raiseAllCommandsCanExecuteChangedCallback,
            updateStatusBarTextCallback,
            notifyMainWindowVMPropertyChangedCallback
        );

        // Subscribe to PlaybackServiceProperty events here, as this manager owns the WorkflowManager that handles it.
        PlaybackServiceProperty.PlaybackEndedNaturally += PlaybackService_PlaybackEndedNaturally;
    }

    private void PlaybackService_PlaybackEndedNaturally(object? sender, EventArgs e)
    {
        // WorkflowManager is instantiated and owned by this ComponentsManager
        WorkflowManager.HandlePlaybackEndedNaturally();
    }

    public void Dispose()
    {
        if (PlaybackServiceProperty is not null)
        {
            PlaybackServiceProperty.PlaybackEndedNaturally -= PlaybackService_PlaybackEndedNaturally;
        }
        ViewModelOrchestrator?.Dispose();
        WorkflowManager?.Dispose();
        Library?.Dispose();
        Playback?.Dispose();
        AdvancedPanel?.Dispose();
        LoopEditor?.Dispose();
        // LibraryDisplayModeService does not currently implement IDisposable
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Views\MainWindowControls\AdvancedPlaybackPanelControls.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Controls.Primitives; // For Thumb
using Avalonia.Data;
using Avalonia.Layout;
using Avalonia.Media;
using Avalonia.Styling;
using Sonorize.Controls;
using Sonorize.Converters;
using Sonorize.Models; // For ThemeColors
using Sonorize.ViewModels; // For MainWindowViewModel, LoopEditorViewModel

namespace Sonorize.Views.MainWindowControls;

public static class AdvancedPlaybackPanelControls
{
    public static Border Create(ThemeColors theme)
    {
        var panelRoot = new Border
        {
            Background = theme.B_SlightlyLighterBackground,
            Padding = new Thickness(10),
            BorderBrush = theme.B_AccentColor,
            BorderThickness = new Thickness(0, 1, 0, 1),
            MinHeight = 180,
            ClipToBounds = true
        };
        var mainStack = new StackPanel { Spacing = 10 };

        // Speed and Pitch Controls
        var speedPitchGrid = new Grid { ColumnDefinitions = new ColumnDefinitions("Auto,*,Auto,15,Auto,*,Auto"), Margin = new Thickness(0, 0, 0, 5) };
        var speedLabel = new TextBlock { Text = "Tempo:", VerticalAlignment = VerticalAlignment.Center, Foreground = theme.B_TextColor, Margin = new Thickness(0, 0, 5, 0) };
        var speedSlider = new Slider { Minimum = 0.5, Maximum = 2.0, SmallChange = 0.05, LargeChange = 0.25, TickFrequency = 0.25, Foreground = theme.B_AccentColor, Background = theme.B_SecondaryTextColor };
        speedSlider.Styles.Add(new Style(s => s.Is<Thumb>()) { Setters = { new Setter(TemplatedControl.BackgroundProperty, theme.B_AccentColor) } });
        speedSlider.Bind(Slider.ValueProperty, new Binding("Playback.EffectsControls.PlaybackSpeed", BindingMode.TwoWay)); // Updated binding
        var speedDisplay = new TextBlock { VerticalAlignment = VerticalAlignment.Center, Margin = new Thickness(5, 0), Foreground = theme.B_TextColor, MinWidth = 35, HorizontalAlignment = HorizontalAlignment.Right };
        speedDisplay.Bind(TextBlock.TextProperty, new Binding("Playback.EffectsControls.PlaybackSpeedDisplay")); // Updated binding

        var pitchLabel = new TextBlock { Text = "Pitch:", VerticalAlignment = VerticalAlignment.Center, Foreground = theme.B_TextColor, Margin = new Thickness(0, 0, 5, 0) };
        var pitchSlider = new Slider { Minimum = -4, Maximum = 4, SmallChange = 0.1, LargeChange = 0.5, TickFrequency = 0.5, Foreground = theme.B_AccentColor, Background = theme.B_SecondaryTextColor };
        pitchSlider.Styles.Add(new Style(s => s.Is<Thumb>()) { Setters = { new Setter(TemplatedControl.BackgroundProperty, theme.B_AccentColor) } });
        pitchSlider.Bind(Slider.ValueProperty, new Binding("Playback.EffectsControls.PlaybackPitch", BindingMode.TwoWay)); // Updated binding
        var pitchDisplay = new TextBlock { VerticalAlignment = VerticalAlignment.Center, Margin = new Thickness(5, 0), Foreground = theme.B_TextColor, MinWidth = 45, HorizontalAlignment = HorizontalAlignment.Right };
        pitchDisplay.Bind(TextBlock.TextProperty, new Binding("Playback.EffectsControls.PlaybackPitchDisplay")); // Updated binding

        Grid.SetColumn(speedLabel, 0); Grid.SetColumn(speedSlider, 1); Grid.SetColumn(speedDisplay, 2);
        Grid.SetColumn(pitchLabel, 4); Grid.SetColumn(pitchSlider, 5); Grid.SetColumn(pitchDisplay, 6);
        speedPitchGrid.Children.Add(speedLabel); speedPitchGrid.Children.Add(speedSlider); speedPitchGrid.Children.Add(speedDisplay);
        speedPitchGrid.Children.Add(pitchLabel); speedPitchGrid.Children.Add(pitchSlider); speedPitchGrid.Children.Add(pitchDisplay);
        mainStack.Children.Add(speedPitchGrid);

        // Waveform Display
        Color accentColorForLoopRegion = (theme.B_AccentColor as ISolidColorBrush)?.Color ?? Colors.Orange;
        var waveformDisplay = new WaveformDisplayControl
        {
            Height = 80,
            MinHeight = 60,
            Background = theme.B_ControlBackgroundColor,
            WaveformBrush = theme.B_AccentColor,
            PositionMarkerBrush = Brushes.OrangeRed,
            LoopRegionBrush = new SolidColorBrush(accentColorForLoopRegion, 0.3)
        };
        waveformDisplay.Bind(WaveformDisplayControl.WaveformPointsProperty, new Binding("Playback.WaveformDisplay.WaveformRenderData"));
        waveformDisplay.Bind(WaveformDisplayControl.CurrentPositionProperty, new Binding("Playback.CurrentPosition"));
        waveformDisplay.Bind(WaveformDisplayControl.DurationProperty, new Binding("Playback.CurrentSongDuration"));
        waveformDisplay.Bind(WaveformDisplayControl.ActiveLoopProperty, new Binding("Playback.PlaybackService.CurrentSong.SavedLoop"));
        waveformDisplay.SeekRequested += (s, time) =>
        {
            if (s is Control { DataContext: MainWindowViewModel mainWindowVM })
            {
                mainWindowVM.LoopEditor.WaveformSeekCommand.Execute(time);
            }
        };

        var waveformLoadingIndicator = new ProgressBar { IsIndeterminate = true, Height = 5, Margin = new Thickness(0, -5, 0, 0), Foreground = theme.B_AccentColor, Background = Brushes.Transparent };
        waveformLoadingIndicator.Bind(Visual.IsVisibleProperty, new Binding("Playback.WaveformDisplay.IsWaveformLoading"));
        var waveformContainer = new Panel();
        waveformContainer.Children.Add(waveformDisplay); waveformContainer.Children.Add(waveformLoadingIndicator);
        mainStack.Children.Add(waveformContainer);

        // Loop Controls
        var loopControlsOuterPanel = new StackPanel { Orientation = Orientation.Vertical, Spacing = 5, Margin = new Thickness(0, 10, 0, 0) };
        var loopDefinitionLabel = new TextBlock { Text = "Define Loop:", FontSize = 12, FontWeight = FontWeight.SemiBold, Foreground = theme.B_TextColor };
        var loopActionsPanel = new StackPanel { Orientation = Orientation.Horizontal, Spacing = 8, VerticalAlignment = VerticalAlignment.Center };

        var setStartBtn = new Button { Content = "A", FontSize = 12, Padding = new Thickness(10, 5), MinWidth = 40, Background = theme.B_ControlBackgroundColor, Foreground = theme.B_TextColor };
        setStartBtn.Bind(Button.CommandProperty, new Binding("LoopEditor.CaptureLoopStartCandidateCommand"));
        var startDisp = new TextBlock { FontSize = 11, Margin = new Thickness(3, 0), VerticalAlignment = VerticalAlignment.Center, Foreground = theme.B_SecondaryTextColor, MinWidth = 60 };
        startDisp.Bind(TextBlock.TextProperty, new Binding("LoopEditor.CandidateLoop.NewLoopStartCandidateDisplay")); // Points to CandidateLoop

        var setEndBtn = new Button { Content = "B", FontSize = 12, Padding = new Thickness(10, 5), MinWidth = 40, Background = theme.B_ControlBackgroundColor, Foreground = theme.B_TextColor };
        setEndBtn.Bind(Button.CommandProperty, new Binding("LoopEditor.CaptureLoopEndCandidateCommand"));
        var endDisp = new TextBlock { FontSize = 11, Margin = new Thickness(3, 0), VerticalAlignment = VerticalAlignment.Center, Foreground = theme.B_SecondaryTextColor, MinWidth = 60 };
        endDisp.Bind(TextBlock.TextProperty, new Binding("LoopEditor.CandidateLoop.NewLoopEndCandidateDisplay")); // Points to CandidateLoop

        var saveLoopBtn = new Button { Content = "Save Loop", FontSize = 11, Padding = new Thickness(10, 5), Background = theme.B_AccentColor, Foreground = theme.B_AccentForeground };
        saveLoopBtn.Bind(Button.CommandProperty, new Binding("LoopEditor.SaveLoopCommand"));
        saveLoopBtn.Bind(Button.IsEnabledProperty, new Binding("LoopEditor.CanSaveLoopRegion"));

        var clearLoopBtn = new Button { Content = "Clear Loop", FontSize = 11, Padding = new Thickness(10, 5), Background = theme.B_ControlBackgroundColor, Foreground = theme.B_TextColor };
        clearLoopBtn.Bind(Button.CommandProperty, new Binding("LoopEditor.ClearLoopCommand"));
        var clearLoopBinding = new Binding("PlaybackService.CurrentSong.SavedLoop") { Converter = NotNullToBooleanConverter.Instance };
        clearLoopBtn.Bind(Button.IsEnabledProperty, clearLoopBinding);

        loopActionsPanel.Children.Add(setStartBtn); loopActionsPanel.Children.Add(startDisp);
        loopActionsPanel.Children.Add(setEndBtn); loopActionsPanel.Children.Add(endDisp);
        loopActionsPanel.Children.Add(saveLoopBtn); loopActionsPanel.Children.Add(clearLoopBtn);

        var loopActiveTogglePanel = new StackPanel { Orientation = Orientation.Horizontal, Margin = new Thickness(0, 8, 0, 0), Spacing = 8, VerticalAlignment = VerticalAlignment.Center };
        var loopActiveCheckBox = new CheckBox { Content = "Activate Loop", Foreground = theme.B_TextColor, VerticalAlignment = VerticalAlignment.Center };
        // Bind to the new ActiveLoopViewModel
        loopActiveCheckBox.Bind(ToggleButton.IsCheckedProperty, new Binding("LoopEditor.ActiveLoop.IsLoopActive", BindingMode.TwoWay));
        var loopActiveCheckBoxIsEnabledBinding = new Binding("PlaybackService.CurrentSong.SavedLoop") { Converter = NotNullToBooleanConverter.Instance };
        loopActiveCheckBox.Bind(Control.IsEnabledProperty, loopActiveCheckBoxIsEnabledBinding);
        loopActiveTogglePanel.Children.Add(loopActiveCheckBox);

        loopControlsOuterPanel.Children.Add(loopDefinitionLabel);
        loopControlsOuterPanel.Children.Add(loopActionsPanel);
        loopControlsOuterPanel.Children.Add(loopActiveTogglePanel);
        mainStack.Children.Add(loopControlsOuterPanel);

        panelRoot.Child = mainStack;
        return panelRoot;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Views\MainWindowControls\ArtistItemTemplateProvider.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Controls.Templates;
using Avalonia.Data;
using Avalonia.Layout;
using Avalonia.Media;
using Avalonia.Media.Imaging;
using Sonorize.Converters;
using Sonorize.Models; // For ThemeColors
using Sonorize.ViewModels; // For ArtistViewModel
using System.Diagnostics;

namespace Sonorize.Views.MainWindowControls;

public class ArtistItemTemplateProvider
{
    private readonly ThemeColors _theme;

    public FuncDataTemplate<ArtistViewModel> DetailedArtistTemplate { get; private set; }
    public FuncDataTemplate<ArtistViewModel> CompactArtistTemplate { get; private set; }
    public FuncDataTemplate<ArtistViewModel> GridArtistTemplate { get; private set; }

    public ArtistItemTemplateProvider(ThemeColors theme)
    {
        _theme = theme;
        Debug.WriteLine("[ArtistItemTemplateProvider] Initialized.");
        InitializeArtistTemplates();
    }

    private void InitializeArtistTemplates()
    {
        DetailedArtistTemplate = new FuncDataTemplate<ArtistViewModel>((dataContext, nameScope) =>
        {
            var image = new Image { Width = 32, Height = 32, Margin = new Thickness(5, 0, 10, 0), Stretch = Stretch.UniformToFill };
            image.Bind(Image.SourceProperty, new Binding(nameof(ArtistViewModel.Thumbnail)));
            RenderOptions.SetBitmapInterpolationMode(image, BitmapInterpolationMode.HighQuality);

            var artistNameBlock = new TextBlock { FontSize = 14, VerticalAlignment = VerticalAlignment.Center };
            artistNameBlock.Bind(TextBlock.TextProperty, new Binding(nameof(ArtistViewModel.Name)));

            var itemGrid = new Grid { ColumnDefinitions = new ColumnDefinitions("Auto,*"), VerticalAlignment = VerticalAlignment.Center };
            itemGrid.Children.Add(image); itemGrid.Children.Add(artistNameBlock);
            Grid.SetColumn(image, 0); Grid.SetColumn(artistNameBlock, 1);
            return new Border { Padding = new Thickness(10, 8), MinHeight = 44, Background = Brushes.Transparent, Child = itemGrid };
        }, supportsRecycling: true);

        CompactArtistTemplate = new FuncDataTemplate<ArtistViewModel>((dataContext, nameScope) =>
        {
            var artistNameBlock = new TextBlock { FontSize = 12, VerticalAlignment = VerticalAlignment.Center, TextTrimming = TextTrimming.CharacterEllipsis };
            artistNameBlock.Bind(TextBlock.TextProperty, new Binding(nameof(ArtistViewModel.Name)));
            return new Border { Padding = new Thickness(10, 4, 10, 4), MinHeight = 30, Background = Brushes.Transparent, Child = artistNameBlock };
        }, supportsRecycling: true);

        GridArtistTemplate = new FuncDataTemplate<ArtistViewModel>((dataContext, nameScope) =>
        {
            var imagePresenter = new Panel { Width = 80, Height = 80, HorizontalAlignment = HorizontalAlignment.Center };

            // Composite 4-image grid
            var imageGrid = new Grid
            {
                Width = 80,
                Height = 80,
                HorizontalAlignment = HorizontalAlignment.Center,
                ColumnDefinitions = new ColumnDefinitions("*,*"),
                RowDefinitions = new RowDefinitions("*,*")
            };
            for (int i = 0; i < 4; i++)
            {
                var img = new Image { Width = 38, Height = 38, Stretch = Stretch.UniformToFill, Margin = new Thickness(1) };
                img.Bind(Image.SourceProperty, new Binding($"SongThumbnailsForGrid[{i}]"));
                RenderOptions.SetBitmapInterpolationMode(img, BitmapInterpolationMode.HighQuality);
                Grid.SetRow(img, i / 2); Grid.SetColumn(img, i % 2);
                imageGrid.Children.Add(img);
            }
            imageGrid.Bind(Visual.IsVisibleProperty, new MultiBinding
            {
                Converter = new GridViewImageVisibilityConverter { TargetType = GridViewImageType.Composite },
                Bindings =
                {
                    new Binding(nameof(ArtistViewModel.SongThumbnailsForGrid)),
                    new Binding("DataContext.Library.LibraryDisplayModeService.ArtistGridDisplayType")
                    {
                        RelativeSource = new RelativeSource(RelativeSourceMode.FindAncestor)
                        {
                            AncestorType = typeof(Window)
                        }
                    }
                }
            });

            // Single representative image
            var singleImage = new Image { Width = 80, Height = 80, Stretch = Stretch.UniformToFill, HorizontalAlignment = HorizontalAlignment.Center };
            singleImage.Bind(Image.SourceProperty, new Binding(nameof(ArtistViewModel.Thumbnail)));
            RenderOptions.SetBitmapInterpolationMode(singleImage, BitmapInterpolationMode.HighQuality);
            singleImage.Bind(Visual.IsVisibleProperty, new MultiBinding
            {
                Converter = new GridViewImageVisibilityConverter { TargetType = GridViewImageType.Single },
                Bindings =
                {
                    new Binding(nameof(ArtistViewModel.SongThumbnailsForGrid)),
                    new Binding("DataContext.Library.LibraryDisplayModeService.ArtistGridDisplayType")
                    {
                        RelativeSource = new RelativeSource(RelativeSourceMode.FindAncestor)
                        {
                            AncestorType = typeof(Window)
                        }
                    }
                }
            });

            imagePresenter.Children.Add(imageGrid);
            imagePresenter.Children.Add(singleImage);

            var artistNameBlock = new TextBlock { FontSize = 12, FontWeight = FontWeight.SemiBold, TextWrapping = TextWrapping.Wrap, MaxHeight = 30, TextAlignment = TextAlignment.Center, HorizontalAlignment = HorizontalAlignment.Center, Margin = new Thickness(0, 3, 0, 0) };
            artistNameBlock.Bind(TextBlock.TextProperty, new Binding(nameof(ArtistViewModel.Name)));

            var contentStack = new StackPanel { Orientation = Orientation.Vertical, HorizontalAlignment = HorizontalAlignment.Center, Spacing = 2, Children = { imagePresenter, artistNameBlock } };
            return new Border { Width = 120, Height = 130, Background = Brushes.Transparent, Padding = new Thickness(5), Child = contentStack, HorizontalAlignment = HorizontalAlignment.Center, VerticalAlignment = VerticalAlignment.Center };
        }, supportsRecycling: true);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Views\MainWindowControls\DataGridViewFactory.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Controls.Templates;
using Avalonia.Data;
using Avalonia.Data.Converters;
using Avalonia.Layout;
using Avalonia.Media;
using Avalonia.Styling;
using Sonorize.Models;
using Sonorize.ViewModels;
using System.Diagnostics;

namespace Sonorize.Views.MainWindowControls
{
    public class DataGridViewFactory
    {
        private readonly ThemeColors _theme;
        private readonly SongContextMenuHelper _contextMenuHelper;

        public DataGridViewFactory(ThemeColors theme, SongContextMenuHelper contextMenuHelper)
        {
            _theme = theme;
            _contextMenuHelper = contextMenuHelper;
            Debug.WriteLine("[DataGridViewFactory] Initialized.");
        }

        // Method for Songs DataGrid
        public Control CreateSongsDataGrid(string itemsSourcePath, string selectedItemPath)
        {
            var dataGrid = CreateBaseDataGrid(itemsSourcePath, selectedItemPath);

            dataGrid.Columns.Add(new DataGridTextColumn { Header = "Title", Binding = new Binding("Title"), Width = new DataGridLength(3, DataGridLengthUnitType.Star) });
            dataGrid.Columns.Add(new DataGridTextColumn { Header = "Artist", Binding = new Binding("Artist"), Width = new DataGridLength(2, DataGridLengthUnitType.Star) });
            dataGrid.Columns.Add(new DataGridTextColumn { Header = "Album", Binding = new Binding("Album"), Width = new DataGridLength(2, DataGridLengthUnitType.Star) });
            dataGrid.Columns.Add(new DataGridTextColumn { Header = "Duration", Binding = new Binding("DurationString"), Width = new DataGridLength(0.7, DataGridLengthUnitType.Star) });

            ApplyDataGridStyles(dataGrid, _theme, true);
            return new DockPanel { Children = { dataGrid } };
        }

        public Control CreateCompactSongsDataGrid(string itemsSourcePath, string selectedItemPath)
        {
            var dataGrid = CreateBaseDataGrid(itemsSourcePath, selectedItemPath);

            dataGrid.RowHeight = 32;

            dataGrid.Columns.Add(new DataGridTextColumn { Header = "Title", Binding = new Binding("Title"), Width = new DataGridLength(4, DataGridLengthUnitType.Star) });
            dataGrid.Columns.Add(new DataGridTextColumn { Header = "Artist", Binding = new Binding("Artist"), Width = new DataGridLength(2, DataGridLengthUnitType.Star) });
            dataGrid.Columns.Add(new DataGridTextColumn { Header = "Duration", Binding = new Binding("DurationString"), Width = new DataGridLength(0.7, DataGridLengthUnitType.Star) });

            ApplyDataGridStyles(dataGrid, _theme, true);
            return new DockPanel { Children = { dataGrid } };
        }

        // Method for Artists DataGrid
        public Control CreateArtistsDataGrid(string itemsSourcePath, string selectedItemPath)
        {
            var dataGrid = CreateBaseDataGrid(itemsSourcePath, selectedItemPath);
            dataGrid.Columns.Add(new DataGridTextColumn { Header = "Artist", Binding = new Binding("Name"), Width = new DataGridLength(1, DataGridLengthUnitType.Star) });
            dataGrid.Columns.Add(new DataGridTextColumn { Header = "Songs", Binding = new Binding("SongCount"), Width = new DataGridLength(0.5, DataGridLengthUnitType.Star) });
            ApplyDataGridStyles(dataGrid, _theme, false);
            return new DockPanel { Children = { dataGrid } };
        }

        // Method for Albums DataGrid
        public Control CreateAlbumsDataGrid(string itemsSourcePath, string selectedItemPath)
        {
            var dataGrid = CreateBaseDataGrid(itemsSourcePath, selectedItemPath);
            dataGrid.Columns.Add(new DataGridTextColumn { Header = "Album", Binding = new Binding("Title"), Width = new DataGridLength(2, DataGridLengthUnitType.Star) });
            dataGrid.Columns.Add(new DataGridTextColumn { Header = "Artist", Binding = new Binding("Artist"), Width = new DataGridLength(2, DataGridLengthUnitType.Star) });
            dataGrid.Columns.Add(new DataGridTextColumn { Header = "Songs", Binding = new Binding("SongCount"), Width = new DataGridLength(0.5, DataGridLengthUnitType.Star) });
            ApplyDataGridStyles(dataGrid, _theme, false);
            return new DockPanel { Children = { dataGrid } };
        }

        // Method for Playlists DataGrid
        public Control CreatePlaylistsDataGrid(string itemsSourcePath, string selectedItemPath)
        {
            var dataGrid = CreateBaseDataGrid(itemsSourcePath, selectedItemPath);
            dataGrid.Columns.Add(new DataGridTextColumn { Header = "Playlist", Binding = new Binding("Name"), Width = new DataGridLength(2, DataGridLengthUnitType.Star) });
            dataGrid.Columns.Add(new DataGridTextColumn { Header = "Songs", Binding = new Binding("SongCount"), Width = new DataGridLength(1, DataGridLengthUnitType.Star) });
            // For auto-playlist icon
            var typeColumn = new DataGridTemplateColumn
            {
                Header = "Type",
                Width = new DataGridLength(0.5, DataGridLengthUnitType.Star)
            };
            typeColumn.CellTemplate = new FuncDataTemplate<PlaylistViewModel>((vm, ns) =>
            {
                var icon = new TextBlock { FontSize = 12, Text = "Auto", VerticalAlignment = VerticalAlignment.Center };
                icon.Bind(Visual.IsVisibleProperty, new Binding(nameof(PlaylistViewModel.IsAutoPlaylist)));
                return icon;
            });
            dataGrid.Columns.Add(typeColumn);
            ApplyDataGridStyles(dataGrid, _theme, false);
            return new DockPanel { Children = { dataGrid } };
        }


        private DataGrid CreateBaseDataGrid(string itemsSourcePath, string selectedItemPath)
        {
            var dataGrid = new DataGrid
            {
                AutoGenerateColumns = false,
                IsReadOnly = true,
                CanUserResizeColumns = true,
                CanUserReorderColumns = true,
                GridLinesVisibility = DataGridGridLinesVisibility.Horizontal,
                Background = _theme.B_ListBoxBackground,
                BorderThickness = new Thickness(0),
                HeadersVisibility = DataGridHeadersVisibility.Column,
                RowHeight = 36 // A bit more spacious for readability
            };

            dataGrid.Bind(ItemsControl.ItemsSourceProperty, new Binding(itemsSourcePath));
            dataGrid.Bind(DataGrid.SelectedItemProperty, new Binding(selectedItemPath, BindingMode.TwoWay));

            return dataGrid;
        }

        private void ApplyDataGridStyles(DataGrid dataGrid, ThemeColors theme, bool addSongContextMenu)
        {
            // Column Header Style
            dataGrid.Styles.Add(new Style(s => s.Is<DataGridColumnHeader>())
            {
                Setters =
                {
                    new Setter(DataGridColumnHeader.BackgroundProperty, theme.B_SlightlyLighterBackground),
                    new Setter(DataGridColumnHeader.ForegroundProperty, theme.B_TextColor),
                    new Setter(DataGridColumnHeader.BorderBrushProperty, theme.B_ControlBackgroundColor),
                    new Setter(DataGridColumnHeader.BorderThicknessProperty, new Thickness(0,0,1,1)),
                    new Setter(DataGridColumnHeader.PaddingProperty, new Thickness(8,5)),
                    new Setter(DataGridColumnHeader.VerticalContentAlignmentProperty, VerticalAlignment.Center),
                }
            });

            // Row Style
            var rowStyle = new Style(s => s.Is<DataGridRow>())
            {
                Setters =
                {
                    new Setter(DataGridRow.BackgroundProperty, Brushes.Transparent),
                    new Setter(DataGridRow.ForegroundProperty, theme.B_TextColor),
                    new Setter(DataGridRow.BorderThicknessProperty, new Thickness(0)),
                }
            };

            dataGrid.Styles.Add(new Style(s => s.Is<DataGridRow>().Class(":pointerover"))
            {
                Setters =
                {
                    new Setter(DataGridRow.BackgroundProperty, theme.B_ControlBackgroundColor)
                }
            });

            dataGrid.Styles.Add(new Style(s => s.Is<DataGridRow>().Class(":selected"))
            {
                Setters =
                {
                    new Setter(DataGridRow.BackgroundProperty, theme.B_AccentColor),
                    new Setter(DataGridRow.ForegroundProperty, theme.B_AccentForeground)
                }
            });

            // Cell Style
            dataGrid.Styles.Add(new Style(s => s.Is<DataGridCell>())
            {
                Setters =
                {
                    new Setter(DataGridCell.BorderThicknessProperty, new Thickness(0)),
                    new Setter(DataGridCell.PaddingProperty, new Thickness(8)),
                    new Setter(DataGridCell.VerticalContentAlignmentProperty, VerticalAlignment.Center),
                }
            });

            // Selected cell foreground needs to be accent foreground
            dataGrid.Styles.Add(new Style(s => s.Is<DataGridRow>().Class(":selected").Descendant().Is<TextBlock>())
            {
                Setters =
                {
                    new Setter(TextBlock.ForegroundProperty, theme.B_AccentForeground),
                }
            });

            if (addSongContextMenu)
            {
                rowStyle.Setters.Add(new Setter(Control.ContextMenuProperty, _contextMenuHelper.CreateSongContextMenu()));
            }

            dataGrid.Styles.Add(rowStyle);
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Views\MainWindowControls\ListBoxViewFactory.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Controls.Primitives;
using Avalonia.Controls.Templates; // Required for IDataTemplate
using Avalonia.Data;
using Avalonia.Media;
using Avalonia.Styling;
using Sonorize.Models; // For ThemeColors
using Sonorize.ViewModels; // For Binding paths (though not directly used for VM types here)
using System; // For Action

namespace Sonorize.Views.MainWindowControls;

public static class ListBoxViewFactory
{
    public static (ScrollViewer ScrollViewer, ListBox ListBox) CreateStyledListBoxScrollViewer(
        ThemeColors theme,
        SharedViewTemplates sharedViewTemplates,
        string name,
        string itemsSourcePath,
        string selectedItemPath,
        IDataTemplate initialItemTemplate,
        ITemplate<Panel> initialItemsPanelTemplate,
        Action<ListBox> storeInstanceCallback)
    {
        var listBoxInstance = new ListBox
        {
            Background = theme.B_ListBoxBackground,
            BorderThickness = new Thickness(0),
            Margin = new Thickness(10),
            Name = name
        };

        ApplyListBoxItemStyles(listBoxInstance, theme);

        listBoxInstance.Bind(ItemsControl.ItemsSourceProperty, new Binding(itemsSourcePath));
        listBoxInstance.Bind(ListBox.SelectedItemProperty, new Binding(selectedItemPath, BindingMode.TwoWay));

        listBoxInstance.ItemTemplate = initialItemTemplate;
        listBoxInstance.ItemsPanel = initialItemsPanelTemplate; // Correct direct assignment

        storeInstanceCallback(listBoxInstance);

        var scrollViewer = new ScrollViewer
        {
            Content = listBoxInstance,
            Padding = new Thickness(0, 0, 0, 5),
            HorizontalScrollBarVisibility = ScrollBarVisibility.Disabled
        };
        return (scrollViewer, listBoxInstance);
    }

    private static void ApplyListBoxItemStyles(ListBox listBox, ThemeColors theme)
    {
        listBox.Styles.Add(new Style(s => s.Is<ListBoxItem>())
        {
            Setters = {
                new Setter(TemplatedControl.BackgroundProperty, theme.B_ListBoxBackground),
                new Setter(TextBlock.ForegroundProperty, theme.B_TextColor),
                new Setter(ListBoxItem.PaddingProperty, new Thickness(3))
            }
        });
        listBox.Styles.Add(new Style(s => s.Is<ListBoxItem>().Class(":pointerover").Not(xx => xx.Class(":selected")))
        { Setters = { new Setter(TemplatedControl.BackgroundProperty, theme.B_ControlBackgroundColor) } });
        listBox.Styles.Add(new Style(s => s.Is<ListBoxItem>().Class(":selected"))
        {
            Setters = {
                new Setter(TemplatedControl.BackgroundProperty, theme.B_AccentColor),
                new Setter(TextBlock.ForegroundProperty, theme.B_AccentForeground)
            }
        });
        listBox.Styles.Add(new Style(s => s.Is<ListBoxItem>().Class(":selected").Class(":pointerover"))
        {
            Setters = {
                new Setter(TemplatedControl.BackgroundProperty, theme.B_AccentColor),
                new Setter(TextBlock.ForegroundProperty, theme.B_AccentForeground)
            }
        });
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Views\MainWindowControls\MainMenu.cs">
using Avalonia.Controls;
using Avalonia.Data;
using Sonorize.Models; // For ThemeColors
using Sonorize.ViewModels; // For SongDisplayMode enum

namespace Sonorize.Views.MainWindowControls;

public static class MainMenu
{
    public static Menu Create(ThemeColors theme, Window ownerWindow)
    {
        var menu = new Menu
        {
            Background = theme.B_SlightlyLighterBackground,
            Foreground = theme.B_TextColor
        };

        // File Menu
        var fileMenuItem = new MenuItem { Header = "_File", Foreground = theme.B_TextColor };
        var addDirectoryMenuItem = new MenuItem { Header = "_Add Music Directory...", Foreground = theme.B_TextColor };
        addDirectoryMenuItem.Bind(MenuItem.CommandProperty, new Binding("AddDirectoryAndRefreshCommand"));
        addDirectoryMenuItem.CommandParameter = ownerWindow;

        var settingsMenuItem = new MenuItem { Header = "_Settings...", Foreground = theme.B_TextColor };
        settingsMenuItem.Bind(MenuItem.CommandProperty, new Binding("OpenSettingsCommand"));
        settingsMenuItem.CommandParameter = ownerWindow;

        var exitMenuItem = new MenuItem { Header = "E_xit", Foreground = theme.B_TextColor };
        exitMenuItem.Bind(MenuItem.CommandProperty, new Binding("ExitCommand"));

        fileMenuItem.Items.Add(addDirectoryMenuItem);
        fileMenuItem.Items.Add(settingsMenuItem);
        fileMenuItem.Items.Add(new Separator());
        fileMenuItem.Items.Add(exitMenuItem);

        // View Menu
        var viewMenuItem = new MenuItem { Header = "_View", Foreground = theme.B_TextColor };

        // Library View SubMenu
        var libraryViewSubMenu = new MenuItem { Header = "Library View", Foreground = theme.B_TextColor };
        var libDetailed = new MenuItem { Header = "Detailed", Foreground = theme.B_TextColor };
        libDetailed.Bind(MenuItem.CommandProperty, new Binding("Library.SetDisplayModeCommand"));
        libDetailed.CommandParameter = ("Library", SongDisplayMode.Detailed);
        var libCompact = new MenuItem { Header = "Compact", Foreground = theme.B_TextColor };
        libCompact.Bind(MenuItem.CommandProperty, new Binding("Library.SetDisplayModeCommand"));
        libCompact.CommandParameter = ("Library", SongDisplayMode.Compact);
        var libGrid = new MenuItem { Header = "Grid", Foreground = theme.B_TextColor };
        libGrid.Bind(MenuItem.CommandProperty, new Binding("Library.SetDisplayModeCommand"));
        libGrid.CommandParameter = ("Library", SongDisplayMode.Grid);
        libraryViewSubMenu.Items.Add(libDetailed);
        libraryViewSubMenu.Items.Add(libCompact);
        libraryViewSubMenu.Items.Add(libGrid);

        // Artists View SubMenu
        var artistsViewSubMenu = new MenuItem { Header = "Artists View", Foreground = theme.B_TextColor };
        var artDetailed = new MenuItem { Header = "Detailed", Foreground = theme.B_TextColor };
        artDetailed.Bind(MenuItem.CommandProperty, new Binding("Library.SetDisplayModeCommand"));
        artDetailed.CommandParameter = ("Artists", SongDisplayMode.Detailed);
        var artCompact = new MenuItem { Header = "Compact", Foreground = theme.B_TextColor };
        artCompact.Bind(MenuItem.CommandProperty, new Binding("Library.SetDisplayModeCommand"));
        artCompact.CommandParameter = ("Artists", SongDisplayMode.Compact);
        var artGrid = new MenuItem { Header = "Grid", Foreground = theme.B_TextColor };
        artGrid.Bind(MenuItem.CommandProperty, new Binding("Library.SetDisplayModeCommand"));
        artGrid.CommandParameter = ("Artists", SongDisplayMode.Grid);
        artistsViewSubMenu.Items.Add(artDetailed);
        artistsViewSubMenu.Items.Add(artCompact);
        artistsViewSubMenu.Items.Add(artGrid);

        // Albums View SubMenu
        var albumsViewSubMenu = new MenuItem { Header = "Albums View", Foreground = theme.B_TextColor };
        var albDetailed = new MenuItem { Header = "Detailed", Foreground = theme.B_TextColor };
        albDetailed.Bind(MenuItem.CommandProperty, new Binding("Library.SetDisplayModeCommand"));
        albDetailed.CommandParameter = ("Albums", SongDisplayMode.Detailed);
        var albCompact = new MenuItem { Header = "Compact", Foreground = theme.B_TextColor };
        albCompact.Bind(MenuItem.CommandProperty, new Binding("Library.SetDisplayModeCommand"));
        albCompact.CommandParameter = ("Albums", SongDisplayMode.Compact);
        var albGrid = new MenuItem { Header = "Grid", Foreground = theme.B_TextColor };
        albGrid.Bind(MenuItem.CommandProperty, new Binding("Library.SetDisplayModeCommand"));
        albGrid.CommandParameter = ("Albums", SongDisplayMode.Grid);
        albumsViewSubMenu.Items.Add(albDetailed);
        albumsViewSubMenu.Items.Add(albCompact);
        albumsViewSubMenu.Items.Add(albGrid);
        
        // Playlists View SubMenu
        var playlistsViewSubMenu = new MenuItem { Header = "Playlists View", Foreground = theme.B_TextColor };
        var playDetailed = new MenuItem { Header = "Detailed", Foreground = theme.B_TextColor };
        playDetailed.Bind(MenuItem.CommandProperty, new Binding("Library.SetDisplayModeCommand"));
        playDetailed.CommandParameter = ("Playlists", SongDisplayMode.Detailed);
        var playCompact = new MenuItem { Header = "Compact", Foreground = theme.B_TextColor };
        playCompact.Bind(MenuItem.CommandProperty, new Binding("Library.SetDisplayModeCommand"));
        playCompact.CommandParameter = ("Playlists", SongDisplayMode.Compact);
        var playGrid = new MenuItem { Header = "Grid", Foreground = theme.B_TextColor };
        playGrid.Bind(MenuItem.CommandProperty, new Binding("Library.SetDisplayModeCommand"));
        playGrid.CommandParameter = ("Playlists", SongDisplayMode.Grid);
        playlistsViewSubMenu.Items.Add(playDetailed);
        playlistsViewSubMenu.Items.Add(playCompact);
        playlistsViewSubMenu.Items.Add(playGrid);

        viewMenuItem.Items.Add(libraryViewSubMenu);
        viewMenuItem.Items.Add(artistsViewSubMenu);
        viewMenuItem.Items.Add(albumsViewSubMenu);
        viewMenuItem.Items.Add(playlistsViewSubMenu);

        menu.Items.Add(fileMenuItem);
        menu.Items.Add(viewMenuItem);
        return menu;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Views\MainWindowControls\MainPlaybackControlsPanel.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Data;
using Avalonia.Data.Converters; // Added required using directive for FuncValueConverter
using Avalonia.Layout;
using Avalonia.Media;
using Sonorize.Models;

namespace Sonorize.Views.MainWindowControls;

public static class MainPlaybackControlsPanel
{
    public static Grid Create(ThemeColors theme) // Root is a Grid
    {
        // --- Playback Navigation Buttons Panel (Extracted) ---
        var combinedPlaybackButtonControlsPanel = PlaybackNavigationButtonsPanel.Create(theme);

        var toggleAdvPanelButton = new Button
        {
            Content = "+",
            Background = theme.B_SlightlyLighterBackground,
            Foreground = theme.B_TextColor, // Default color
            BorderBrush = theme.B_ControlBackgroundColor, // Default border color
            BorderThickness = new Thickness(1),
            CornerRadius = new CornerRadius(3),
            Padding = new Thickness(8, 4),
            MinWidth = 30, // Give it a minimum size to occupy space
            FontWeight = FontWeight.Bold,
            Width = 32, // Fixed width for consistency
            Height = 32, // Fixed height for consistency
            HorizontalContentAlignment = HorizontalAlignment.Center, // Center content horizontally
            VerticalContentAlignment = VerticalAlignment.Center     // Center content vertically
        };
        // Change BorderBrush color based on IsAdvancedPanelVisible
        toggleAdvPanelButton[!Button.BorderBrushProperty] = new Binding("IsAdvancedPanelVisible")
        {
            Converter = new FuncValueConverter<bool, IBrush>(isVisible => isVisible ? theme.B_AccentColor : theme.B_ControlBackgroundColor)
        };
        toggleAdvPanelButton[!Button.ForegroundProperty] = new Binding("IsAdvancedPanelVisible")
        {
            Converter = new FuncValueConverter<bool, IBrush>(isVisible => isVisible ? theme.B_AccentColor : theme.B_TextColor)
        };
        toggleAdvPanelButton.Bind(Button.CommandProperty, new Binding("ToggleAdvancedPanelCommand"));
        toggleAdvPanelButton.Bind(Control.IsEnabledProperty, new Binding("Playback.HasCurrentSong"));


        var rightControlsPanel = new StackPanel // Holds toggle button
        {
            Orientation = Orientation.Horizontal,
            Spacing = 5,
            VerticalAlignment = VerticalAlignment.Center,
            HorizontalAlignment = HorizontalAlignment.Right, // Align to the right within its grid cell
            Margin = new Thickness(0, 0, 10, 0) // Margin from the right edge of the grid cell
            // MinWidth/Width could be added here if needed to reserve space even when invisible
        };
        rightControlsPanel.Children.Add(toggleAdvPanelButton);

        // --- Playback Time Slider Panel (Extracted) ---
        var timeSliderGrid = PlaybackTimeSliderPanel.Create(theme);


        // --- Center Playback Controls Stack (Combined Buttons Panel + Slider) ---
        // This stack panel contains the combined button panel (now includes shuffle/loop, prev/play/next) and the time/slider grid.
        var centerPlaybackControlsStack = new StackPanel
        {
            Orientation = Orientation.Vertical,
            Margin = new Thickness(0, 5, 0, 0),
            Spacing = 8, // Space between the button row and the slider row
            HorizontalAlignment = HorizontalAlignment.Center, // Center this stack panel within its parent grid cell
            VerticalAlignment = VerticalAlignment.Center
        };
        // Add the combined button panel (now includes shuffle/loop, prev/play/next)
        centerPlaybackControlsStack.Children.Add(combinedPlaybackButtonControlsPanel);
        centerPlaybackControlsStack.Children.Add(timeSliderGrid);


        // --- Currently Playing Song Info Panel (Extracted) ---
        var songInfoPanel = SongInfoDisplayPanel.Create(theme);


        // --- Main Grid Layout (Restored Single Column Centering) ---
        // Use a single star (*) column. All children are placed in this column.
        // Their HorizontalAlignment determines their position within the column.
        // The centerPlaybackControlsStack has HorizontalAlignment.Center, ensuring it's centered
        // regardless of the width of the left (songInfoPanel) or right (rightControlsPanel) elements.
        var outerGrid = new Grid // This is the root panel
        {
            Background = theme.B_BackgroundColor,
            Margin = new Thickness(0, 5, 0, 5), // Vertical margin for the whole control
            HorizontalAlignment = HorizontalAlignment.Stretch,
            RowDefinitions = new RowDefinitions("Auto"), // Single row, height is Auto based on content
            ColumnDefinitions = new ColumnDefinitions("*") // Single column spanning the width
        };

        // Place all panels in the single column (column 0).
        // Their HorizontalAlignment will handle horizontal positioning.
        Grid.SetColumn(songInfoPanel, 0);
        Grid.SetColumn(centerPlaybackControlsStack, 0);
        Grid.SetColumn(rightControlsPanel, 0);

        // Add children in any order; their position is determined by grid layout and alignment.
        outerGrid.Children.Add(songInfoPanel);
        outerGrid.Children.Add(centerPlaybackControlsStack);
        outerGrid.Children.Add(rightControlsPanel);

        return outerGrid;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Views\MainWindowControls\MainTabViewControls.cs">
using System.Diagnostics;
using Avalonia;
using Avalonia.Controls;
using Avalonia.Controls.Primitives;
using Avalonia.Controls.Templates;
using Avalonia.Data;
using Avalonia.Data.Converters;
using Avalonia.Media;
using Avalonia.Styling;
using Sonorize.Models;
using Sonorize.ViewModels;

namespace Sonorize.Views.MainWindowControls;

public class MainTabViewControls
{
    private readonly ThemeColors _theme;
    private readonly SharedViewTemplates _sharedViewTemplates;

    // View controls for each tab
    private Control _songsDetailedView, _songsCompactView, _songsGridView;
    private Control _artistsDetailedView, _artistsCompactView, _artistsGridView;
    private Control _albumsDetailedView, _albumsCompactView, _albumsGridView;
    private Control _playlistsDetailedView, _playlistsCompactView, _playlistsGridView;


    public MainTabViewControls(ThemeColors theme, SharedViewTemplates sharedViewTemplates)
    {
        _theme = theme;
        _sharedViewTemplates = sharedViewTemplates;
        CreateAllViews();
    }

    private void CreateAllViews()
    {
        // Library (Song) Views
        _songsDetailedView = _sharedViewTemplates.DataGridTemplates.CreateSongsDataGrid("Library.FilteredSongs", "Library.SelectedSong");
        _songsCompactView = _sharedViewTemplates.DataGridTemplates.CreateCompactSongsDataGrid("Library.FilteredSongs", "Library.SelectedSong");
        var (songsGridScrollViewer, _) = ListBoxViewFactory.CreateStyledListBoxScrollViewer(
            _theme, _sharedViewTemplates, "SongGridListBox", "Library.FilteredSongs", "Library.SelectedSong",
            _sharedViewTemplates.SongTemplates.GridSongTemplate, _sharedViewTemplates.WrapPanelItemsPanelTemplate,
            lb => { });
        _songsGridView = songsGridScrollViewer;

        // Artists Views
        _artistsDetailedView = _sharedViewTemplates.DataGridTemplates.CreateArtistsDataGrid("Library.Groupings.Artists", "Library.FilterState.SelectedArtist");
        var (artistsCompactScrollViewer, _) = ListBoxViewFactory.CreateStyledListBoxScrollViewer(
            _theme, _sharedViewTemplates, "ArtistCompactListBox", "Library.Groupings.Artists", "Library.FilterState.SelectedArtist",
            _sharedViewTemplates.ArtistTemplates.CompactArtistTemplate, _sharedViewTemplates.StackPanelItemsPanelTemplate,
            lb => { });
        _artistsCompactView = artistsCompactScrollViewer;
        var (artistsGridScrollViewer, _) = ListBoxViewFactory.CreateStyledListBoxScrollViewer(
            _theme, _sharedViewTemplates, "ArtistsGridListBox", "Library.Groupings.Artists", "Library.FilterState.SelectedArtist",
            _sharedViewTemplates.ArtistTemplates.GridArtistTemplate, _sharedViewTemplates.WrapPanelItemsPanelTemplate,
             lb => { });
        _artistsGridView = artistsGridScrollViewer;

        // Albums Views
        _albumsDetailedView = _sharedViewTemplates.DataGridTemplates.CreateAlbumsDataGrid("Library.Groupings.Albums", "Library.FilterState.SelectedAlbum");
        var (albumsCompactScrollViewer, _) = ListBoxViewFactory.CreateStyledListBoxScrollViewer(
            _theme, _sharedViewTemplates, "AlbumCompactListBox", "Library.Groupings.Albums", "Library.FilterState.SelectedAlbum",
            _sharedViewTemplates.CompactAlbumTemplate, _sharedViewTemplates.StackPanelItemsPanelTemplate,
             lb => { });
        _albumsCompactView = albumsCompactScrollViewer;
        var (albumsGridScrollViewer, _) = ListBoxViewFactory.CreateStyledListBoxScrollViewer(
            _theme, _sharedViewTemplates, "AlbumsGridListBox", "Library.Groupings.Albums", "Library.FilterState.SelectedAlbum",
            _sharedViewTemplates.GridAlbumTemplate, _sharedViewTemplates.WrapPanelItemsPanelTemplate,
            lb => { });
        _albumsGridView = albumsGridScrollViewer;

        // Playlists Views
        _playlistsDetailedView = _sharedViewTemplates.DataGridTemplates.CreatePlaylistsDataGrid("Library.Groupings.Playlists", "Library.FilterState.SelectedPlaylist");
        var (playlistsCompactScrollViewer, _) = ListBoxViewFactory.CreateStyledListBoxScrollViewer(
            _theme, _sharedViewTemplates, "PlaylistCompactListBox", "Library.Groupings.Playlists", "Library.FilterState.SelectedPlaylist",
            _sharedViewTemplates.CompactPlaylistTemplate, _sharedViewTemplates.StackPanelItemsPanelTemplate,
            lb => { });
        _playlistsCompactView = playlistsCompactScrollViewer;
        var (playlistsGridScrollViewer, _) = ListBoxViewFactory.CreateStyledListBoxScrollViewer(
            _theme, _sharedViewTemplates, "PlaylistsGridListBox", "Library.Groupings.Playlists", "Library.FilterState.SelectedPlaylist",
            _sharedViewTemplates.GridPlaylistTemplate, _sharedViewTemplates.WrapPanelItemsPanelTemplate,
            lb => { });
        _playlistsGridView = playlistsGridScrollViewer;
    }


    public TabControl CreateMainTabView()
    {
        var tabControl = new TabControl
        {
            Background = _theme.B_BackgroundColor,
            Margin = new Thickness(10, 5, 10, 5),
            BorderThickness = new Thickness(0),
            Padding = new Thickness(0)
        };
        tabControl.Bind(TabControl.SelectedIndexProperty, new Binding("ActiveTabIndex", BindingMode.TwoWay));

        var tabItemStyle = new Style(s => s.Is<TabItem>());
        tabItemStyle.Setters.Add(new Setter(TabItem.BackgroundProperty, _theme.B_BackgroundColor));
        tabItemStyle.Setters.Add(new Setter(TabItem.ForegroundProperty, _theme.B_SecondaryTextColor));
        tabItemStyle.Setters.Add(new Setter(TabItem.PaddingProperty, new Thickness(12, 7)));
        tabItemStyle.Setters.Add(new Setter(TabItem.FontSizeProperty, 13.0));
        tabItemStyle.Setters.Add(new Setter(TabItem.FontWeightProperty, FontWeight.SemiBold));
        tabItemStyle.Setters.Add(new Setter(TabItem.BorderThicknessProperty, new Thickness(0)));
        tabItemStyle.Setters.Add(new Setter(TabItem.BorderBrushProperty, Brushes.Transparent));

        var selectedTabItemStyle = new Style(s => s.Is<TabItem>().Class(":selected"));
        selectedTabItemStyle.Setters.Add(new Setter(TabItem.BackgroundProperty, _theme.B_BackgroundColor));
        selectedTabItemStyle.Setters.Add(new Setter(TabItem.ForegroundProperty, _theme.B_TextColor));

        var pointerOverTabItemStyle = new Style(s => s.Is<TabItem>().Class(":pointerover").Not(x => x.Class(":selected")));
        pointerOverTabItemStyle.Setters.Add(new Setter(TabItem.BackgroundProperty, _theme.B_SlightlyLighterBackground));
        pointerOverTabItemStyle.Setters.Add(new Setter(TabItem.ForegroundProperty, _theme.B_TextColor));

        tabControl.Styles.Add(tabItemStyle);
        tabControl.Styles.Add(selectedTabItemStyle);
        tabControl.Styles.Add(pointerOverTabItemStyle);

        var viewModeToIntConverter = new FuncValueConverter<SongDisplayMode, int>(mode => (int)mode);

        // Library Tab
        var libraryCarousel = new Carousel { ItemsSource = new Control[] { _songsDetailedView, _songsCompactView, _songsGridView } };
        libraryCarousel.Bind(Carousel.SelectedIndexProperty, new Binding("Library.LibraryViewMode", BindingMode.OneWay) { Converter = viewModeToIntConverter });
        var libraryTab = new TabItem { Header = "LIBRARY", Content = libraryCarousel };

        // Artists Tab
        var artistsCarousel = new Carousel { ItemsSource = new Control[] { _artistsDetailedView, _artistsCompactView, _artistsGridView } };
        artistsCarousel.Bind(Carousel.SelectedIndexProperty, new Binding("Library.ArtistViewMode", BindingMode.OneWay) { Converter = viewModeToIntConverter });
        var artistsTab = new TabItem { Header = "ARTISTS", Content = artistsCarousel };

        // Albums Tab
        var albumsCarousel = new Carousel { ItemsSource = new Control[] { _albumsDetailedView, _albumsCompactView, _albumsGridView } };
        albumsCarousel.Bind(Carousel.SelectedIndexProperty, new Binding("Library.AlbumViewMode", BindingMode.OneWay) { Converter = viewModeToIntConverter });
        var albumsTab = new TabItem { Header = "ALBUMS", Content = albumsCarousel };

        // Playlists Tab
        var playlistsCarousel = new Carousel { ItemsSource = new Control[] { _playlistsDetailedView, _playlistsCompactView, _playlistsGridView } };
        playlistsCarousel.Bind(Carousel.SelectedIndexProperty, new Binding("Library.PlaylistViewMode", BindingMode.OneWay) { Converter = viewModeToIntConverter });
        var playlistsTab = new TabItem { Header = "PLAYLISTS", Content = playlistsCarousel };

        tabControl.Items.Add(libraryTab);
        tabControl.Items.Add(artistsTab);
        tabControl.Items.Add(albumsTab);
        tabControl.Items.Add(playlistsTab);

        return tabControl;
    }

    public void UpdateListViewMode(string viewName, SongDisplayMode mode)
    {
        // This method is now obsolete as the Carousel handles view switching via binding.
        // It is no longer called by MainWindow.
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Views\MainWindowControls\PlaybackNavigationButtonsPanel.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Controls.Primitives;
using Avalonia.Data;
using Avalonia.Data.Converters;
using Avalonia.Layout;
using Avalonia.Media;
using Sonorize.Converters;
using Sonorize.Models;
using Sonorize.ViewModels; // Required for RepeatMode enum

namespace Sonorize.Views.MainWindowControls;

public static class PlaybackNavigationButtonsPanel
{
    public static StackPanel Create(ThemeColors theme)
    {
        // Previous Button
        var previousButton = new Button
        {
            Content = "<",
            Background = theme.B_SlightlyLighterBackground,
            Foreground = theme.B_TextColor,
            BorderBrush = theme.B_ControlBackgroundColor,
            BorderThickness = new Thickness(1),
            Width = 32,
            Height = 32,
            CornerRadius = new CornerRadius(16),
            Padding = new Thickness(0),
            FontSize = 16,
            HorizontalContentAlignment = HorizontalAlignment.Center,
            VerticalContentAlignment = VerticalAlignment.Center
        };
        previousButton.Bind(Button.CommandProperty, new Binding("Library.PreviousTrackCommand"));

        var mainPlayPauseButton = new Button
        {
            Background = theme.B_SlightlyLighterBackground,
            Foreground = theme.B_TextColor,
            BorderBrush = theme.B_AccentColor,
            BorderThickness = new Thickness(1),
            Width = 38,
            Height = 38,
            CornerRadius = new CornerRadius(19),
            Padding = new Thickness(0),
            FontSize = 18,
            HorizontalAlignment = HorizontalAlignment.Center,
            VerticalContentAlignment = VerticalAlignment.Center,
            HorizontalContentAlignment = HorizontalAlignment.Center
        };
        mainPlayPauseButton.Bind(Button.CommandProperty, new Binding("Playback.PlayPauseResumeCommand"));
        mainPlayPauseButton.Bind(Button.ContentProperty, new Binding("Playback.IsPlaying") { Converter = BooleanToPlayPauseIconConverter.Instance });

        var nextButton = new Button
        {
            Content = ">",
            Background = theme.B_SlightlyLighterBackground,
            Foreground = theme.B_TextColor,
            BorderBrush = theme.B_ControlBackgroundColor,
            BorderThickness = new Thickness(1),
            Width = 32,
            Height = 32,
            CornerRadius = new CornerRadius(16),
            Padding = new Thickness(0),
            FontSize = 16,
            HorizontalContentAlignment = HorizontalAlignment.Center,
            VerticalContentAlignment = VerticalAlignment.Center
        };
        nextButton.Bind(Button.CommandProperty, new Binding("Library.NextTrackCommand"));

        var shuffleButton = new ToggleButton
        {
            Foreground = theme.B_SecondaryTextColor,
            Background = Brushes.Transparent,
            BorderBrush = theme.B_ControlBackgroundColor,
            BorderThickness = new Thickness(1),
            CornerRadius = new CornerRadius(4),
            Padding = new Thickness(5),
            VerticalAlignment = VerticalAlignment.Center,
            HorizontalAlignment = HorizontalAlignment.Center,
            VerticalContentAlignment = VerticalAlignment.Center,
            HorizontalContentAlignment = HorizontalAlignment.Center,
            ContentTemplate = null,
            Width = 32,
            Height = 32
        };
        shuffleButton.Content = new TextBlock
        {
            TextAlignment = TextAlignment.Center,
            VerticalAlignment = VerticalAlignment.Center,
            HorizontalAlignment = HorizontalAlignment.Center,
            FontSize = 18,
            FontFamily = new FontFamily("Segoe UI Symbol, Arial"),
            [!TextBlock.TextProperty] = new Binding("Playback.ModeControls.ShuffleEnabled") { Converter = BooleanToShuffleIconConverter.Instance } // Updated path
        };
        shuffleButton.Bind(ToggleButton.IsCheckedProperty, new Binding("Playback.ModeControls.ShuffleEnabled", BindingMode.TwoWay)); // Updated path
        shuffleButton[!ToggleButton.ForegroundProperty] = new Binding("IsChecked")
        {
            Source = shuffleButton,
            Converter = new FuncValueConverter<bool, IBrush>(isChecked => isChecked ? theme.B_AccentColor : theme.B_SecondaryTextColor)
        };
        shuffleButton[!ToggleButton.BorderBrushProperty] = new Binding("IsChecked")
        {
            Source = shuffleButton,
            Converter = new FuncValueConverter<bool, IBrush>(isChecked => isChecked ? theme.B_AccentColor : theme.B_ControlBackgroundColor)
        };
        shuffleButton.Bind(Control.IsEnabledProperty, new Binding("Playback.HasCurrentSong"));

        var repeatModeButton = new ToggleButton
        {
            Foreground = theme.B_SecondaryTextColor,
            Background = Brushes.Transparent,
            BorderBrush = theme.B_ControlBackgroundColor,
            BorderThickness = new Thickness(1),
            CornerRadius = new CornerRadius(4),
            Padding = new Thickness(5),
            VerticalAlignment = VerticalAlignment.Center,
            HorizontalAlignment = HorizontalAlignment.Center,
            VerticalContentAlignment = VerticalAlignment.Center,
            HorizontalContentAlignment = HorizontalAlignment.Center,
            ContentTemplate = null,
            Width = 32,
            Height = 32
        };
        repeatModeButton.Content = new TextBlock
        {
            TextAlignment = TextAlignment.Center,
            VerticalAlignment = VerticalAlignment.Center,
            HorizontalAlignment = HorizontalAlignment.Center,
            FontSize = 18,
            FontFamily = new FontFamily("Segoe UI Symbol, Arial"),
            RenderTransformOrigin = new RelativePoint(0.5, 0.5, RelativeUnit.Relative),
            [!TextBlock.TextProperty] = new Binding("Playback.ModeControls.RepeatMode") // Updated path
            {
                Converter = new FuncValueConverter<RepeatMode, string>(mode => mode switch
                {
                    RepeatMode.None => "―",
                    RepeatMode.PlayOnce => "₁",
                    RepeatMode.RepeatOne => "🔂",
                    RepeatMode.RepeatAll => "🔁",
                    _ => "?"
                })
            },
            [!TextBlock.RenderTransformProperty] = new Binding("Playback.ModeControls.RepeatMode") // Updated path
            {
                Converter = new FuncValueConverter<RepeatMode, ITransform?>(mode =>
                {
                    return mode switch
                    {
                        RepeatMode.PlayOnce => new TranslateTransform(0, -3),
                        RepeatMode.None => new TranslateTransform(0, -1),
                        _ => null
                    };
                })
            }
        };
        repeatModeButton[!ToggleButton.ForegroundProperty] = new Binding("Playback.ModeControls.RepeatMode") // Updated path
        {
            Converter = new FuncValueConverter<RepeatMode, IBrush>(mode => mode != RepeatMode.None ? theme.B_AccentColor : theme.B_SecondaryTextColor)
        };
        repeatModeButton[!ToggleButton.BorderBrushProperty] = new Binding("Playback.ModeControls.RepeatMode") // Updated path
        {
            Converter = new FuncValueConverter<RepeatMode, IBrush>(mode => mode != RepeatMode.None ? theme.B_AccentColor : theme.B_ControlBackgroundColor)
        };
        repeatModeButton.Bind(ToggleButton.IsCheckedProperty, new Binding("Playback.ModeControls.IsRepeatActive")); // Updated path
        repeatModeButton.Bind(Button.CommandProperty, new Binding("Playback.ModeControls.CycleRepeatModeCommand")); // Updated path
        repeatModeButton.Bind(Control.IsEnabledProperty, new Binding("Playback.HasCurrentSong"));

        var combinedPlaybackButtonControlsPanel = new StackPanel
        {
            Orientation = Orientation.Horizontal,
            Spacing = 10,
            HorizontalAlignment = HorizontalAlignment.Center,
            VerticalAlignment = VerticalAlignment.Center,
            Margin = new Thickness(0)
        };

        combinedPlaybackButtonControlsPanel.Children.Add(shuffleButton);
        combinedPlaybackButtonControlsPanel.Children.Add(previousButton);
        combinedPlaybackButtonControlsPanel.Children.Add(mainPlayPauseButton);
        combinedPlaybackButtonControlsPanel.Children.Add(nextButton);
        combinedPlaybackButtonControlsPanel.Children.Add(repeatModeButton);

        return combinedPlaybackButtonControlsPanel;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Views\MainWindowControls\PlaybackTimeSliderPanel.cs">
using System;
using Avalonia;
using Avalonia.Controls;
using Avalonia.Controls.Primitives; // For Thumb, Track
using Avalonia.Data;
using Avalonia.Input;
using Avalonia.Interactivity;
using Avalonia.Layout;
using Avalonia.Media;
using Avalonia.Styling;
using Avalonia.VisualTree;
using Sonorize.Models; // For ThemeColors
using Sonorize.ViewModels;

namespace Sonorize.Views.MainWindowControls;

public static class PlaybackTimeSliderPanel
{
    public static Grid Create(ThemeColors theme)
    {
        // TextBlock for Current Time
        var currentTimeTextBlock = new TextBlock
        {
            Foreground = theme.B_SecondaryTextColor,
            FontSize = 11,
            VerticalAlignment = VerticalAlignment.Center,
            Margin = new Thickness(0, 0, 5, 0),
            MinWidth = 40,
            HorizontalAlignment = HorizontalAlignment.Left
        };
        currentTimeTextBlock.Bind(TextBlock.TextProperty, new Binding("Playback.CurrentTimeDisplay"));
        currentTimeTextBlock.Bind(Visual.IsVisibleProperty, new Binding("Playback.HasCurrentSong"));

        // TextBlock for Total Time
        var totalTimeTextBlock = new TextBlock
        {
            Foreground = theme.B_SecondaryTextColor,
            FontSize = 11,
            VerticalAlignment = VerticalAlignment.Center,
            Margin = new Thickness(5, 0, 0, 0),
            MinWidth = 40,
            HorizontalAlignment = HorizontalAlignment.Right
        };
        totalTimeTextBlock.Bind(TextBlock.TextProperty, new Binding("Playback.TotalTimeDisplay"));
        totalTimeTextBlock.Bind(Visual.IsVisibleProperty, new Binding("Playback.HasCurrentSong"));

        var mainPlaybackSlider = new Slider
        {
            Name = "MainPlaybackSliderInstance",
            Minimum = 0,
            VerticalAlignment = VerticalAlignment.Center,
            Background = theme.B_SecondaryTextColor, // Inactive part of the track
            Foreground = theme.B_AccentColor,        // Active part of the track
            HorizontalAlignment = HorizontalAlignment.Stretch,
        };

        // Add a style for the slider's thumb to make it visible and circular
        mainPlaybackSlider.Styles.Add(new Style(s => s.OfType<Slider>().Descendant().Is<Thumb>())
        {
            Setters =
            {
                new Setter(Thumb.BackgroundProperty, theme.B_AccentColor),
                new Setter(Thumb.BorderThicknessProperty, new Thickness(0)),
                new Setter(Thumb.CornerRadiusProperty, new CornerRadius(7)),
                new Setter(Thumb.WidthProperty, 14.0),
                new Setter(Thumb.HeightProperty, 14.0),
            }
        });

        // Optional: Style for the track height
        mainPlaybackSlider.Styles.Add(new Style(s => s.OfType<Slider>().Descendant().Is<Track>())
        {
            Setters =
            {
                new Setter(Track.HeightProperty, 4.0)
            }
        });

        // --- New Event Handling for "Snap-and-Drag" ---

        mainPlaybackSlider.AddHandler(Slider.PointerPressedEvent, (sender, e) =>
        {
            if (sender is not Slider slider || slider.DataContext is not MainWindowViewModel { Playback: { } playbackVM }) return;

            var point = e.GetCurrentPoint(slider);
            if (!point.Properties.IsLeftButtonPressed) return;

            // Don't interfere with built-in thumb dragging
            var thumb = slider.FindDescendantOfType<Thumb>();
            if (thumb is not null && thumb.IsPointerOver)
            {
                return;
            }

            // This is a click on the track. Begin the operation.
            playbackVM.BeginSliderDrag();

            // Immediately move the slider to the clicked position
            var bounds = slider.Bounds;
            if (bounds.Width > 0)
            {
                var ratio = Math.Clamp(point.Position.X / bounds.Width, 0, 1);
                var newValue = slider.Minimum + (ratio * (slider.Maximum - slider.Minimum));
                slider.Value = newValue;
            }

            // Capture the pointer to receive PointerMoved events for dragging from the track.
            e.Pointer.Capture(slider);
            e.Handled = true;
        }, RoutingStrategies.Tunnel);

        mainPlaybackSlider.AddHandler(Slider.PointerMovedEvent, (sender, e) =>
        {
            if (sender is not Slider slider) return;

            // Only process moves if we have captured the pointer (i.e., we are in a track-drag operation).
            if (e.Pointer.Captured != slider) return;

            var point = e.GetCurrentPoint(slider);
            var bounds = slider.Bounds;
            if (bounds.Width > 0)
            {
                var ratio = Math.Clamp(point.Position.X / bounds.Width, 0, 1);
                var newValue = slider.Minimum + (ratio * (slider.Maximum - slider.Minimum));
                slider.Value = newValue;
            }
        });

        mainPlaybackSlider.AddHandler(Slider.PointerReleasedEvent, (sender, e) =>
        {
            if (sender is not Slider slider || slider.DataContext is not MainWindowViewModel { Playback: { } playbackVM }) return;

            // Only process releases if we have captured the pointer.
            if (e.Pointer.Captured != slider) return;

            // Release pointer capture and finalize the seek.
            e.Pointer.Capture(null);
            playbackVM.CompleteSliderDrag();
            e.Handled = true;
        });

        // Add handlers specifically for the Thumb's native drag operations
        mainPlaybackSlider.AddHandler(Thumb.DragStartedEvent, (s, e) =>
        {
            if (s is Slider { DataContext: MainWindowViewModel { Playback: { } playbackVM } })
            {
                playbackVM.BeginSliderDrag();
            }
        });

        mainPlaybackSlider.AddHandler(Thumb.DragCompletedEvent, (s, e) =>
        {
            if (s is Slider { DataContext: MainWindowViewModel { Playback: { } playbackVM } })
            {
                playbackVM.CompleteSliderDrag();
            }
        });


        mainPlaybackSlider.Bind(Slider.MaximumProperty, new Binding("Playback.CurrentSongDurationSeconds"));
        mainPlaybackSlider.Bind(Slider.ValueProperty, new Binding("Playback.SliderPosition", BindingMode.TwoWay));
        mainPlaybackSlider.Bind(Control.IsEnabledProperty, new Binding("Playback.HasCurrentSong"));

        var timeSliderGrid = new Grid
        {
            ColumnDefinitions = new ColumnDefinitions("Auto,*,Auto"),
            VerticalAlignment = VerticalAlignment.Center,
            MinWidth = 500,
            HorizontalAlignment = HorizontalAlignment.Stretch,
            ClipToBounds = false
        };

        Grid.SetColumn(currentTimeTextBlock, 0);
        Grid.SetColumn(mainPlaybackSlider, 1);
        Grid.SetColumn(totalTimeTextBlock, 2);

        timeSliderGrid.Children.Add(currentTimeTextBlock);
        timeSliderGrid.Children.Add(mainPlaybackSlider);
        timeSliderGrid.Children.Add(totalTimeTextBlock);

        return timeSliderGrid;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Views\MainWindowControls\SearchBarPanels.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Data;
using Avalonia.Styling;
using Sonorize.Models; // For ThemeColors

namespace Sonorize.Views.MainWindowControls;

public static class SearchBarPanel
{
    public static Panel Create(ThemeColors theme)
    {
        var searchBox = new TextBox
        {
            Watermark = "Search songs by title, artist, or album...",
            Margin = new Thickness(10, 5, 10, 5),
            Padding = new Thickness(10, 7),
            Background = theme.B_SlightlyLighterBackground,
            Foreground = theme.B_TextColor,
            BorderBrush = theme.B_ControlBackgroundColor,
            BorderThickness = new Thickness(1),
            CornerRadius = new CornerRadius(4),
            FontSize = 14
        };
        // Bind to Library.FilterState.SearchQuery
        searchBox.Bind(TextBox.TextProperty, new Binding("Library.FilterState.SearchQuery", BindingMode.TwoWay));

        searchBox.Styles.Add(new Style(s => s.Is<TextBox>().Class(":focus"))
        {
            Setters = { new Setter(TextBox.BorderBrushProperty, theme.B_AccentColor) }
        });

        var panel = new Panel
        {
            Children = { searchBox },
            Margin = new Thickness(0, 5, 0, 0)
        };
        return panel;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Views\MainWindowControls\SharedViewTemplates.cs">
using System.Linq;
using Avalonia;
using Avalonia.Controls;
using Avalonia.Controls.Templates;
using Avalonia.Data;
using Avalonia.Layout;
using Avalonia.Media;
using Avalonia.Media.Imaging;
using Sonorize.Converters;
using Sonorize.Models;
using Sonorize.ViewModels;
using System.Diagnostics;

namespace Sonorize.Views.MainWindowControls;

public class SharedViewTemplates
{
    private readonly ThemeColors _theme;
    private readonly SongContextMenuHelper _contextMenuHelper;

    // Expose the provider for Song templates
    public SongItemTemplateProvider SongTemplates { get; private set; }
    // Expose the provider for Artist templates
    public ArtistItemTemplateProvider ArtistTemplates { get; private set; }
    public DataGridViewFactory DataGridTemplates { get; private set; }

    public FuncDataTemplate<PlaylistViewModel> DetailedPlaylistTemplate { get; private set; }
    public FuncDataTemplate<PlaylistViewModel> CompactPlaylistTemplate { get; private set; }
    public FuncDataTemplate<PlaylistViewModel> GridPlaylistTemplate { get; private set; }

    public FuncDataTemplate<AlbumViewModel> DetailedAlbumTemplate { get; private set; }
    public FuncDataTemplate<AlbumViewModel> CompactAlbumTemplate { get; private set; }
    public FuncDataTemplate<AlbumViewModel> GridAlbumTemplate { get; private set; }

    public ITemplate<Panel> StackPanelItemsPanelTemplate { get; private set; }
    public ITemplate<Panel> WrapPanelItemsPanelTemplate { get; private set; }

    public SharedViewTemplates(ThemeColors theme)
    {
        _theme = theme;
        _contextMenuHelper = new SongContextMenuHelper(_theme);
        SongTemplates = new SongItemTemplateProvider(_theme, _contextMenuHelper);
        ArtistTemplates = new ArtistItemTemplateProvider(_theme);
        DataGridTemplates = new DataGridViewFactory(_theme, _contextMenuHelper);

        Debug.WriteLine("[SharedViewTemplates] Constructor called.");
        InitializeAlbumTemplates();
        InitializePlaylistTemplates();
        InitializePanelTemplates();
    }

    private void InitializePlaylistTemplates()
    {
        DetailedPlaylistTemplate = new FuncDataTemplate<PlaylistViewModel>((dataContext, nameScope) =>
        {
            var itemGrid = new Grid { ColumnDefinitions = new ColumnDefinitions("Auto,*,Auto"), VerticalAlignment = VerticalAlignment.Center };

            var imageGrid = new Grid
            {
                Width = 58,
                Height = 58,
                Margin = new Thickness(5, 0, 10, 0),
                ColumnDefinitions = new ColumnDefinitions("*,*"),
                RowDefinitions = new RowDefinitions("*,*")
            };

            for (int i = 0; i < 4; i++)
            {
                var img = new Image { Width = 28, Height = 28, Stretch = Stretch.UniformToFill, Margin = new Thickness(1) };
                img.Bind(Image.SourceProperty, new Binding($"SongThumbnailsForGrid[{i}]"));
                RenderOptions.SetBitmapInterpolationMode(img, BitmapInterpolationMode.HighQuality);
                Grid.SetRow(img, i / 2); Grid.SetColumn(img, i % 2);
                imageGrid.Children.Add(img);
            }
            Grid.SetColumn(imageGrid, 0); itemGrid.Children.Add(imageGrid);

            var iconAndNamePanel = new StackPanel { Orientation = Orientation.Horizontal, Spacing = 8, VerticalAlignment = VerticalAlignment.Center };
            var icon = new TextBlock { FontSize = 14, Text = "✨", VerticalAlignment = VerticalAlignment.Center };
            icon.Bind(Visual.IsVisibleProperty, new Binding(nameof(PlaylistViewModel.IsAutoPlaylist)));
            var nameBlock = new TextBlock { FontSize = 14, FontWeight = FontWeight.Normal, VerticalAlignment = VerticalAlignment.Center };
            nameBlock.Bind(TextBlock.TextProperty, new Binding(nameof(PlaylistViewModel.Name)));
            iconAndNamePanel.Children.Add(icon);
            iconAndNamePanel.Children.Add(nameBlock);
            Grid.SetColumn(iconAndNamePanel, 1);
            itemGrid.Children.Add(iconAndNamePanel);

            var countBlock = new TextBlock { FontSize = 11, HorizontalAlignment = HorizontalAlignment.Right, VerticalAlignment = VerticalAlignment.Center, Foreground = _theme.B_SecondaryTextColor };
            countBlock.Bind(TextBlock.TextProperty, new Binding(nameof(PlaylistViewModel.SongCount)) { StringFormat = "{0} songs" });
            Grid.SetColumn(countBlock, 2); itemGrid.Children.Add(countBlock);

            return new Border { Padding = new Thickness(10, 6), MinHeight = 68, Background = Brushes.Transparent, Child = itemGrid };
        }, supportsRecycling: true);

        CompactPlaylistTemplate = new FuncDataTemplate<PlaylistViewModel>((dataContext, nameScope) =>
        {
            var icon = new TextBlock { FontSize = 12, Text = "✨", VerticalAlignment = VerticalAlignment.Center, Margin = new Thickness(0, 0, 5, 0) };
            icon.Bind(Visual.IsVisibleProperty, new Binding(nameof(PlaylistViewModel.IsAutoPlaylist)));

            var nameBlock = new TextBlock { FontSize = 12, VerticalAlignment = VerticalAlignment.Center, TextTrimming = TextTrimming.CharacterEllipsis };
            nameBlock.Bind(TextBlock.TextProperty, new Binding(nameof(PlaylistViewModel.Name)));

            var countBlock = new TextBlock { FontSize = 11, Foreground = _theme.B_SecondaryTextColor, VerticalAlignment = VerticalAlignment.Center, TextTrimming = TextTrimming.CharacterEllipsis, Margin = new Thickness(5, 0, 0, 0) };
            countBlock.Bind(TextBlock.TextProperty, new Binding(nameof(PlaylistViewModel.SongCount)) { StringFormat = " - {0} songs" });

            var panel = new StackPanel { Orientation = Orientation.Horizontal, VerticalAlignment = VerticalAlignment.Center, Children = { icon, nameBlock, countBlock } };
            return new Border { Padding = new Thickness(10, 4, 10, 4), MinHeight = 30, Background = Brushes.Transparent, Child = panel };
        }, supportsRecycling: true);

        GridPlaylistTemplate = new FuncDataTemplate<PlaylistViewModel>((dataContext, nameScope) =>
        {
            var imagePresenter = new Panel { Width = 80, Height = 80, HorizontalAlignment = HorizontalAlignment.Center };

            // Composite 4-image grid
            var imageGrid = new Grid
            {
                Width = 80,
                Height = 80,
                HorizontalAlignment = HorizontalAlignment.Center,
                ColumnDefinitions = new ColumnDefinitions("*,*"),
                RowDefinitions = new RowDefinitions("*,*")
            };
            for (int i = 0; i < 4; i++)
            {
                var img = new Image { Width = 38, Height = 38, Stretch = Stretch.UniformToFill, Margin = new Thickness(1) };
                img.Bind(Image.SourceProperty, new Binding($"SongThumbnailsForGrid[{i}]"));
                RenderOptions.SetBitmapInterpolationMode(img, BitmapInterpolationMode.HighQuality);
                Grid.SetRow(img, i / 2); Grid.SetColumn(img, i % 2);
                imageGrid.Children.Add(img);
            }
            imageGrid.Bind(Visual.IsVisibleProperty, new MultiBinding
            {
                Converter = new GridViewImageVisibilityConverter { TargetType = GridViewImageType.Composite },
                Bindings =
                {
                    new Binding(nameof(PlaylistViewModel.SongThumbnailsForGrid)),
                    new Binding("DataContext.Library.LibraryDisplayModeService.PlaylistGridDisplayType")
                    {
                        RelativeSource = new RelativeSource(RelativeSourceMode.FindAncestor) { AncestorType = typeof(Window) }
                    }
                }
            });

            // Single representative image
            var singleImage = new Image { Width = 80, Height = 80, Stretch = Stretch.UniformToFill, HorizontalAlignment = HorizontalAlignment.Center };
            singleImage.Bind(Image.SourceProperty, new Binding(nameof(PlaylistViewModel.RepresentativeThumbnail)));
            RenderOptions.SetBitmapInterpolationMode(singleImage, BitmapInterpolationMode.HighQuality);
            singleImage.Bind(Visual.IsVisibleProperty, new MultiBinding
            {
                Converter = new GridViewImageVisibilityConverter { TargetType = GridViewImageType.Single },
                Bindings =
                {
                    new Binding(nameof(PlaylistViewModel.SongThumbnailsForGrid)),
                    new Binding("DataContext.Library.LibraryDisplayModeService.PlaylistGridDisplayType")
                    {
                        RelativeSource = new RelativeSource(RelativeSourceMode.FindAncestor) { AncestorType = typeof(Window) }
                    }
                }
            });

            imagePresenter.Children.Add(imageGrid);
            imagePresenter.Children.Add(singleImage);

            var contentStack = new StackPanel
            {
                Orientation = Orientation.Vertical,
                HorizontalAlignment = HorizontalAlignment.Center,
                Spacing = 3
            };
            contentStack.Children.Add(imagePresenter);

            var namePanel = new StackPanel { Orientation = Orientation.Horizontal, Spacing = 4, HorizontalAlignment = HorizontalAlignment.Center, Margin = new Thickness(0, 2, 0, 0) };
            var icon = new TextBlock { FontSize = 12, Text = "✨", VerticalAlignment = VerticalAlignment.Center };
            icon.Bind(Visual.IsVisibleProperty, new Binding(nameof(PlaylistViewModel.IsAutoPlaylist)));
            var nameBlock = new TextBlock
            {
                FontSize = 12,
                FontWeight = FontWeight.SemiBold,
                TextWrapping = TextWrapping.Wrap,
                MaxHeight = 30,
                TextAlignment = TextAlignment.Center,
                HorizontalAlignment = HorizontalAlignment.Center
            };
            nameBlock.Bind(TextBlock.TextProperty, new Binding(nameof(PlaylistViewModel.Name)));
            namePanel.Children.Add(icon);
            namePanel.Children.Add(nameBlock);
            contentStack.Children.Add(namePanel);

            var countBlock = new TextBlock
            {
                FontSize = 10,
                Foreground = _theme.B_SecondaryTextColor,
                TextWrapping = TextWrapping.Wrap,
                MaxHeight = 15,
                TextAlignment = TextAlignment.Center,
                HorizontalAlignment = HorizontalAlignment.Center
            };
            countBlock.Bind(TextBlock.TextProperty, new Binding(nameof(PlaylistViewModel.SongCount)) { StringFormat = "{0} songs" });
            contentStack.Children.Add(countBlock);

            return new Border
            {
                Width = 120,
                Height = 150,
                Background = Brushes.Transparent,
                Padding = new Thickness(5),
                Child = contentStack,
                HorizontalAlignment = HorizontalAlignment.Center,
                VerticalAlignment = VerticalAlignment.Center
            };
        }, supportsRecycling: true);
    }

    private void InitializeAlbumTemplates()
    {
        DetailedAlbumTemplate = new FuncDataTemplate<AlbumViewModel>((dataContext, nameScope) =>
        {
            var itemGrid = new Grid
            {
                ColumnDefinitions = new ColumnDefinitions("Auto,*"),
                VerticalAlignment = VerticalAlignment.Center
            };

            var imageGrid = new Grid
            {
                Width = 58,
                Height = 58,
                Margin = new Thickness(5, 0, 10, 0),
                ColumnDefinitions = new ColumnDefinitions("*,*"),
                RowDefinitions = new RowDefinitions("*,*")
            };

            for (int i = 0; i < 4; i++)
            {
                var img = new Image { Width = 28, Height = 28, Stretch = Stretch.UniformToFill };
                img.Bind(Image.SourceProperty, new Binding($"SongThumbnailsForGrid[{i}]"));
                RenderOptions.SetBitmapInterpolationMode(img, BitmapInterpolationMode.HighQuality);
                Grid.SetRow(img, i / 2);
                Grid.SetColumn(img, i % 2);
                imageGrid.Children.Add(img);
            }

            Grid.SetColumn(imageGrid, 0);
            itemGrid.Children.Add(imageGrid);

            var albumTitleBlock = new TextBlock { FontSize = 14, FontWeight = FontWeight.Normal, VerticalAlignment = VerticalAlignment.Center };
            albumTitleBlock.Bind(TextBlock.TextProperty, new Binding(nameof(AlbumViewModel.Title)));

            var albumArtistBlock = new TextBlock { FontSize = 11, Foreground = _theme.B_SecondaryTextColor, VerticalAlignment = VerticalAlignment.Center };
            albumArtistBlock.Bind(TextBlock.TextProperty, new Binding(nameof(AlbumViewModel.Artist)));

            var textStack = new StackPanel { Orientation = Orientation.Vertical, VerticalAlignment = VerticalAlignment.Center, Children = { albumTitleBlock, albumArtistBlock } };

            Grid.SetColumn(textStack, 1);
            itemGrid.Children.Add(textStack);

            return new Border { Padding = new Thickness(10, 6), MinHeight = 68, Background = Brushes.Transparent, Child = itemGrid };
        }, supportsRecycling: true);

        CompactAlbumTemplate = new FuncDataTemplate<AlbumViewModel>((dataContext, nameScope) =>
        {
            var albumTitleBlock = new TextBlock { FontSize = 12, VerticalAlignment = VerticalAlignment.Center, TextTrimming = TextTrimming.CharacterEllipsis };
            albumTitleBlock.Bind(TextBlock.TextProperty, new Binding(nameof(AlbumViewModel.Title)));

            var albumArtistBlock = new TextBlock { FontSize = 11, Foreground = _theme.B_SecondaryTextColor, VerticalAlignment = VerticalAlignment.Center, TextTrimming = TextTrimming.CharacterEllipsis, Margin = new Thickness(5, 0, 0, 0) };
            albumArtistBlock.Bind(TextBlock.TextProperty, new Binding(nameof(AlbumViewModel.Artist)) { StringFormat = " - {0}" });

            var panel = new StackPanel { Orientation = Orientation.Horizontal, VerticalAlignment = VerticalAlignment.Center, Children = { albumTitleBlock, albumArtistBlock } };
            return new Border { Padding = new Thickness(10, 4, 10, 4), MinHeight = 30, Background = Brushes.Transparent, Child = panel };
        }, supportsRecycling: true);

        GridAlbumTemplate = new FuncDataTemplate<AlbumViewModel>((dataContext, nameScope) =>
        {
            var imagePresenter = new Panel { Width = 80, Height = 80, HorizontalAlignment = HorizontalAlignment.Center };

            // Composite 4-image grid
            var imageGrid = new Grid
            {
                Width = 80,
                Height = 80,
                HorizontalAlignment = HorizontalAlignment.Center,
                ColumnDefinitions = new ColumnDefinitions("*,*"),
                RowDefinitions = new RowDefinitions("*,*")
            };
            for (int i = 0; i < 4; i++)
            {
                var img = new Image { Width = 38, Height = 38, Stretch = Stretch.UniformToFill, Margin = new Thickness(1) };
                img.Bind(Image.SourceProperty, new Binding($"SongThumbnailsForGrid[{i}]"));
                RenderOptions.SetBitmapInterpolationMode(img, BitmapInterpolationMode.HighQuality);
                Grid.SetRow(img, i / 2); Grid.SetColumn(img, i % 2);
                imageGrid.Children.Add(img);
            }
            imageGrid.Bind(Visual.IsVisibleProperty, new MultiBinding
            {
                Converter = new GridViewImageVisibilityConverter { TargetType = GridViewImageType.Composite },
                Bindings =
                {
                    new Binding(nameof(AlbumViewModel.SongThumbnailsForGrid)),
                    new Binding("DataContext.Library.LibraryDisplayModeService.AlbumGridDisplayType")
                    {
                        RelativeSource = new RelativeSource(RelativeSourceMode.FindAncestor) { AncestorType = typeof(Window) }
                    }
                }
            });

            // Single representative image
            var singleImage = new Image { Width = 80, Height = 80, Stretch = Stretch.UniformToFill, HorizontalAlignment = HorizontalAlignment.Center };
            singleImage.Bind(Image.SourceProperty, new Binding(nameof(AlbumViewModel.RepresentativeThumbnail)));
            RenderOptions.SetBitmapInterpolationMode(singleImage, BitmapInterpolationMode.HighQuality);
            singleImage.Bind(Visual.IsVisibleProperty, new MultiBinding
            {
                Converter = new GridViewImageVisibilityConverter { TargetType = GridViewImageType.Single },
                Bindings =
                {
                    new Binding(nameof(AlbumViewModel.SongThumbnailsForGrid)),
                    new Binding("DataContext.Library.LibraryDisplayModeService.AlbumGridDisplayType")
                    {
                        RelativeSource = new RelativeSource(RelativeSourceMode.FindAncestor) { AncestorType = typeof(Window) }
                    }
                }
            });

            imagePresenter.Children.Add(imageGrid);
            imagePresenter.Children.Add(singleImage);

            var contentStack = new StackPanel
            {
                Orientation = Orientation.Vertical,
                HorizontalAlignment = HorizontalAlignment.Center,
                Spacing = 3
            };
            contentStack.Children.Add(imagePresenter);

            var albumTitleBlock = new TextBlock
            {
                FontSize = 12,
                FontWeight = FontWeight.SemiBold,
                TextWrapping = TextWrapping.Wrap,
                MaxHeight = 30,
                TextAlignment = TextAlignment.Center,
                HorizontalAlignment = HorizontalAlignment.Center,
                Margin = new Thickness(0, 2, 0, 0)
            };
            albumTitleBlock.Bind(TextBlock.TextProperty, new Binding(nameof(AlbumViewModel.Title)));
            contentStack.Children.Add(albumTitleBlock);

            var albumArtistBlock = new TextBlock
            {
                FontSize = 10,
                Foreground = _theme.B_SecondaryTextColor,
                TextWrapping = TextWrapping.Wrap,
                MaxHeight = 15,
                TextAlignment = TextAlignment.Center,
                HorizontalAlignment = HorizontalAlignment.Center
            };
            albumArtistBlock.Bind(TextBlock.TextProperty, new Binding(nameof(AlbumViewModel.Artist)));
            contentStack.Children.Add(albumArtistBlock);

            return new Border
            {
                Width = 120,
                Height = 150,
                Background = Brushes.Transparent,
                Padding = new Thickness(5),
                Child = contentStack,
                HorizontalAlignment = HorizontalAlignment.Center,
                VerticalAlignment = VerticalAlignment.Center
            };
        }, supportsRecycling: true);
    }

    private void InitializePanelTemplates()
    {
        StackPanelItemsPanelTemplate = new FuncTemplate<Panel>(() => new VirtualizingStackPanel { Orientation = Orientation.Vertical });
        WrapPanelItemsPanelTemplate = new FuncTemplate<Panel>(() => new WrapPanel { Orientation = Orientation.Horizontal, ItemWidth = 130, ItemHeight = 160 });
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Views\MainWindowControls\SongContextMenuHelper.cs">
using System.Diagnostics;
using Avalonia;
using Avalonia.Controls;
using Avalonia.Data;
using Avalonia.Media;
using Avalonia.Styling;
using Sonorize.Models; // For ThemeColors, Song
using Avalonia.Markup.Xaml.MarkupExtensions; // For RelativeSource

namespace Sonorize.Views.MainWindowControls;

public class SongContextMenuHelper
{
    private readonly ThemeColors _theme;

    public SongContextMenuHelper(ThemeColors theme)
    {
        _theme = theme;
        Debug.WriteLine($"[SongContextMenuHelper] Initialized.");
    }

    public ContextMenu CreateSongContextMenu()
    {
        var contextMenu = new ContextMenu();

        // Apply styles
        contextMenu.Styles.Add(new Style(s => s.OfType<ContextMenu>())
        {
            Setters =
            {
                new Setter(ContextMenu.BackgroundProperty, _theme.B_SlightlyLighterBackground),
                new Setter(ContextMenu.BorderBrushProperty, _theme.B_ControlBackgroundColor),
                new Setter(ContextMenu.BorderThicknessProperty, new Thickness(1)),
            }
        });
        contextMenu.Styles.Add(new Style(s => s.OfType<MenuItem>())
        {
            Setters =
            {
                new Setter(MenuItem.ForegroundProperty, _theme.B_TextColor),
                new Setter(MenuItem.BackgroundProperty, Brushes.Transparent)
            }
        });
        contextMenu.Styles.Add(new Style(s => s.OfType<MenuItem>().Class(":pointerover"))
        {
            Setters =
            {
                new Setter(MenuItem.BackgroundProperty, _theme.B_ControlBackgroundColor.Multiply(1.3))
            }
        });
        contextMenu.Styles.Add(new Style(s => s.OfType<MenuItem>().Class(":pressed"))
        {
            Setters =
            {
                new Setter(MenuItem.BackgroundProperty, _theme.B_AccentColor.Multiply(0.8))
            }
        });

        var editMetadataMenuItem = new MenuItem
        {
            Header = "Edit Metadata",
        };

        // When the menu opens, its DataContext becomes the item (Song).
        // We bind the CommandParameter to that DataContext.
        editMetadataMenuItem.Bind(MenuItem.CommandParameterProperty, new Binding("."));

        var commandBinding = new Binding
        {
            Path = "DataContext.OpenEditSongMetadataDialogCommand", // Path from Window's DataContext (MainWindowViewModel)
            RelativeSource = new RelativeSource(RelativeSourceMode.FindAncestor)
            {
                AncestorType = typeof(Window) // Find the parent Window - this is more robust
            }
        };
        editMetadataMenuItem.Bind(MenuItem.CommandProperty, commandBinding);

        contextMenu.Items.Add(editMetadataMenuItem);
        Debug.WriteLine($"[SongContextMenuHelper] CreateSongContextMenu called.");

        return contextMenu;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Views\MainWindowControls\SongInfoDisplayPanel.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Data;
using Avalonia.Layout;
using Avalonia.Media;
using Avalonia.Media.Imaging; // Required for BitmapInterpolationMode
using Sonorize.Models; // For ThemeColors

namespace Sonorize.Views.MainWindowControls;

public static class SongInfoDisplayPanel
{
    public static StackPanel Create(ThemeColors theme)
    {
        var songInfoPanel = new StackPanel
        {
            Orientation = Orientation.Horizontal,
            VerticalAlignment = VerticalAlignment.Center,
            HorizontalAlignment = HorizontalAlignment.Left,
            Margin = new Thickness(10, 0, 0, 0),
            Spacing = 8,
        };
        songInfoPanel.Bind(Visual.IsVisibleProperty, new Binding("Playback.HasCurrentSong"));

        var thumbnailImage = new Image
        {
            Width = 64,
            Height = 64,
            Source = null, // Will be bound
            Stretch = Stretch.UniformToFill,
            VerticalAlignment = VerticalAlignment.Center
        };
        RenderOptions.SetBitmapInterpolationMode(thumbnailImage, BitmapInterpolationMode.HighQuality);
        thumbnailImage.Bind(Image.SourceProperty, new Binding("Playback.CurrentSong.Thumbnail"));

        var textStack = new StackPanel
        {
            Orientation = Orientation.Vertical,
            VerticalAlignment = VerticalAlignment.Center,
            Spacing = 1
        };

        var titleTextBlock = new TextBlock
        {
            Text = "Unknown Title", // Default, will be bound
            FontSize = 14,
            FontWeight = FontWeight.SemiBold,
            Foreground = theme.B_TextColor,
            TextTrimming = TextTrimming.CharacterEllipsis,
            VerticalAlignment = VerticalAlignment.Center,
            MaxWidth = 200
        };
        titleTextBlock.Bind(TextBlock.TextProperty, new Binding("Playback.CurrentSong.Title"));

        var artistTextBlock = new TextBlock
        {
            Text = "Unknown Artist", // Default, will be bound
            FontSize = 11,
            Foreground = theme.B_SecondaryTextColor,
            TextTrimming = TextTrimming.CharacterEllipsis,
            VerticalAlignment = VerticalAlignment.Center,
            MaxWidth = 200
        };
        artistTextBlock.Bind(TextBlock.TextProperty, new Binding("Playback.CurrentSong.Artist"));

        textStack.Children.Add(titleTextBlock);
        textStack.Children.Add(artistTextBlock);

        songInfoPanel.Children.Add(thumbnailImage);
        songInfoPanel.Children.Add(textStack);

        return songInfoPanel;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Views\MainWindowControls\SongItemTemplateProvider.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Controls.Templates;
using Avalonia.Data;
using Avalonia.Layout;
using Avalonia.Media;
using Avalonia.Media.Imaging;
using Sonorize.Models;
using Sonorize.ViewModels; // For Song model if not already included via Sonorize.Models
using System.Diagnostics;

namespace Sonorize.Views.MainWindowControls;

public class SongItemTemplateProvider
{
    private readonly ThemeColors _theme;
    private readonly SongContextMenuHelper _contextMenuHelper;

    public FuncDataTemplate<Song> DetailedSongTemplate { get; private set; }
    public FuncDataTemplate<Song> CompactSongTemplate { get; private set; }
    public FuncDataTemplate<Song> GridSongTemplate { get; private set; }

    public SongItemTemplateProvider(ThemeColors theme, SongContextMenuHelper contextMenuHelper)
    {
        _theme = theme;
        _contextMenuHelper = contextMenuHelper ?? throw new System.ArgumentNullException(nameof(contextMenuHelper));
        Debug.WriteLine("[SongItemTemplateProvider] Initialized.");
        InitializeSongTemplates();
    }

    private void InitializeSongTemplates()
    {
        // Detailed Song Template
        DetailedSongTemplate = new FuncDataTemplate<Song>((dataContext, nameScope) =>
        {
            var image = new Image { Width = 32, Height = 32, Margin = new Thickness(5, 0, 5, 0), Stretch = Stretch.UniformToFill };
            image.Bind(Image.SourceProperty, new Binding(nameof(Song.Thumbnail)));
            RenderOptions.SetBitmapInterpolationMode(image, BitmapInterpolationMode.HighQuality);

            var titleBlock = new TextBlock { FontSize = 14, FontWeight = FontWeight.Normal, VerticalAlignment = VerticalAlignment.Center, Margin = new Thickness(0, 0, 0, 1) };
            titleBlock.Bind(TextBlock.TextProperty, new Binding(nameof(Song.Title)));

            var artistBlock = new TextBlock { FontSize = 11, VerticalAlignment = VerticalAlignment.Center, Foreground = _theme.B_SecondaryTextColor };
            artistBlock.Bind(TextBlock.TextProperty, new Binding(nameof(Song.Artist)));

            var durationBlock = new TextBlock { FontSize = 11, HorizontalAlignment = HorizontalAlignment.Right, VerticalAlignment = VerticalAlignment.Center, Foreground = _theme.B_SecondaryTextColor };
            durationBlock.Bind(TextBlock.TextProperty, new Binding(nameof(Song.DurationString)));

            var textStack = new StackPanel { Orientation = Orientation.Vertical, VerticalAlignment = VerticalAlignment.Center, Margin = new Thickness(8, 0, 0, 0), Children = { titleBlock, artistBlock } };
            var itemGrid = new Grid { ColumnDefinitions = new ColumnDefinitions("Auto,*,Auto"), VerticalAlignment = VerticalAlignment.Center, Children = { image, textStack, durationBlock } };
            Grid.SetColumn(image, 0); Grid.SetColumn(textStack, 1); Grid.SetColumn(durationBlock, 2);

            var rootBorder = new Border { Padding = new Thickness(10, 6, 10, 6), MinHeight = 44, Background = Brushes.Transparent, Child = itemGrid };
            rootBorder.ContextMenu = _contextMenuHelper.CreateSongContextMenu();
            return rootBorder;
        }, supportsRecycling: true);

        // Compact Song Template
        CompactSongTemplate = new FuncDataTemplate<Song>((dataContext, nameScope) =>
        {
            var titleBlock = new TextBlock { FontSize = 12, FontWeight = FontWeight.Normal, VerticalAlignment = VerticalAlignment.Center, TextTrimming = TextTrimming.CharacterEllipsis };
            titleBlock.Bind(TextBlock.TextProperty, new Binding(nameof(Song.Title)));

            var artistBlock = new TextBlock { FontSize = 11, VerticalAlignment = VerticalAlignment.Center, Foreground = _theme.B_SecondaryTextColor, TextTrimming = TextTrimming.CharacterEllipsis, Margin = new Thickness(5, 0, 0, 0) };
            artistBlock.Bind(TextBlock.TextProperty, new Binding(nameof(Song.Artist)) { StringFormat = " - {0}" });


            var titleArtistPanel = new StackPanel { Orientation = Orientation.Horizontal, VerticalAlignment = VerticalAlignment.Center, Children = { titleBlock, artistBlock } };

            var durationBlock = new TextBlock { FontSize = 11, HorizontalAlignment = HorizontalAlignment.Right, VerticalAlignment = VerticalAlignment.Center, Foreground = _theme.B_SecondaryTextColor, Margin = new Thickness(5, 0, 0, 0) };
            durationBlock.Bind(TextBlock.TextProperty, new Binding(nameof(Song.DurationString)));

            var itemGrid = new Grid { ColumnDefinitions = new ColumnDefinitions("*,Auto"), VerticalAlignment = VerticalAlignment.Center };
            itemGrid.Children.Add(titleArtistPanel); itemGrid.Children.Add(durationBlock);
            Grid.SetColumn(titleArtistPanel, 0); Grid.SetColumn(durationBlock, 1);

            var rootBorder = new Border { Padding = new Thickness(10, 4, 10, 4), MinHeight = 30, Background = Brushes.Transparent, Child = itemGrid };
            rootBorder.ContextMenu = _contextMenuHelper.CreateSongContextMenu();
            return rootBorder;
        }, supportsRecycling: true);

        // Grid Song Template
        GridSongTemplate = new FuncDataTemplate<Song>((dataContext, nameScope) =>
        {
            var image = new Image { Width = 80, Height = 80, Stretch = Stretch.UniformToFill, HorizontalAlignment = HorizontalAlignment.Center };
            image.Bind(Image.SourceProperty, new Binding(nameof(Song.Thumbnail)));
            RenderOptions.SetBitmapInterpolationMode(image, BitmapInterpolationMode.HighQuality);

            var titleBlock = new TextBlock
            {
                FontSize = 12,
                FontWeight = FontWeight.SemiBold,
                TextWrapping = TextWrapping.Wrap,
                Height = 32,
                MaxLines = 2,
                TextAlignment = TextAlignment.Center,
                HorizontalAlignment = HorizontalAlignment.Center,
                Margin = new Thickness(0, 3, 0, 0),
                VerticalAlignment = VerticalAlignment.Top
            };
            titleBlock.Bind(TextBlock.TextProperty, new Binding(nameof(Song.Title)));

            var artistBlock = new TextBlock { FontSize = 10, Foreground = _theme.B_SecondaryTextColor, TextWrapping = TextWrapping.Wrap, MaxHeight = 15, TextAlignment = TextAlignment.Center, HorizontalAlignment = HorizontalAlignment.Center, Margin = new Thickness(0, 1, 0, 0) };
            artistBlock.Bind(TextBlock.TextProperty, new Binding(nameof(Song.Artist)));

            var contentStack = new StackPanel { Orientation = Orientation.Vertical, HorizontalAlignment = HorizontalAlignment.Center, Spacing = 2, Children = { image, titleBlock, artistBlock } };

            var rootBorder = new Border { Width = 120, Height = 150, Background = Brushes.Transparent, Padding = new Thickness(5), Child = contentStack, HorizontalAlignment = HorizontalAlignment.Center, VerticalAlignment = VerticalAlignment.Center };
            rootBorder.ContextMenu = _contextMenuHelper.CreateSongContextMenu();
            return rootBorder;
        }, supportsRecycling: true);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Views\SettingsWindowControls\AppearanceSettingsPanel.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Data;
using Avalonia.Layout;
using Avalonia.Media;
using Sonorize.Models;

namespace Sonorize.Views.SettingsWindowControls;

public static class AppearanceSettingsPanel
{
    public static StackPanel Create(ThemeColors theme)
    {
        var panel = new StackPanel { Spacing = 15 };

        panel.Children.Add(new TextBlock
        {
            Text = "Appearance",
            FontSize = 18,
            FontWeight = FontWeight.SemiBold,
            Foreground = theme.B_TextColor,
            Margin = new Thickness(0, 0, 0, 5)
        });

        panel.Children.Add(CreateGridImageTypeSelector(theme, "Artist", "AppearanceSettings.IsArtistGridSingle", "AppearanceSettings.IsArtistGridComposite"));
        panel.Children.Add(CreateGridImageTypeSelector(theme, "Album", "AppearanceSettings.IsAlbumGridSingle", "AppearanceSettings.IsAlbumGridComposite"));
        panel.Children.Add(CreateGridImageTypeSelector(theme, "Playlist", "AppearanceSettings.IsPlaylistGridSingle", "AppearanceSettings.IsPlaylistGridComposite"));

        return panel;
    }

    private static StackPanel CreateGridImageTypeSelector(ThemeColors theme, string label, string singleBindingPath, string compositeBindingPath)
    {
        var sectionPanel = new StackPanel { Spacing = 8 };

        var title = new TextBlock
        {
            Text = $"{label} Grid Image Style",
            FontSize = 14,
            FontWeight = FontWeight.Normal,
            Foreground = theme.B_TextColor,
            Margin = new Thickness(0, 0, 0, 5)
        };

        var singleRadio = new RadioButton
        {
            Content = "Single Representative Image",
            GroupName = $"{label}GridStyle",
            Foreground = theme.B_TextColor
        };
        singleRadio.Bind(RadioButton.IsCheckedProperty, new Binding(singleBindingPath, BindingMode.TwoWay));

        var compositeRadio = new RadioButton
        {
            Content = "4-Image Composite (if available)",
            GroupName = $"{label}GridStyle",
            Foreground = theme.B_TextColor
        };
        compositeRadio.Bind(RadioButton.IsCheckedProperty, new Binding(compositeBindingPath, BindingMode.TwoWay));

        var radioPanel = new StackPanel { Orientation = Orientation.Vertical, Spacing = 5, Margin = new Thickness(10, 0, 0, 0) };
        radioPanel.Children.Add(singleRadio);
        radioPanel.Children.Add(compositeRadio);

        sectionPanel.Children.Add(title);
        sectionPanel.Children.Add(radioPanel);
        sectionPanel.Children.Add(new Separator { Background = theme.B_ControlBackgroundColor, Margin = new Thickness(0, 5) });

        return sectionPanel;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Views\SettingsWindowControls\DirectoriesSettingsPanel.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Data;
using Avalonia.Layout;
using Avalonia.Media;
using Sonorize.Models; // For ThemeColors

namespace Sonorize.Views.SettingsWindowControls;

public static class DirectoriesSettingsPanel
{
    public static StackPanel Create(ThemeColors theme, Window ownerWindow)
    {
        var panel = new StackPanel { Spacing = 10 };

        panel.Children.Add(new TextBlock
        {
            Text = "Music Directories",
            FontSize = 18,
            FontWeight = FontWeight.SemiBold,
            Foreground = theme.B_TextColor,
            Margin = new Thickness(0, 0, 0, 10)
        });

        var directoriesManagementPanel = new DockPanel();
        var dirManagementButtons = new StackPanel { Orientation = Orientation.Vertical, Spacing = 5, Margin = new Thickness(0, 0, 10, 0) };
        DockPanel.SetDock(dirManagementButtons, Dock.Right);
        var addButton = new Button { Content = "Add", Background = theme.B_ControlBackgroundColor, Foreground = theme.B_TextColor, HorizontalAlignment = HorizontalAlignment.Stretch };
        // Updated binding path
        addButton.Bind(Button.CommandProperty, new Binding("MusicDirectoriesSettings.AddDirectoryCommand"));
        addButton.CommandParameter = ownerWindow; // Pass the owner window for the dialog

        var removeButton = new Button { Content = "Remove", Background = theme.B_ControlBackgroundColor, Foreground = theme.B_TextColor, HorizontalAlignment = HorizontalAlignment.Stretch };
        // Updated binding paths
        removeButton.Bind(Button.CommandProperty, new Binding("MusicDirectoriesSettings.RemoveDirectoryCommand"));
        removeButton.Bind(Button.IsEnabledProperty, new Binding("MusicDirectoriesSettings.CanRemoveDirectory"));
        dirManagementButtons.Children.Add(addButton);
        dirManagementButtons.Children.Add(removeButton);

        var directoryListBox = new ListBox
        {
            Background = theme.B_ControlBackgroundColor,
            BorderThickness = new Thickness(1),
            BorderBrush = theme.B_SecondaryTextColor,
            Foreground = theme.B_TextColor,
            Height = 150,
            MaxHeight = 200
        };
        // Updated binding paths
        directoryListBox.Bind(ItemsControl.ItemsSourceProperty, new Binding("MusicDirectoriesSettings.MusicDirectories"));
        directoryListBox.Bind(ListBox.SelectedItemProperty, new Binding("MusicDirectoriesSettings.SelectedDirectory", BindingMode.TwoWay));
        directoriesManagementPanel.Children.Add(dirManagementButtons);
        directoriesManagementPanel.Children.Add(directoryListBox);

        panel.Children.Add(directoriesManagementPanel);
        return panel;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Views\SettingsWindowControls\ScrobblingSettingsPanel.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Controls.Primitives; // Required for NumericUpDown
using Avalonia.Data;
using Avalonia.Layout;
using Avalonia.Media; // Required for Brushes
using Sonorize.Models; // For ThemeColors

namespace Sonorize.Views.SettingsWindowControls;

public static class ScrobblingSettingsPanel
{
    public static StackPanel Create(ThemeColors theme)
    {
        var panel = new StackPanel { Spacing = 10 };

        panel.Children.Add(new TextBlock
        {
            Text = "Last.fm Scrobbling",
            FontSize = 18,
            FontWeight = FontWeight.SemiBold,
            Foreground = theme.B_TextColor,
            Margin = new Thickness(0, 0, 0, 5)
        });

        var scrobblingEnableCheckBox = new CheckBox
        {
            Content = "Enable Scrobbling",
            Foreground = theme.B_TextColor,
            Margin = new Thickness(0, 0, 0, 10)
        };
        scrobblingEnableCheckBox.Bind(ToggleButton.IsCheckedProperty, new Binding("LastfmSettings.LastfmScrobblingEnabled", BindingMode.TwoWay));
        panel.Children.Add(scrobblingEnableCheckBox);

        var usernameLabel = new TextBlock { Text = "Username:", Foreground = theme.B_TextColor, VerticalAlignment = VerticalAlignment.Center, Margin = new Thickness(0, 0, 10, 5) };
        var usernameTextBox = new TextBox
        {
            Background = theme.B_ControlBackgroundColor,
            Foreground = theme.B_TextColor,
            BorderBrush = theme.B_SecondaryTextColor,
            Watermark = "Last.fm Username",
            Margin = new Thickness(0, 0, 0, 5)
        };
        usernameTextBox.Bind(TextBox.TextProperty, new Binding("LastfmSettings.LastfmUsername", BindingMode.TwoWay));

        var passwordLabel = new TextBlock { Text = "Password:", Foreground = theme.B_TextColor, VerticalAlignment = VerticalAlignment.Center, Margin = new Thickness(0, 0, 10, 0) };
        var passwordTextBox = new TextBox
        {
            Background = theme.B_ControlBackgroundColor,
            Foreground = theme.B_TextColor,
            BorderBrush = theme.B_SecondaryTextColor,
            PasswordChar = '•',
            Watermark = "Last.fm Password (if changing)"
        };
        passwordTextBox.Bind(TextBox.TextProperty, new Binding("LastfmSettings.LastfmPassword", BindingMode.TwoWay));

        var scrobblingGrid = new Grid
        {
            ColumnDefinitions = new ColumnDefinitions("Auto,*"),
            RowDefinitions = new RowDefinitions("Auto,Auto"),
            Margin = new Thickness(0, 0, 0, 10)
        };
        Grid.SetRow(usernameLabel, 0); Grid.SetColumn(usernameLabel, 0);
        Grid.SetRow(usernameTextBox, 0); Grid.SetColumn(usernameTextBox, 1);
        Grid.SetRow(passwordLabel, 1); Grid.SetColumn(passwordLabel, 0);
        Grid.SetRow(passwordTextBox, 1); Grid.SetColumn(passwordTextBox, 1);
        scrobblingGrid.Children.Add(usernameLabel);
        scrobblingGrid.Children.Add(usernameTextBox);
        scrobblingGrid.Children.Add(passwordLabel);
        scrobblingGrid.Children.Add(passwordTextBox);
        panel.Children.Add(scrobblingGrid);

        var criteriaPanel = new StackPanel { Orientation = Orientation.Vertical, Spacing = 8, Margin = new Thickness(0, 10, 0, 5) };
        var percentagePanel = new StackPanel { Orientation = Orientation.Horizontal, Spacing = 5 };
        var percentageLabel = new TextBlock { Text = "Scrobble if played for at least ", Foreground = theme.B_TextColor, VerticalAlignment = VerticalAlignment.Center };
        var percentageUpDown = new NumericUpDown { Minimum = 1, Maximum = 100, Increment = 1, Width = 120, Background = theme.B_ControlBackgroundColor, Foreground = theme.B_TextColor, BorderBrush = theme.B_SecondaryTextColor }; // Increased width
        percentageUpDown.Bind(NumericUpDown.ValueProperty, new Binding("LastfmSettings.ScrobbleThresholdPercentage", BindingMode.TwoWay));
        var percentageUnitLabel = new TextBlock { Text = "% of duration", Foreground = theme.B_TextColor, VerticalAlignment = VerticalAlignment.Center };
        percentagePanel.Children.Add(percentageLabel); percentagePanel.Children.Add(percentageUpDown); percentagePanel.Children.Add(percentageUnitLabel);

        var absolutePanel = new StackPanel { Orientation = Orientation.Horizontal, Spacing = 5 };
        var absoluteLabel = new TextBlock { Text = "OR Scrobble if played for at least ", Foreground = theme.B_TextColor, VerticalAlignment = VerticalAlignment.Center };
        var absoluteUpDown = new NumericUpDown { Minimum = 10, Maximum = 600, Increment = 10, Width = 130, Background = theme.B_ControlBackgroundColor, Foreground = theme.B_TextColor, BorderBrush = theme.B_SecondaryTextColor }; // Increased width
        absoluteUpDown.Bind(NumericUpDown.ValueProperty, new Binding("LastfmSettings.ScrobbleThresholdAbsoluteSeconds", BindingMode.TwoWay));
        var absoluteUnitLabel = new TextBlock { Text = "seconds", Foreground = theme.B_TextColor, VerticalAlignment = VerticalAlignment.Center };
        absolutePanel.Children.Add(absoluteLabel); absolutePanel.Children.Add(absoluteUpDown); absolutePanel.Children.Add(absoluteUnitLabel);

        var criteriaExplanation = new TextBlock { Text = "(Whichever threshold is met first, and track is > 30s)", FontSize = 10, Foreground = theme.B_SecondaryTextColor, FontStyle = FontStyle.Italic, TextWrapping = TextWrapping.Wrap };
        criteriaPanel.Children.Add(percentagePanel); criteriaPanel.Children.Add(absolutePanel); criteriaPanel.Children.Add(criteriaExplanation);
        panel.Children.Add(criteriaPanel);

        panel.Children.Add(new TextBlock
        {
            Text = "Password stored locally only until a session key is obtained. Authentication happens when Sonorize starts or when settings are saved.",
            FontSize = 10,
            Foreground = theme.B_SecondaryTextColor,
            FontStyle = FontStyle.Italic,
            Margin = new Thickness(0, 15, 0, 0),
            TextWrapping = TextWrapping.Wrap
        });

        return panel;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Views\SettingsWindowControls\SettingsButtonPanel.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Layout;
using Sonorize.Models; // For ThemeColors
using Sonorize.ViewModels; // For SettingsViewModel

namespace Sonorize.Views.SettingsWindowControls;

public static class SettingsButtonPanel
{
    public static StackPanel Create(ThemeColors theme, Window ownerWindow)
    {
        var buttonsPanel = new StackPanel
        {
            Orientation = Orientation.Horizontal,
            HorizontalAlignment = HorizontalAlignment.Right,
            Spacing = 10,
            Margin = new Thickness(15) // Consistent margin
        };

        var saveButton = new Button { Content = "Save & Close", Background = theme.B_AccentColor, Foreground = theme.B_AccentForeground, Padding = new Thickness(15, 8), CornerRadius = new CornerRadius(3) };
        saveButton.Click += (s, e) =>
        {
            if (ownerWindow.DataContext is SettingsViewModel vm)
            {
                vm.SaveAndCloseCommand.Execute(null);
            }
            ownerWindow.Close();
        };

        var cancelButton = new Button { Content = "Cancel", Background = theme.B_ControlBackgroundColor, Foreground = theme.B_TextColor, Padding = new Thickness(15, 8), CornerRadius = new CornerRadius(3) };
        cancelButton.Click += (s, e) => ownerWindow.Close();

        buttonsPanel.Children.Add(saveButton);
        buttonsPanel.Children.Add(cancelButton);
        return buttonsPanel;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Views\SettingsWindowControls\SettingsMenuPanel.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Data;
using Avalonia.Layout;
using Sonorize.Models; // For ThemeColors

namespace Sonorize.Views.SettingsWindowControls;

public static class SettingsMenuPanel
{
    public static Border Create(ThemeColors theme)
    {
        var menuStackPanel = new StackPanel
        {
            Spacing = 5
        };

        var directoriesButton = new Button { Content = "Directories", HorizontalAlignment = HorizontalAlignment.Stretch, Background = theme.B_ControlBackgroundColor, Foreground = theme.B_TextColor };
        directoriesButton.Bind(Button.CommandProperty, new Binding("ShowDirectoriesSettingsCommand"));

        var themeButton = new Button { Content = "Theme", HorizontalAlignment = HorizontalAlignment.Stretch, Background = theme.B_ControlBackgroundColor, Foreground = theme.B_TextColor };
        themeButton.Bind(Button.CommandProperty, new Binding("ShowThemeSettingsCommand"));
        
        var appearanceButton = new Button { Content = "Appearance", HorizontalAlignment = HorizontalAlignment.Stretch, Background = theme.B_ControlBackgroundColor, Foreground = theme.B_TextColor };
        appearanceButton.Bind(Button.CommandProperty, new Binding("ShowAppearanceSettingsCommand"));

        var scrobblingButton = new Button { Content = "Scrobbling", HorizontalAlignment = HorizontalAlignment.Stretch, Background = theme.B_ControlBackgroundColor, Foreground = theme.B_TextColor };
        scrobblingButton.Bind(Button.CommandProperty, new Binding("ShowScrobblingSettingsCommand"));

        menuStackPanel.Children.Add(directoriesButton);
        menuStackPanel.Children.Add(themeButton);
        menuStackPanel.Children.Add(appearanceButton);
        menuStackPanel.Children.Add(scrobblingButton);

        var menuBorder = new Border
        {
            Background = theme.B_BackgroundColor,
            Padding = new Thickness(10),
            Child = menuStackPanel
        };

        return menuBorder;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\Sonorize\Sonorize\Source\Views\SettingsWindowControls\ThemeSettingsPanel.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Data;
using Avalonia.Layout;
using Avalonia.Media; // Required for FontStyle, TextWrapping
using Sonorize.Models; // For ThemeColors

namespace Sonorize.Views.SettingsWindowControls;

public static class ThemeSettingsPanel
{
    public static StackPanel Create(ThemeColors theme)
    {
        var panel = new StackPanel { Spacing = 10 };
        panel.Children.Add(new TextBlock
        {
            Text = "Application Theme",
            FontSize = 18,
            FontWeight = FontWeight.SemiBold,
            Foreground = theme.B_TextColor,
            Margin = new Thickness(0, 0, 0, 10)
        });

        var themeComboBox = new ComboBox
        {
            HorizontalAlignment = HorizontalAlignment.Stretch,
            Background = theme.B_ControlBackgroundColor,
            Foreground = theme.B_TextColor,
            BorderBrush = theme.B_SecondaryTextColor
        };
        // Updated binding paths
        themeComboBox.Bind(ItemsControl.ItemsSourceProperty, new Binding("ThemeSettings.AvailableThemes"));
        themeComboBox.Bind(ComboBox.SelectedItemProperty, new Binding("ThemeSettings.SelectedThemeFile", BindingMode.TwoWay));
        panel.Children.Add(themeComboBox);

        panel.Children.Add(new TextBlock
        {
            Text = "A restart is required for theme changes to take full effect.",
            FontSize = 10,
            Foreground = theme.B_SecondaryTextColor,
            FontStyle = FontStyle.Italic,
            Margin = new Thickness(0, 5, 0, 0),
            TextWrapping = TextWrapping.Wrap
        });
        return panel;
    }
}
</file>

