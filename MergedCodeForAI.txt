<file path="App.axaml.cs">
using Avalonia;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Markup.Xaml; // Required for AvaloniaXamlLoader or InitializeComponent
using Avalonia.Styling;
using Sonorize.ViewModels;
using Sonorize.Views;
using Sonorize.Services;
using Sonorize.Models;
using Avalonia.Themes.Fluent;
using Avalonia.Media;
using System.Diagnostics;

namespace Sonorize;

public partial class App : Application // Add 'partial' keyword
{
    public override void Initialize()
    {
        AvaloniaXamlLoader.Load(this); // Loads the XAML content from App.axaml
        // Or, if your build system generates InitializeComponent():
        // InitializeComponent(); 
        // The line above is typically generated for .axaml files.
        // If InitializeComponent() is available, it calls AvaloniaXamlLoader.Load(this) internally.
        // Your original Initialize() was empty, which is fine.
        // The FluentTheme is added later in OnFrameworkInitializationCompleted.
    }

    public override void OnFrameworkInitializationCompleted()
    {
        if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
        {
            var settingsService = new SettingsService();
            var appSettings = settingsService.LoadSettings();

            var themeService = new ThemeService(appSettings.PreferredThemeFileName);
            ThemeColors currentCustomTheme = themeService.CurrentTheme;

            var fluentTheme = new FluentTheme();
            Styles.Add(fluentTheme);
            RequestedThemeVariant = ThemeVariant.Dark; // This will override XAML if set there
            Debug.WriteLine($"[App] RequestedThemeVariant set to: {RequestedThemeVariant}");

            if (currentCustomTheme.B_AccentColor is ISolidColorBrush accentSolidBrush &&
                currentCustomTheme.B_AccentForeground is ISolidColorBrush accentForegroundSolidBrush)
            {
                Color accentColor = accentSolidBrush.Color;
                Color accentForegroundColor = accentForegroundSolidBrush.Color;
                Debug.WriteLine($"[App] Overriding FluentTheme accent resources. Accent: {accentColor}, AccentFG: {accentForegroundColor}");
                Resources["SystemAccentColor"] = accentColor;
                Resources["SystemAccentColorLight1"] = accentColor.ChangeLightness(0.15);
                Resources["SystemAccentColorLight2"] = accentColor.ChangeLightness(0.30);
                Resources["SystemAccentColorLight3"] = accentColor.ChangeLightness(0.45);
                Resources["SystemAccentColorDark1"] = accentColor.ChangeLightness(-0.15);
                Resources["SystemAccentColorDark2"] = accentColor.ChangeLightness(-0.30);
                Resources["SystemAccentColorDark3"] = accentColor.ChangeLightness(-0.45);
                Resources["AccentFillColorDefaultBrush"] = new SolidColorBrush(accentColor);
                Resources["AccentFillColorSecondaryBrush"] = new SolidColorBrush(accentColor.ChangeLightness(0.15).WithAlpha(204));
                Resources["AccentFillColorTertiaryBrush"] = new SolidColorBrush(accentColor.ChangeLightness(0.30).WithAlpha(153));
                Resources["AccentFillColorDisabledBrush"] = new SolidColorBrush(accentColor.WithAlpha(51));
                Resources["AccentFillColorSelectedTextBackgroundBrush"] = new SolidColorBrush(accentColor);
                Resources["TextOnAccentFillColorPrimaryBrush"] = new SolidColorBrush(accentForegroundColor);
                Resources["TextOnAccentFillColorSecondaryBrush"] = new SolidColorBrush(accentForegroundColor.WithAlpha(178));
                Resources["TextOnAccentFillColorDisabledBrush"] = new SolidColorBrush(accentForegroundColor.WithAlpha(127));
                Resources["AccentControlBackgroundBrush"] = new SolidColorBrush(accentColor);
            }
            else
            {
                Debug.WriteLine("[App] Warning: Custom theme AccentColor or AccentForeground is not a SolidColorBrush. Cannot fully override Fluent accent system.");
            }

            var playbackService = new PlaybackService();
            var loopDataService = new LoopDataService();
            var musicLibraryService = new MusicLibraryService(loopDataService);
            var waveformService = new WaveformService();

            var mainWindowViewModel = new MainWindowViewModel(
                settingsService,
                musicLibraryService,
                playbackService,
                currentCustomTheme,
                waveformService,
                loopDataService);

            // Pass the theme to the MainWindow constructor
            desktop.MainWindow = new MainWindow(currentCustomTheme)
            {
                DataContext = mainWindowViewModel
            };

            mainWindowViewModel.LoadInitialDataCommand.Execute(null);
        }

        base.OnFrameworkInitializationCompleted();
    }
}

// ColorManipulationExtensions and ColorExtensions remain the same
// Ensure they are either in this file or accessible via a 'using' statement if in another file.
// For brevity, I'm assuming they are still in this file or correctly referenced.

public static class ColorManipulationExtensions
{
    public static Color WithAlpha(this Color color, byte alpha)
    {
        return new Color(alpha, color.R, color.G, color.B);
    }
}

public static class ColorExtensions
{
    public static Color ChangeLightness(this Color color, double factor)
    {
        var hsl = color.ToHsl();
        double newL = System.Math.Clamp(hsl.L + factor, 0.0, 1.0);
        return HslColor.FromAhsl(hsl.A, hsl.H, hsl.S, newL).ToRgb();
    }
}
</file>

<file path="Program.cs">
using Avalonia;
using System;
using NAudio.MediaFoundation; // Required for MediaFoundationApi

namespace Sonorize;

class Program
{
    // Initialization code. Don't use any Avalonia, third-party APIs or any
    // SynchronizationContext-reliant code before AppMain is called: things aren't initialized
    // yet and stuff might break.
    [STAThread]
    public static void Main(string[] args)
    {
        // Initialize Media Foundation
        try
        {
            MediaFoundationApi.Startup();
            Console.WriteLine("[Program] MediaFoundationApi.Startup() called successfully.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[Program] CRITICAL ERROR: MediaFoundationApi.Startup() failed: {ex.Message}");
            // Optionally, prevent the app from starting or notify the user,
            // as MF features will likely not work.
        }

        try
        {
            BuildAvaloniaApp().StartWithClassicDesktopLifetime(args);
        }
        finally
        {
            // Shutdown Media Foundation
            try
            {
                MediaFoundationApi.Shutdown();
                Console.WriteLine("[Program] MediaFoundationApi.Shutdown() called successfully.");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[Program] ERROR: MediaFoundationApi.Shutdown() failed: {ex.Message}");
            }
        }
    }

    // Avalonia configuration, don't remove; also used by visual designer.
    public static AppBuilder BuildAvaloniaApp()
        => AppBuilder.Configure<App>()
            .UsePlatformDetect()
            .LogToTrace();
}
</file>

<file path="Source\Controls\WaveformDisplayControl.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Media;
using Avalonia.Input;
using System;
using System.Collections.Generic;
using System.Linq; // Required for Enumerable.Empty
using Sonorize.Models; // For LoopRegion
using Sonorize.Services; // For WaveformPoint

namespace Sonorize.Controls;

public class WaveformDisplayControl : Control
{
    // Background Property
    public static readonly StyledProperty<IBrush?> BackgroundProperty =
        Border.BackgroundProperty.AddOwner<WaveformDisplayControl>();

    public IBrush? Background
    {
        get => GetValue(BackgroundProperty);
        set => SetValue(BackgroundProperty, value);
    }

    // Corrected to use IEnumerable<WaveformPoint>
    public static readonly StyledProperty<IEnumerable<WaveformPoint>> WaveformPointsProperty =
        AvaloniaProperty.Register<WaveformDisplayControl, IEnumerable<WaveformPoint>>(
            nameof(WaveformPoints),
            defaultValue: Enumerable.Empty<WaveformPoint>()); // Default to an empty enumerable

    public IEnumerable<WaveformPoint> WaveformPoints
    {
        get => GetValue(WaveformPointsProperty);
        set => SetValue(WaveformPointsProperty, value);
    }

    public static readonly StyledProperty<TimeSpan> CurrentPositionProperty =
        AvaloniaProperty.Register<WaveformDisplayControl, TimeSpan>(nameof(CurrentPosition));

    public TimeSpan CurrentPosition
    {
        get => GetValue(CurrentPositionProperty);
        set => SetValue(CurrentPositionProperty, value);
    }

    public static readonly StyledProperty<TimeSpan> DurationProperty =
        AvaloniaProperty.Register<WaveformDisplayControl, TimeSpan>(nameof(Duration), TimeSpan.FromSeconds(1));

    public TimeSpan Duration
    {
        get => GetValue(DurationProperty);
        set => SetValue(DurationProperty, value);
    }

    public static readonly StyledProperty<LoopRegion?> ActiveLoopProperty =
        AvaloniaProperty.Register<WaveformDisplayControl, LoopRegion?>(nameof(ActiveLoop));

    public LoopRegion? ActiveLoop
    {
        get => GetValue(ActiveLoopProperty);
        set => SetValue(ActiveLoopProperty, value);
    }

    public static readonly StyledProperty<IBrush> WaveformBrushProperty =
        AvaloniaProperty.Register<WaveformDisplayControl, IBrush>(nameof(WaveformBrush), Brushes.DodgerBlue);
    public IBrush WaveformBrush { get => GetValue(WaveformBrushProperty); set => SetValue(WaveformBrushProperty, value); }

    public static readonly StyledProperty<IBrush> PositionMarkerBrushProperty =
        AvaloniaProperty.Register<WaveformDisplayControl, IBrush>(nameof(PositionMarkerBrush), Brushes.Red);
    public IBrush PositionMarkerBrush { get => GetValue(PositionMarkerBrushProperty); set => SetValue(PositionMarkerBrushProperty, value); }

    public static readonly StyledProperty<IBrush> LoopRegionBrushProperty =
        AvaloniaProperty.Register<WaveformDisplayControl, IBrush>(nameof(LoopRegionBrush), new SolidColorBrush(Colors.Orange, 0.3));
    public IBrush LoopRegionBrush { get => GetValue(LoopRegionBrushProperty); set => SetValue(LoopRegionBrushProperty, value); }


    public event EventHandler<TimeSpan>? SeekRequested;

    static WaveformDisplayControl()
    {
        AffectsRender<WaveformDisplayControl>(BackgroundProperty, WaveformPointsProperty, CurrentPositionProperty, DurationProperty, ActiveLoopProperty, WaveformBrushProperty, PositionMarkerBrushProperty, LoopRegionBrushProperty);
    }

    public WaveformDisplayControl()
    {
        ClipToBounds = true;
    }

    protected override void OnPointerPressed(PointerPressedEventArgs e)
    {
        base.OnPointerPressed(e);
        if (Duration.TotalSeconds > 0 && e.GetCurrentPoint(this).Properties.IsLeftButtonPressed)
        {
            var position = e.GetPosition(this);
            var relativeX = position.X / Bounds.Width;
            var seekTime = TimeSpan.FromSeconds(relativeX * Duration.TotalSeconds);
            SeekRequested?.Invoke(this, seekTime);
        }
    }

    public override void Render(DrawingContext context)
    {
        base.Render(context);
        var width = Bounds.Width;
        var height = Bounds.Height;

        if (width <= 0 || height <= 0) return;

        // Draw Background
        if (Background != null)
        {
            context.FillRectangle(Background, Bounds);
        }

        var waveformPen = new Pen(WaveformBrush, 1);
        var positionPen = new Pen(PositionMarkerBrush, 1.5);

        // WaveformPoints is now IEnumerable<WaveformPoint>
        if (WaveformPoints != null && WaveformPoints.Any()) // Use .Any() for IEnumerable
        {
            // If we need Count or indexed access, we might need to ToList() it here,
            // but for simple iteration, this is fine.
            // For performance with potentially large IEnumerable, if Count is needed multiple times,
            // convert to List once.
            var pointsList = WaveformPoints as List<WaveformPoint> ?? WaveformPoints.ToList();
            if (pointsList.Count > 1)
            {
                for (int i = 0; i < pointsList.Count; i++)
                {
                    var point = pointsList[i];
                    var x = point.X * width;
                    var yPeakValue = point.YPeak * (height / 2);
                    context.DrawLine(waveformPen, new Point(x, height / 2 - yPeakValue), new Point(x, height / 2 + yPeakValue));
                }
            }
            else if (pointsList.Count == 1) // Draw a small vertical line for a single point
            {
                var point = pointsList[0];
                var x = point.X * width;
                var yPeakValue = point.YPeak * (height / 2);
                context.DrawLine(waveformPen, new Point(x, height / 2 - yPeakValue), new Point(x, height / 2 + yPeakValue));
            }
            else // No points but not null (e.g., empty collection)
            {
                context.DrawLine(waveformPen, new Point(0, height / 2), new Point(width, height / 2));
            }
        }
        else // WaveformPoints is null or empty
        {
            context.DrawLine(waveformPen, new Point(0, height / 2), new Point(width, height / 2));
        }

        if (ActiveLoop != null && Duration.TotalSeconds > 0)
        {
            var loopStartRatio = ActiveLoop.Start.TotalSeconds / Duration.TotalSeconds;
            var loopEndRatio = ActiveLoop.End.TotalSeconds / Duration.TotalSeconds;
            var loopStartX = loopStartRatio * width;
            var loopEndX = loopEndRatio * width;
            if (loopEndX > loopStartX)
            {
                context.FillRectangle(LoopRegionBrush, new Rect(loopStartX, 0, loopEndX - loopStartX, height));
            }
        }

        if (Duration.TotalSeconds > 0)
        {
            var currentX = (CurrentPosition.TotalSeconds / Duration.TotalSeconds) * width;
            currentX = Math.Clamp(currentX, 0, width);
            context.DrawLine(positionPen, new Point(currentX, 0), new Point(currentX, height));
        }
    }
}
</file>

<file path="Source\Models\AppSettings.cs">
using System.Collections.Generic;

namespace Sonorize.Models;

public class AppSettings
{
    public List<string> MusicDirectories { get; set; } = new List<string>();
    public string? PreferredThemeFileName { get; set; } // Stores the name of the theme file
}
</file>

<file path="Source\Models\LoopRegion.cs">
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace Sonorize.Models;

public class LoopRegion(TimeSpan start, TimeSpan end, string name = "Loop") : INotifyPropertyChanged
{
    private string _name = name; // Name field remains, but not prominently used in UI
    public string Name
    {
        get => _name;
        set => SetProperty(ref _name, value);
    }

    private TimeSpan _start = start;
    public TimeSpan Start
    {
        get => _start;
        set => SetProperty(ref _start, value);
    }

    private TimeSpan _end = end;
    public TimeSpan End
    {
        get => _end;
        set => SetProperty(ref _end, value);
    }

    // DisplayText no longer includes the name by default for main UI, focused on times
    public string DisplayText => $"({Start:mm\\:ss} - {End:mm\\:ss})";

    public event PropertyChangedEventHandler? PropertyChanged;
    protected bool SetProperty<T>(ref T field, T value, [CallerMemberName] string? propertyName = null)
    {
        if (EqualityComparer<T>.Default.Equals(field, value)) return false;
        field = value;
        OnPropertyChanged(propertyName);
        return true;
    }
    protected void OnPropertyChanged([CallerMemberName] string? propertyName = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
</file>

<file path="Source\Models\LoopStorageData.cs">
using System;

namespace Sonorize.Models;

public record LoopStorageData(TimeSpan Start, TimeSpan End, bool IsActive);
</file>

<file path="Source\Models\Song.cs">
using Avalonia.Media.Imaging;
using Sonorize.ViewModels; // For ViewModelBase
using System;
using System.ComponentModel;
using System.Diagnostics; // For INotifyPropertyChanged

namespace Sonorize.Models;

public class Song : ViewModelBase
{
    private string _filePath = string.Empty;
    public string FilePath { get => _filePath; set => SetProperty(ref _filePath, value); }

    private string _title = "Unknown Title";
    public string Title { get => _title; set => SetProperty(ref _title, value); }

    private string _artist = "Unknown Artist";
    public string Artist { get => _artist; set => SetProperty(ref _artist, value); }

    private string _album = "Unknown Album";
    public string Album { get => _album; set => SetProperty(ref _album, value); }

    private TimeSpan _duration;
    public TimeSpan Duration { get => _duration; set => SetProperty(ref _duration, value); }
    public string DurationString => $"{Duration:mm\\:ss}";

    private Bitmap? _thumbnail;
    public Bitmap? Thumbnail { get => _thumbnail; set => SetProperty(ref _thumbnail, value); }

    private LoopRegion? _savedLoop;
    public LoopRegion? SavedLoop
    {
        get => _savedLoop;
        set => SetProperty(ref _savedLoop, value);
    }

    private bool _isLoopActive;
    public bool IsLoopActive
    {
        get => _isLoopActive;
        set
        {
            // SetProperty handles OnPropertyChanged
            if (SetProperty(ref _isLoopActive, value))
            {
                // The ViewModel will observe this change and trigger persistence
                Debug.WriteLine($"[SongModel] {Title} - IsLoopActive set to: {value}");
            }
        }
    }
}
</file>

<file path="Source\Models\ThemeColors.cs">
using Avalonia.Media;
using System.Text.Json.Serialization;

namespace Sonorize.Models;

public class ThemeColors
{
    // --- Main UI Colors (Strings) ---
    public string BackgroundColor { get; set; } = "#FF1E1E1E";
    public string SlightlyLighterBackground { get; set; } = "#FF2D2D30";
    public string ControlBackgroundColor { get; set; } = "#FF3C3C3C";
    public string TextColor { get; set; } = "#FFF1F1F1";
    public string SecondaryTextColor { get; set; } = "#FFAAAAAA";
    public string AccentColor { get; set; } = "#FF007ACC";
    public string AccentForeground { get; set; } = "#FFFFFFFF";
    public string ListBoxBackground { get; set; } = "#FF2D2D30";

    // --- Brush Properties (IBrush) ---
    [JsonIgnore] public IBrush B_BackgroundColor => SolidColorBrush.Parse(BackgroundColor);
    [JsonIgnore] public IBrush B_SlightlyLighterBackground => SolidColorBrush.Parse(SlightlyLighterBackground);
    [JsonIgnore] public IBrush B_ControlBackgroundColor => SolidColorBrush.Parse(ControlBackgroundColor);
    [JsonIgnore] public IBrush B_TextColor => SolidColorBrush.Parse(TextColor);
    [JsonIgnore] public IBrush B_SecondaryTextColor => SolidColorBrush.Parse(SecondaryTextColor);
    [JsonIgnore] public IBrush B_AccentColor => SolidColorBrush.Parse(AccentColor);
    [JsonIgnore] public IBrush B_AccentForeground => SolidColorBrush.Parse(AccentForeground);
    [JsonIgnore] public IBrush B_ListBoxBackground => SolidColorBrush.Parse(ListBoxBackground);

    // --- Color Struct Properties (Color) ---
    [JsonIgnore] public Color C_BackgroundColor => Color.Parse(BackgroundColor);
    [JsonIgnore] public Color C_SlightlyLighterBackground => Color.Parse(SlightlyLighterBackground);
    [JsonIgnore] public Color C_ControlBackgroundColor => Color.Parse(ControlBackgroundColor);
    [JsonIgnore] public Color C_TextColor => Color.Parse(TextColor);
    [JsonIgnore] public Color C_SecondaryTextColor => Color.Parse(SecondaryTextColor);
    [JsonIgnore] public Color C_AccentColor => Color.Parse(AccentColor);
    [JsonIgnore] public Color C_AccentForeground => Color.Parse(AccentForeground);
    [JsonIgnore] public Color C_ListBoxBackground => Color.Parse(ListBoxBackground);

    public static ThemeColors CreateAmoledSpotifyTheme()
    {
        return new ThemeColors
        {
            BackgroundColor = "#FF000000",
            SlightlyLighterBackground = "#FF121212",
            ControlBackgroundColor = "#FF181818",
            TextColor = "#FFFFFFFF",
            SecondaryTextColor = "#FFB3B3B3",
            AccentColor = "#FF1DB954",      // Spotify Green
            AccentForeground = "#FF000000",  // Black text on green buttons
            ListBoxBackground = "#FF000000"
        };
    }
}
</file>

<file path="Source\Services\LoopDataService.cs">
// Path: Source/Services/LoopDataService.cs
using Sonorize.Models;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text.Json;
using System.Diagnostics;

namespace Sonorize.Services;

public class LoopDataService
{
    private readonly string _loopDataFilePath;
    private Dictionary<string, LoopStorageData> _loopDataStore = new();
    private readonly object _lock = new object();

    public LoopDataService()
    {
        var appDataPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
        var sonorizeAppDataPath = Path.Combine(appDataPath, "Sonorize");
        Directory.CreateDirectory(sonorizeAppDataPath);
        _loopDataFilePath = Path.Combine(sonorizeAppDataPath, "loopdata.json");
        LoadLoopData();
        Debug.WriteLine($"[LoopDataService] Initialized. Data loaded from: {_loopDataFilePath}");
    }

    private void LoadLoopData()
    {
        lock (_lock)
        {
            try
            {
                if (File.Exists(_loopDataFilePath))
                {
                    var json = File.ReadAllText(_loopDataFilePath);
                    // Handle potential old format without IsActive gracefully
                    var tempStore = JsonSerializer.Deserialize<Dictionary<string, JsonElement>>(json);
                    _loopDataStore = new Dictionary<string, LoopStorageData>();
                    if (tempStore != null)
                    {
                        foreach (var kvp in tempStore)
                        {
                            try
                            {
                                // Try to deserialize to the new record type
                                _loopDataStore[kvp.Key] = kvp.Value.Deserialize<LoopStorageData>()!;
                            }
                            catch (JsonException) // If it fails, it might be the old format
                            {
                                try
                                {
                                    // Old format: record LoopStorageData(TimeSpan Start, TimeSpan End);
                                    var oldLoop = kvp.Value.Deserialize<OldLoopStorageDataTemp>();
                                    if (oldLoop != null)
                                    {
                                        _loopDataStore[kvp.Key] = new LoopStorageData(oldLoop.Start, oldLoop.End, false); // Default IsActive to false for old data
                                        Debug.WriteLine($"[LoopDataService] Migrated old loop format for {Path.GetFileName(kvp.Key)}");
                                    }
                                }
                                catch (Exception exMigrate)
                                {
                                    Debug.WriteLine($"[LoopDataService] Failed to migrate or deserialize loop for {Path.GetFileName(kvp.Key)}: {exMigrate.Message}");
                                }
                            }
                        }
                    }
                    Debug.WriteLine($"[LoopDataService] Successfully loaded/migrated {_loopDataStore.Count} loop entries.");
                }
                else
                {
                    _loopDataStore = new Dictionary<string, LoopStorageData>();
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[LoopDataService] Error loading loop data: {ex.Message}. Initializing with empty store.");
                _loopDataStore = new Dictionary<string, LoopStorageData>();
            }
        }
    }
    // Temporary record for migration from old format
    private record OldLoopStorageDataTemp(TimeSpan Start, TimeSpan End);


    private void SaveLoopData()
    {
        lock (_lock)
        {
            try
            {
                var options = new JsonSerializerOptions { WriteIndented = true };
                var json = JsonSerializer.Serialize(_loopDataStore, options);
                File.WriteAllText(_loopDataFilePath, json);
                Debug.WriteLine($"[LoopDataService] Successfully saved {_loopDataStore.Count} loop entries to {_loopDataFilePath}");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[LoopDataService] Error saving loop data: {ex.Message}");
            }
        }
    }

    public LoopStorageData? GetLoop(string filePath)
    {
        if (string.IsNullOrEmpty(filePath)) return null;
        lock (_lock)
        {
            _loopDataStore.TryGetValue(filePath, out var loopData);
            return loopData;
        }
    }

    // Modified to accept isActive
    public void SetLoop(string filePath, TimeSpan start, TimeSpan end, bool isActive)
    {
        if (string.IsNullOrEmpty(filePath)) return;
        var loopData = new LoopStorageData(start, end, isActive);
        lock (_lock)
        {
            _loopDataStore[filePath] = loopData;
        }
        Debug.WriteLine($"[LoopDataService] SetLoop for \"{Path.GetFileName(filePath)}\": Start={start}, End={end}, IsActive={isActive}. Triggering save.");
        SaveLoopData();
    }

    public void UpdateLoopActiveState(string filePath, bool isActive)
    {
        if (string.IsNullOrEmpty(filePath)) return;
        lock (_lock)
        {
            if (_loopDataStore.TryGetValue(filePath, out var existingLoop))
            {
                _loopDataStore[filePath] = existingLoop with { IsActive = isActive }; // Using record 'with' expression
                Debug.WriteLine($"[LoopDataService] UpdateLoopActiveState for \"{Path.GetFileName(filePath)}\" to IsActive={isActive}. Triggering save.");
                SaveLoopData();
            }
            else
            {
                Debug.WriteLine($"[LoopDataService] UpdateLoopActiveState: No loop definition found for \"{Path.GetFileName(filePath)}\" to update active state.");
            }
        }
    }


    public void ClearLoop(string filePath)
    {
        if (string.IsNullOrEmpty(filePath)) return;
        bool removed = false;
        lock (_lock)
        {
            if (_loopDataStore.ContainsKey(filePath))
            {
                removed = _loopDataStore.Remove(filePath);
            }
        }
        if (removed)
        {
            Debug.WriteLine($"[LoopDataService] ClearLoop for \"{Path.GetFileName(filePath)}\". Triggering save.");
            SaveLoopData();
        }
    }
}
</file>

<file path="Source\Services\MusicLibraryService.cs">
using Avalonia.Media.Imaging;
using Sonorize.Models;
using System;
using System.Collections.Generic;
using System.Globalization; // For CultureInfo
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Diagnostics;
using TagLib;
using Avalonia.Threading;
using Avalonia.Media; // For Brushes, Colors
using Avalonia; // For PixelSize, Vector, Rect, Size, Point
using Avalonia.Platform; // For RenderTargetBitmap

namespace Sonorize.Services;

public class MusicLibraryService
{
    private Bitmap? _defaultThumbnail;
    private readonly LoopDataService _loopDataService;

    public MusicLibraryService(LoopDataService loopDataService)
    {
        _loopDataService = loopDataService;
        Debug.WriteLine("[MusicLibService] Constructor called.");
        // Default thumbnail creation logic remains the same...
        if (_defaultThumbnail == null)
        {
            _defaultThumbnail = CreateDefaultMusicalNoteIcon();
            if (_defaultThumbnail == null)
            {
                Debug.WriteLine("[MusicLibService] CRITICAL: Failed to create default thumbnail in constructor.");
            }
            else
            {
                Debug.WriteLine("[MusicLibService] Default thumbnail created successfully in constructor.");
            }
        }
    }
    private Bitmap? CreateDefaultMusicalNoteIcon()
    {
        Debug.WriteLine("[ThumbGen] CreateDefaultMusicalNoteIcon called.");
        try
        {
            var pixelSize = new Avalonia.PixelSize(64, 64);
            var dpi = new Avalonia.Vector(96, 96);

            using var renderTarget = new RenderTargetBitmap(pixelSize, dpi);
            using (DrawingContext context = renderTarget.CreateDrawingContext())
            {
                var backgroundBrush = new SolidColorBrush(Avalonia.Media.Colors.DimGray);
                var foregroundBrush = Avalonia.Media.Brushes.WhiteSmoke;

                var bounds = new Rect(new Size(pixelSize.Width, pixelSize.Height));
                context.FillRectangle(backgroundBrush, bounds);

                var formattedText = new FormattedText(
                    "â™«",
                    CultureInfo.CurrentCulture,
                    FlowDirection.LeftToRight,
                    Typeface.Default, // Consider a more specific font if default doesn't have the note
                    32, // Font size
                    foregroundBrush);

                // Center the text
                var textOrigin = new Avalonia.Point(
                    (bounds.Width - formattedText.Width) / 2,
                    (bounds.Height - formattedText.Height) / 2);
                context.DrawText(formattedText, textOrigin);
            }

            // Save to a memory stream
            using var memoryStream = new MemoryStream();
            renderTarget.Save(memoryStream); // Default is PNG
            memoryStream.Seek(0, SeekOrigin.Begin);

            if (memoryStream.Length > 0)
            {
                var bitmap = new Bitmap(memoryStream);
                Debug.WriteLine($"[ThumbGen] Default musical note icon created successfully. Size: {bitmap.PixelSize}");
                return bitmap;
            }
            Debug.WriteLine("[ThumbGen] CRITICAL ERROR: MemoryStream empty for default icon, returning null.");
            return null;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[ThumbGen] CRITICAL EXCEPTION creating default icon: {ex.ToString()}, returning null.");
            return null;
        }
    }

    public Bitmap? GetDefaultThumbnail() => _defaultThumbnail;
    private Bitmap? LoadAlbumArt(string filePath)
    {
        try
        {
            using (var tagFile = TagLib.File.Create(filePath))
            {
                if (tagFile.Tag.Pictures.Length > 0)
                {
                    IPicture pic = tagFile.Tag.Pictures[0];
                    using (var ms = new MemoryStream(pic.Data.Data))
                    {
                        if (ms.Length > 0)
                        {
                            // It's good practice to check if the bitmap can be created
                            // and handle potential exceptions here too.
                            using (var originalBitmap = new Bitmap(ms))
                            {
                                // Resize to a smaller thumbnail
                                var targetSize = new PixelSize(64, 64); // Example size
                                var scaledBitmap = originalBitmap.CreateScaledBitmap(targetSize, BitmapInterpolationMode.HighQuality);
                                return scaledBitmap;
                            }
                        }
                    }
                }
            }
        }
        catch (CorruptFileException) { /* Optional: Debug.WriteLine for tracking */ }
        catch (UnsupportedFormatException) { /* Optional: Debug.WriteLine */ }
        catch (Exception ex) { Debug.WriteLine($"[AlbumArt] Error loading album art for {Path.GetFileName(filePath)}: {ex.Message}"); }
        return null;
    }


    public async Task LoadMusicFromDirectoriesAsync(
        IEnumerable<string> directories,
        Action<Song> songAddedCallback,
        Action<string> statusUpdateCallback)
    {
        Debug.WriteLine("[MusicLibService] LoadMusicFromDirectoriesAsync called.");
        var supportedExtensions = new[] { ".mp3", ".wav", ".flac", ".m4a", ".ogg" }; // Common audio formats
        Bitmap? defaultIcon = GetDefaultThumbnail();
        int filesProcessed = 0;

        foreach (var dir in directories)
        {
            if (!Directory.Exists(dir))
            {
                Debug.WriteLine($"[LibScan] Directory not found: {dir}");
                await Dispatcher.UIThread.InvokeAsync(() => statusUpdateCallback($"Directory not found: {dir}"));
                continue;
            }
            await Dispatcher.UIThread.InvokeAsync(() => statusUpdateCallback($"Scanning: {Path.GetFileName(dir)}..."));

            List<string> filesInDir;
            try
            {
                filesInDir = Directory.EnumerateFiles(dir, "*.*", SearchOption.AllDirectories)
                                      .Where(f => supportedExtensions.Any(ext => f.EndsWith(ext, StringComparison.OrdinalIgnoreCase)))
                                      .ToList();
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[LibScan] Error enumerating files in {dir}: {ex.Message}");
                await Dispatcher.UIThread.InvokeAsync(() => statusUpdateCallback($"Error scanning {Path.GetFileName(dir)}"));
                continue;
            }

            foreach (var file in filesInDir)
            {
                Bitmap? thumbnail = LoadAlbumArt(file);
                var song = new Song
                {
                    FilePath = file,
                    Title = Path.GetFileNameWithoutExtension(file), // Default title
                    Artist = "Unknown Artist",       // Default artist
                    Album = "Unknown Album",         // Default album
                    Duration = TimeSpan.Zero,        // Default duration
                    Thumbnail = thumbnail ?? defaultIcon
                };

                try
                {
                    using (var tagFile = TagLib.File.Create(file))
                    {
                        if (!string.IsNullOrWhiteSpace(tagFile.Tag.Title)) song.Title = tagFile.Tag.Title;
                        if (tagFile.Tag.Performers.Length > 0 && !string.IsNullOrWhiteSpace(tagFile.Tag.Performers[0]))
                            song.Artist = tagFile.Tag.Performers[0];
                        else if (tagFile.Tag.AlbumArtists.Length > 0 && !string.IsNullOrWhiteSpace(tagFile.Tag.AlbumArtists[0]))
                            song.Artist = tagFile.Tag.AlbumArtists[0]; // Fallback to album artist
                        if (!string.IsNullOrWhiteSpace(tagFile.Tag.Album)) song.Album = tagFile.Tag.Album;
                        if (tagFile.Properties.Duration > TimeSpan.Zero) song.Duration = tagFile.Properties.Duration;
                    }
                }
                catch (Exception) { /* Silently ignore metadata read errors for now */ }

                var storedLoopData = _loopDataService.GetLoop(song.FilePath);
                if (storedLoopData != null)
                {
                    song.SavedLoop = new LoopRegion(storedLoopData.Start, storedLoopData.End);
                    song.IsLoopActive = storedLoopData.IsActive; // <-- SET IsLoopActive
                    Debug.WriteLine($"[MusicLibService] Loaded persistent loop for {Path.GetFileName(song.FilePath)}: {song.SavedLoop.Start} - {song.SavedLoop.End}, Active: {song.IsLoopActive}");
                }

                await Dispatcher.UIThread.InvokeAsync(() => songAddedCallback(song));
                filesProcessed++;
                if (filesProcessed % 20 == 0) // Update status periodically
                {
                    await Dispatcher.UIThread.InvokeAsync(() => statusUpdateCallback($"Loaded {filesProcessed} songs..."));
                }
            }
        }
        Debug.WriteLine($"[MusicLibService] Background file scanning complete. Processed {filesProcessed} songs.");
    }
}
</file>

<file path="Source\Services\PlaybackService.cs">
using Avalonia.Threading;
using NAudio.Wave;
using NAudio.Wave.SampleProviders;
using Sonorize.Models;
using Sonorize.ViewModels;
using System;
using System.Diagnostics;
using System.IO;
using System.Threading;
using SoundTouch.Net.NAudioSupport;

namespace Sonorize.Services;

public enum PlaybackStateStatus { Stopped, Playing, Paused }

public class PlaybackService : ViewModelBase, IDisposable
{
    private Song? _currentSong;
    public Song? CurrentSong
    {
        get => _currentSong;
        private set
        {
            if (SetProperty(ref _currentSong, value))
            {
                Debug.WriteLine($"[PlaybackService] CurrentSong property set to: {value?.Title ?? "null"}");
                OnPropertyChanged(nameof(HasCurrentSong));
            }
        }
    }

    public bool HasCurrentSong => CurrentSong != null;

    private bool _isPlaying;
    public bool IsPlaying
    {
        get => _isPlaying;
        private set => SetProperty(ref _isPlaying, value);
    }

    private PlaybackStateStatus _currentPlaybackStatus = PlaybackStateStatus.Stopped;
    public PlaybackStateStatus CurrentPlaybackStatus
    {
        get => _currentPlaybackStatus;
        private set => SetProperty(ref _currentPlaybackStatus, value);
    }

    private TimeSpan _currentPosition;
    public TimeSpan CurrentPosition
    {
        get => _currentPosition;
        private set // Changed to private set
        {
            if (SetProperty(ref _currentPosition, value))
            {
                OnPropertyChanged(nameof(CurrentPositionSeconds));
            }
        }
    }
    public double CurrentPositionSeconds => CurrentPosition.TotalSeconds;

    private TimeSpan _currentSongDuration;
    public TimeSpan CurrentSongDuration
    {
        get => _currentSongDuration;
        private set
        {
            if (SetProperty(ref _currentSongDuration, value))
            {
                OnPropertyChanged(nameof(CurrentSongDurationSeconds));
            }
        }
    }
    public double CurrentSongDurationSeconds => CurrentSongDuration.TotalSeconds > 0 ? CurrentSongDuration.TotalSeconds : 1.0;

    private IWavePlayer? _waveOutDevice;
    private AudioFileReader? audioFileReader;
    private SmbPitchShiftingSampleProvider? pitchShifter;
    private Timer? uiUpdateTimer;
    private SoundTouchWaveProvider? soundTouch;
    private IWavePlayer? _waveOutDeviceInstanceForStopEventCheck;

    private float _playbackRate = 1.0f;
    public float PlaybackRate
    {
        get => _playbackRate;
        set
        {
            if (Math.Abs(_playbackRate - value) > float.Epsilon)
            {
                _playbackRate = value;
                if (soundTouch != null) soundTouch.Tempo = _playbackRate;
                OnPropertyChanged();
            }
        }
    }

    private float _pitchSemitones = 0f;
    public float PitchSemitones
    {
        get => _pitchSemitones;
        set
        {
            if (Math.Abs(_pitchSemitones - value) > float.Epsilon)
            {
                _pitchSemitones = value;
                if (pitchShifter != null) pitchShifter.PitchFactor = (float)Math.Pow(2, _pitchSemitones / 12.0);
                OnPropertyChanged();
            }
        }
    }

    public PlaybackService()
    {
        Debug.WriteLine("[PlaybackService] Constructor called.");
        uiUpdateTimer = new Timer(UpdateUiCallback, null, Timeout.Infinite, Timeout.Infinite);
    }

    private void UpdateUiCallback(object? state)
    {
        if (IsPlaying && audioFileReader != null && _waveOutDevice?.PlaybackState == PlaybackState.Playing)
        {
            Dispatcher.UIThread.InvokeAsync(() =>
            {
                if (audioFileReader == null || _waveOutDevice == null || CurrentSong == null) return;

                this.CurrentPosition = audioFileReader.CurrentTime; // Update CurrentPosition via its private setter

                if (CurrentSong.IsLoopActive && CurrentSong.SavedLoop != null)
                {
                    var loop = CurrentSong.SavedLoop;
                    if (loop.End > loop.Start && this.CurrentPosition >= loop.End)
                    {
                        Debug.WriteLine($"[PlaybackService] Loop active & end reached ({this.CurrentPosition} >= {loop.End}). Seeking to loop start: {loop.Start}");
                        Seek(loop.Start);
                    }
                }
            });
        }
    }

    public void Play(Song song)
    {
        Debug.WriteLine($"[PlaybackService] Play requested for: {(song?.Title ?? "null song")}");
        StopPlaybackInternal(resetCurrentSongAndRelatedState: false);

        if (song == null || string.IsNullOrEmpty(song.FilePath))
        {
            CurrentSong = null;
            CurrentSongDuration = TimeSpan.Zero;
            this.CurrentPosition = TimeSpan.Zero;
            Debug.WriteLine("[PlaybackService] Play called with null/invalid song. State is stopped, CurrentSong nulled.");
            return;
        }

        CurrentSong = song;
        bool pipelineInitialized = InitializeNAudioPipeline(song.FilePath); // This sets CurrentPosition to Zero initially

        if (pipelineInitialized && _waveOutDevice != null && audioFileReader != null)
        {
            if (CurrentSong.IsLoopActive && CurrentSong.SavedLoop != null)
            {
                Debug.WriteLine($"[PlaybackService] Song has active loop. Seeking to loop start: {CurrentSong.SavedLoop.Start} before playing.");
                Seek(CurrentSong.SavedLoop.Start); // Seek will update CurrentPosition
            }
            // If not looping, CurrentPosition is already Zero from InitializeNAudioPipeline

            _waveOutDevice.Play();
            IsPlaying = true;
            CurrentPlaybackStatus = PlaybackStateStatus.Playing;
            StartUiUpdateTimer();
            Debug.WriteLine($"[PlaybackService] Playback started for: {CurrentSong.Title}");
        }
        else
        {
            Debug.WriteLine($"[PlaybackService] Pipeline init failed for {Path.GetFileName(song.FilePath)}. Cleaning up and stopping.");
            IsPlaying = false;
            CurrentPlaybackStatus = PlaybackStateStatus.Stopped;
            StopUiUpdateTimer();
            CurrentSong = null;
            CurrentSongDuration = TimeSpan.Zero;
            this.CurrentPosition = TimeSpan.Zero;
        }
    }


    private bool InitializeNAudioPipeline(string filePath)
    {
        Debug.WriteLine($"[PlaybackService] InitializeNAudioPipeline for: {Path.GetFileName(filePath)}");
        try
        {
            audioFileReader = new AudioFileReader(filePath);
            ISampleProvider sourceSampleProvider = audioFileReader.ToSampleProvider();
            ISampleProvider monoSampleProvider = sourceSampleProvider.ToMono();
            IWaveProvider monoWaveProviderForSoundTouch = new SampleToWaveProvider(monoSampleProvider);

            soundTouch = new SoundTouchWaveProvider(monoWaveProviderForSoundTouch)
            {
                Tempo = PlaybackRate,
                Rate = 1.0f,
            };

            ISampleProvider soundTouchAsSampleProvider = soundTouch.ToSampleProvider();

            pitchShifter = new SmbPitchShiftingSampleProvider(soundTouchAsSampleProvider)
            {
                PitchFactor = (float)Math.Pow(2, PitchSemitones / 12.0)
            };

            IWaveProvider finalWaveProviderForDevice = pitchShifter.ToWaveProvider();

            _waveOutDevice = new WaveOutEvent();
            _waveOutDeviceInstanceForStopEventCheck = _waveOutDevice;
            _waveOutDevice.PlaybackStopped += OnPlaybackStopped;
            _waveOutDevice.Init(finalWaveProviderForDevice);

            CurrentSongDuration = audioFileReader.TotalTime;
            this.CurrentPosition = TimeSpan.Zero; // Set position to zero for new song
            Debug.WriteLine($"[PlaybackService] NAudio pipeline initialization COMPLETE for: {Path.GetFileName(filePath)}. Duration: {CurrentSongDuration}");
            return true;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[PlaybackService] CRITICAL ERROR during NAudio pipeline init for {Path.GetFileName(filePath)}: {ex.ToString()}");
            CleanUpNAudioResources();
            CurrentSongDuration = TimeSpan.Zero;
            this.CurrentPosition = TimeSpan.Zero;
            return false;
        }
    }

    private void StartUiUpdateTimer()
    {
        uiUpdateTimer?.Change(TimeSpan.Zero, TimeSpan.FromMilliseconds(100));
        Debug.WriteLine("[PlaybackService] UI Update Timer Started.");
    }

    private void StopUiUpdateTimer()
    {
        uiUpdateTimer?.Change(Timeout.Infinite, Timeout.Infinite);
        Debug.WriteLine("[PlaybackService] UI Update Timer Stopped.");
    }

    private void CleanUpNAudioResources()
    {
        if (_waveOutDevice != null)
        {
            if (_waveOutDeviceInstanceForStopEventCheck == _waveOutDevice)
            {
                _waveOutDevice.PlaybackStopped -= OnPlaybackStopped;
            }
            _waveOutDevice.Stop();
            _waveOutDevice.Dispose();
            _waveOutDevice = null;
        }
        _waveOutDeviceInstanceForStopEventCheck = null;

        audioFileReader?.Dispose();
        audioFileReader = null;

        pitchShifter = null;
        soundTouch = null;

        Debug.WriteLine("[PlaybackService] NAudio resources cleaned up.");
    }


    private void OnPlaybackStopped(object? sender, StoppedEventArgs e)
    {
        if (sender != _waveOutDeviceInstanceForStopEventCheck)
        {
            Debug.WriteLine("[PlaybackService] OnPlaybackStopped received for a stale WaveOutDevice instance. Ignoring.");
            return;
        }

        Dispatcher.UIThread.InvokeAsync(() =>
        {
            Debug.WriteLine($"[PlaybackService] OnPlaybackStopped: Exception: {e.Exception?.Message ?? "None"}");
            if (e.Exception != null)
            {
                Debug.WriteLine($"[PlaybackService] Playback stopped due to error: {e.Exception.Message}");
            }

            IsPlaying = false;
            CurrentPlaybackStatus = PlaybackStateStatus.Stopped;
            StopUiUpdateTimer();

            bool naturalEndOfSong = CurrentSong != null && audioFileReader != null &&
                                    audioFileReader.CurrentTime >= audioFileReader.TotalTime - TimeSpan.FromMilliseconds(500);

            if (naturalEndOfSong && (CurrentSong?.IsLoopActive == false || CurrentSong?.SavedLoop == null))
            {
                Debug.WriteLine($"[PlaybackService] Natural end of song: {CurrentSong?.Title}. Resetting position.");
                this.CurrentPosition = TimeSpan.Zero;
            }
        });
    }

    public void Pause()
    {
        if (IsPlaying && _waveOutDevice != null && _waveOutDevice.PlaybackState == PlaybackState.Playing)
        {
            Debug.WriteLine("[PlaybackService] Pause requested.");
            _waveOutDevice.Pause();
            IsPlaying = false;
            CurrentPlaybackStatus = PlaybackStateStatus.Paused;
            StopUiUpdateTimer();
        }
    }

    public void Resume()
    {
        if (CurrentSong == null)
        {
            Debug.WriteLine("[PlaybackService] Resume requested but no CurrentSong. Doing nothing.");
            return;
        }

        if (_waveOutDevice != null && _waveOutDevice.PlaybackState == PlaybackState.Paused && audioFileReader != null)
        {
            Debug.WriteLine("[PlaybackService] Resume requested from Paused state.");
            _waveOutDevice.Play();
            IsPlaying = true;
            CurrentPlaybackStatus = PlaybackStateStatus.Playing;
            StartUiUpdateTimer();
        }
        else if (CurrentPlaybackStatus == PlaybackStateStatus.Stopped)
        {
            Debug.WriteLine("[PlaybackService] Resume requested from Stopped state. Re-playing current song.");
            Play(CurrentSong);
        }
        else
        {
            Debug.WriteLine($"[PlaybackService] Resume requested but conditions not met. State: {_waveOutDevice?.PlaybackState}, AFR: {audioFileReader != null}, Status: {CurrentPlaybackStatus}");
        }
    }

    private void StopPlaybackInternal(bool resetCurrentSongAndRelatedState = true)
    {
        IsPlaying = false;
        CurrentPlaybackStatus = PlaybackStateStatus.Stopped;
        StopUiUpdateTimer();
        CleanUpNAudioResources();

        if (resetCurrentSongAndRelatedState)
        {
            CurrentSong = null;
            CurrentSongDuration = TimeSpan.Zero;
            this.CurrentPosition = TimeSpan.Zero;
            Debug.WriteLine("[PlaybackService] StopPlaybackInternal: CurrentSong, Duration, Position reset.");
        }
        else
        {
            Debug.WriteLine("[PlaybackService] StopPlaybackInternal: CurrentSong and related state NOT reset by this call (new song incoming). Resources cleaned.");
        }
    }

    public void Stop()
    {
        Debug.WriteLine("[PlaybackService] Public Stop() called.");
        StopPlaybackInternal(resetCurrentSongAndRelatedState: true);
    }

    public void Seek(TimeSpan requestedPosition)
    {
        if (audioFileReader == null || _waveOutDevice == null || CurrentSong == null)
        {
            Debug.WriteLine($"[PlaybackService] Seek ignored: AFR null? {audioFileReader == null}, Device null? {_waveOutDevice == null}, Song null? {CurrentSong == null}");
            return;
        }

        TimeSpan targetPosition = requestedPosition;

        if (CurrentSong.IsLoopActive && CurrentSong.SavedLoop != null)
        {
            var loop = CurrentSong.SavedLoop;
            if (loop.End > loop.Start)
            {
                if (targetPosition < loop.Start)
                {
                    Debug.WriteLine($"[PlaybackService] Seek: Loop active, target {targetPosition} < loop start {loop.Start}. Snapping to loop start.");
                    targetPosition = loop.Start;
                }
                else if (targetPosition > loop.End)
                {
                    Debug.WriteLine($"[PlaybackService] Seek: Loop active, target {targetPosition} > loop end {loop.End}. Snapping to loop start (as per spec: seeking outside loop end goes to loop start).");
                    targetPosition = loop.Start;
                }
            }
        }

        // Clamp targetPosition to valid range within the audio file.
        // Prevent seeking too close to the very end to avoid issues with NAudio or file formats.
        var maxSeekablePosition = audioFileReader.TotalTime - TimeSpan.FromMilliseconds(100);
        if (maxSeekablePosition < TimeSpan.Zero) maxSeekablePosition = TimeSpan.Zero; // Handle very short files
        targetPosition = TimeSpan.FromSeconds(Math.Clamp(targetPosition.TotalSeconds, 0, maxSeekablePosition.TotalSeconds));


        Debug.WriteLine($"[PlaybackService] Seeking to: {targetPosition}. Current AFR Time: {audioFileReader.CurrentTime}");
        audioFileReader.CurrentTime = targetPosition; // Actual engine seek

        // Update our CurrentPosition property to reflect the new position and notify listeners.
        this.CurrentPosition = audioFileReader.CurrentTime;
        Debug.WriteLine($"[PlaybackService] Seek completed. New Position: {this.CurrentPosition}, New AFR Time: {audioFileReader.CurrentTime}");
    }

    public void Dispose()
    {
        Debug.WriteLine("[PlaybackService] Dispose() called.");
        StopPlaybackInternal(true);
        uiUpdateTimer?.Dispose();
        uiUpdateTimer = null;
        GC.SuppressFinalize(this);
    }
}
</file>

<file path="Source\Services\SettingsService.cs">
using Sonorize.Models;
using System;
using System.IO;
using System.Text.Json;

namespace Sonorize.Services;

public class SettingsService
{
    private readonly string _settingsFilePath;

    public SettingsService()
    {
        var appDataPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
        var sonorizeAppDataPath = Path.Combine(appDataPath, "Sonorize");
        Directory.CreateDirectory(sonorizeAppDataPath); // Ensure directory exists
        _settingsFilePath = Path.Combine(sonorizeAppDataPath, "settings.json");
    }

    public AppSettings LoadSettings()
    {
        try
        {
            if (File.Exists(_settingsFilePath))
            {
                var json = File.ReadAllText(_settingsFilePath);
                return JsonSerializer.Deserialize<AppSettings>(json) ?? new AppSettings();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading settings: {ex.Message}");
            // Fallback to default settings
        }
        return new AppSettings();
    }

    public void SaveSettings(AppSettings settings)
    {
        try
        {
            var json = JsonSerializer.Serialize(settings, new JsonSerializerOptions { WriteIndented = true });
            File.WriteAllText(_settingsFilePath, json);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error saving settings: {ex.Message}");
        }
    }
}
</file>

<file path="Source\Services\ThemeService.cs">
using Sonorize.Models;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Diagnostics;

namespace Sonorize.Services;

public class ThemeService
{
    private readonly string _themesDirectory;
    public ThemeColors CurrentTheme { get; private set; }

    public const string DefaultThemeFileName = "DefaultTheme.json"; // Made public const
    private const string AmoledSpotifyThemeFileName = "AmoledSpotify.json";


    public ThemeService(string? preferredThemeNameFromSettings)
    {
        var appDataPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
        var sonorizeAppDataPath = Path.Combine(appDataPath, "Sonorize");
        _themesDirectory = Path.Combine(sonorizeAppDataPath, "Themes");
        Directory.CreateDirectory(_themesDirectory);

        EnsureDefaultThemesExist();

        string themeToLoad = DefaultThemeFileName; // Default to this one first

        if (!string.IsNullOrEmpty(preferredThemeNameFromSettings))
        {
            // Check if preferred theme exists
            if (File.Exists(Path.Combine(_themesDirectory, preferredThemeNameFromSettings)))
            {
                themeToLoad = preferredThemeNameFromSettings;
            }
            else
            {
                Debug.WriteLine($"[ThemeService] Preferred theme '{preferredThemeNameFromSettings}' not found. Falling back to default.");
            }
        }

        CurrentTheme = LoadThemeFromFile(themeToLoad);
        if (CurrentTheme == null) // If chosen (or default) theme failed, use hardcoded
        {
            Debug.WriteLine($"[ThemeService] Theme '{themeToLoad}' failed to load. Using hardcoded fallback (standard dark).");
            CurrentTheme = new ThemeColors(); // Hardcoded fallback (standard dark)
        }
        Debug.WriteLine($"[ThemeService] Current theme loaded: {themeToLoad} (BG: {CurrentTheme.BackgroundColor}, Accent: {CurrentTheme.AccentColor})");
    }

    private void EnsureDefaultThemesExist()
    {
        string defaultThemePath = Path.Combine(_themesDirectory, DefaultThemeFileName);
        if (!File.Exists(defaultThemePath))
        {
            SaveThemeToFile(new ThemeColors(), DefaultThemeFileName);
        }

        string amoledSpotifyThemePath = Path.Combine(_themesDirectory, AmoledSpotifyThemeFileName);
        if (!File.Exists(amoledSpotifyThemePath))
        {
            SaveThemeToFile(ThemeColors.CreateAmoledSpotifyTheme(), AmoledSpotifyThemeFileName);
        }
    }

    public ThemeColors? LoadThemeFromFile(string themeFileName)
    {
        // ... (LoadThemeFromFile remains the same as previous correct version) ...
        string filePath = Path.Combine(_themesDirectory, themeFileName);
        Debug.WriteLine($"[ThemeService] Attempting to load theme from: {filePath}");
        if (File.Exists(filePath))
        {
            try
            {
                var json = File.ReadAllText(filePath);
                var theme = JsonSerializer.Deserialize<ThemeColors>(json);
                if (theme != null)
                {
                    Debug.WriteLine($"[ThemeService] Theme '{themeFileName}' loaded successfully.");
                    return theme;
                }
                Debug.WriteLine($"[ThemeService] Failed to deserialize theme '{themeFileName}'. Json content was: {json.Substring(0, Math.Min(json.Length, 200))}");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[ThemeService] Error loading theme '{themeFileName}': {ex.Message}");
            }
        }
        else
        {
            Debug.WriteLine($"[ThemeService] Theme file not found: {filePath}");
        }
        return null;
    }

    public void SaveThemeToFile(ThemeColors theme, string themeFileName)
    {
        // ... (SaveThemeToFile remains the same as previous correct version) ...
        string filePath = Path.Combine(_themesDirectory, themeFileName);
        try
        {
            var options = new JsonSerializerOptions { WriteIndented = true };
            var json = JsonSerializer.Serialize(theme, options);
            File.WriteAllText(filePath, json);
            Debug.WriteLine($"[ThemeService] Theme '{themeFileName}' saved to: {filePath}");
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[ThemeService] Error saving theme '{themeFileName}': {ex.Message}");
        }
    }

    public List<string> GetAvailableThemeFiles()
    {
        if (!Directory.Exists(_themesDirectory))
        {
            return new List<string>();
        }
        return Directory.GetFiles(_themesDirectory, "*.json")
                        .Select(Path.GetFileName)
                        .Where(f => f != null) // Path.GetFileName can return null
                        .ToList()!; // Non-null asserted as we filter nulls
    }
}
</file>

<file path="Source\Services\WaveFormService.cs">
using Avalonia;
using NAudio.Wave;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Diagnostics;
using System.IO; // Required for Path.GetFileName

namespace Sonorize.Services;

// Represents a simplified data point for the waveform
public record WaveformPoint(double X, double YPeak);

public class WaveformService
{
    // Cache for waveform data to avoid reprocessing
    private readonly Dictionary<string, List<WaveformPoint>> _waveformCache = new();

    public async Task<List<WaveformPoint>> GetWaveformAsync(string filePath, int targetPoints)
    {
        if (string.IsNullOrEmpty(filePath) || targetPoints <= 0)
        {
            Debug.WriteLine($"[WaveformService] Invalid input: filePath is null/empty or targetPoints <= 0. File: '{filePath}', Points: {targetPoints}");
            return new List<WaveformPoint>();
        }

        // For debugging, temporarily disable cache to ensure fresh generation
        // if (_waveformCache.ContainsKey(filePath)) _waveformCache.Remove(filePath);

        if (_waveformCache.TryGetValue(filePath, out var cachedData))
        {
            Debug.WriteLine($"[WaveformService] Returning cached waveform for \"{Path.GetFileName(filePath)}\". Points: {cachedData.Count}");
            return cachedData;
        }

        Debug.WriteLine($"[WaveformService] Generating waveform for \"{Path.GetFileName(filePath)}\". Target points: {targetPoints}.");
        List<WaveformPoint> points = new List<WaveformPoint>();

        try
        {
            await Task.Run(() =>
            {
                using (var reader = new AudioFileReader(filePath))
                {
                    Debug.WriteLine($"[WaveformServiceReader] File: \"{Path.GetFileName(filePath)}\", TotalTime: {reader.TotalTime}, Channels: {reader.WaveFormat.Channels}, SampleRate: {reader.WaveFormat.SampleRate}, BitsPerSample: {reader.WaveFormat.BitsPerSample}, Encoding: {reader.WaveFormat.Encoding}, BlockAlign: {reader.WaveFormat.BlockAlign}, Length (bytes): {reader.Length}");

                    if (reader.WaveFormat.BlockAlign == 0)
                    {
                        Debug.WriteLine($"[WaveformServiceReader] File \"{Path.GetFileName(filePath)}\" has BlockAlign = 0. Cannot calculate total sample frames.");
                        return;
                    }

                    long totalSampleFrames = reader.Length / reader.WaveFormat.BlockAlign;

                    if (totalSampleFrames == 0)
                    {
                        Debug.WriteLine($"[WaveformServiceReader] File \"{Path.GetFileName(filePath)}\" has 0 sample frames (Length: {reader.Length}, BlockAlign: {reader.WaveFormat.BlockAlign}). Cannot generate waveform.");
                        return;
                    }

                    var samplesPerFrameToProcessPerPoint = (int)Math.Max(1, totalSampleFrames / targetPoints);
                    var bufferSizeInSamples = samplesPerFrameToProcessPerPoint * reader.WaveFormat.Channels;

                    if (bufferSizeInSamples == 0)
                    {
                        Debug.WriteLine($"[WaveformServiceReader] Calculated bufferSizeInSamples is 0 for \"{Path.GetFileName(filePath)}\". TotalSampleFrames: {totalSampleFrames}, TargetPoints: {targetPoints}, Channels: {reader.WaveFormat.Channels}, SamplesPerFrameToProcessPerPoint: {samplesPerFrameToProcessPerPoint}. Cannot generate.");
                        return;
                    }

                    var buffer = new float[bufferSizeInSamples];
                    int samplesReadFromAudioFile;
                    double currentX = 0;
                    double xIncrement = 1.0 / targetPoints;
                    int pointsGeneratedCount = 0;

                    Debug.WriteLine($"[WaveformServiceReader] Processing \"{Path.GetFileName(filePath)}\": TotalSampleFrames: {totalSampleFrames}, TargetPoints: {targetPoints}, SamplesPerFrameToProcessPerPoint: {samplesPerFrameToProcessPerPoint}, BufferSizeInFloats: {bufferSizeInSamples}");

                    for (int i = 0; i < targetPoints; i++)
                    {
                        float maxPeakInChunk = 0f;

                        samplesReadFromAudioFile = reader.Read(buffer, 0, buffer.Length);

                        if (samplesReadFromAudioFile == 0)
                        {
                            Debug.WriteLine($"[WaveformServiceReader] Read 0 samples at waveform point index {i} (target: {targetPoints}) for \"{Path.GetFileName(filePath)}\". End of audio stream reached.");
                            break;
                        }

                        for (int n = 0; n < samplesReadFromAudioFile; n++)
                        {
                            maxPeakInChunk = Math.Max(maxPeakInChunk, Math.Abs(buffer[n]));
                        }

                        points.Add(new WaveformPoint(currentX, maxPeakInChunk));
                        pointsGeneratedCount++;

                        if (i < 5 || (i > 0 && i % (targetPoints / 10) == 0) || i == targetPoints - 1)
                        {
                            Debug.WriteLine($"[WaveformServiceReader] Point {i}: X={currentX:F3}, Calculated YPeak={maxPeakInChunk:F4}, SamplesInThisChunk={samplesReadFromAudioFile}");
                        }

                        currentX += xIncrement;
                        if (currentX > 1.0) currentX = 1.0;
                    }
                    Debug.WriteLine($"[WaveformServiceReader] Loop finished for \"{Path.GetFileName(filePath)}\". Total waveform points generated: {pointsGeneratedCount}. (Target was {targetPoints})");
                }
            });

            if (points.Any())
            {
                _waveformCache[filePath] = points;
                Debug.WriteLine($"[WaveformService] Waveform generated and cached for \"{Path.GetFileName(filePath)}\", {points.Count} points. First point YPeak: {points[0].YPeak:F4}. Approx mid point YPeak: {points[points.Count / 2].YPeak:F4}. Last point YPeak: {points.Last().YPeak:F4}");
            }
            else
            {
                Debug.WriteLine($"[WaveformService] No points generated for \"{Path.GetFileName(filePath)}\". It might be too short, silent, or an issue with reading audio data.");
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[WaveformService] CRITICAL Error generating waveform for \"{Path.GetFileName(filePath)}\": {ex.ToString()}");
            return new List<WaveformPoint>();
        }
        return points;
    }

    public void ClearCache()
    {
        _waveformCache.Clear();
        Debug.WriteLine("[WaveformService] Cache cleared.");
    }
}
</file>

<file path="Source\Utils\AlbumArtistTupleComparer.cs">
// Path: Source/Utils/AlbumArtistTupleComparer.cs (or a similar appropriate location)
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis; // For NotNullWhen attribute

namespace Sonorize.Utils; // Or your preferred namespace for utility classes

public class AlbumArtistTupleComparer : IEqualityComparer<(string Album, string Artist)>
{
    public bool Equals((string Album, string Artist) x, (string Album, string Artist) y)
    {
        return string.Equals(x.Album, y.Album, StringComparison.OrdinalIgnoreCase) &&
               string.Equals(x.Artist, y.Artist, StringComparison.OrdinalIgnoreCase);
    }

    public int GetHashCode([DisallowNull] (string Album, string Artist) obj)
    {
        // Combine hash codes in a way that's sensitive to order and case-insensitivity
        // For case-insensitivity in hash code, convert to a consistent case first
        int albumHashCode = obj.Album?.ToLowerInvariant().GetHashCode() ?? 0;
        int artistHashCode = obj.Artist?.ToLowerInvariant().GetHashCode() ?? 0;
        return HashCode.Combine(albumHashCode, artistHashCode);
    }

    // Static instance for convenience
    public static readonly AlbumArtistTupleComparer Instance = new AlbumArtistTupleComparer();
}
</file>

<file path="Source\Utils\BindingProxy.cs">
using Avalonia;

namespace Sonorize.Util // Or Sonorize.Views, Sonorize.UI, etc.
{
    public class BindingProxy : AvaloniaObject
    {
        public static readonly StyledProperty<object?> DataProperty =
            AvaloniaProperty.Register<BindingProxy, object?>(nameof(Data));

        public object? Data
        {
            get => GetValue(DataProperty);
            set => SetValue(DataProperty, value);
        }
    }
}
</file>

<file path="Source\ViewModels\AlbumViewModel.cs">
using Avalonia.Media.Imaging;

namespace Sonorize.ViewModels;

public class AlbumViewModel
{
    public string? Title { get; set; }       // Album Title
    public string? Artist { get; set; }      // Primary Artist for this album
    public Bitmap? Thumbnail { get; set; }
    public string DisplayText => $"{Title} - {Artist}"; // For simpler display if needed
}
</file>

<file path="Source\ViewModels\ArtistViewModel.cs">
using Avalonia.Media.Imaging;

namespace Sonorize.ViewModels;

public class ArtistViewModel
{
    public string? Name { get; set; }
    public Bitmap? Thumbnail { get; set; }
    // You could add more properties later, like SongCount or AlbumCount
}
</file>

<file path="Source\ViewModels\MainViewModel.cs">
// Path: Source/ViewModels/MainViewModel.cs
using Avalonia.Controls;
using Sonorize.Models;
using Sonorize.Services;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Input;
using System;
using System.Diagnostics;
using Avalonia.Threading;
using System.ComponentModel;
using System.Collections.Generic;
using Avalonia.Media.Imaging;
using Avalonia.Platform.Storage;
using Sonorize.Utils; // For AlbumArtistTupleComparer

namespace Sonorize.ViewModels;

public class MainWindowViewModel : ViewModelBase
{
    private readonly SettingsService _settingsService;
    private readonly MusicLibraryService _musicLibraryService;
    private readonly WaveformService _waveformService;
    private readonly LoopDataService _loopDataService;
    public PlaybackService PlaybackService { get; }
    public ThemeColors CurrentTheme { get; }

    public bool HasCurrentSong => PlaybackService.CurrentSong != null;

    private readonly ObservableCollection<Song> _allSongs = new();
    public ObservableCollection<Song> FilteredSongs { get; } = new();
    public ObservableCollection<ArtistViewModel> Artists { get; } = new();
    public ObservableCollection<AlbumViewModel> Albums { get; } = new();

    private string _searchQuery = string.Empty;
    public string SearchQuery { get => _searchQuery; set { if (SetProperty(ref _searchQuery, value)) ApplyFilter(); } }

    private Song? _selectedSongInternal;
    public Song? SelectedSong
    {
        get => _selectedSongInternal;
        set
        {
            if (_selectedSongInternal != value)
            {
                var previousSong = _selectedSongInternal;
                if (SetProperty(ref _selectedSongInternal, value))
                {
                    HandleSelectedSongChange(previousSong, _selectedSongInternal);
                }
            }
        }
    }

    private ArtistViewModel? _selectedArtist;
    public ArtistViewModel? SelectedArtist
    {
        get => _selectedArtist;
        set
        {
            if (SetProperty(ref _selectedArtist, value))
            {
                if (value != null)
                {
                    OnArtistSelected(value);
                }
            }
        }
    }

    private AlbumViewModel? _selectedAlbum;
    public AlbumViewModel? SelectedAlbum
    {
        get => _selectedAlbum;
        set
        {
            if (SetProperty(ref _selectedAlbum, value))
            {
                if (value != null)
                {
                    OnAlbumSelected(value);
                }
            }
        }
    }

    private int _activeTabIndex = 0;
    public int ActiveTabIndex { get => _activeTabIndex; set => SetProperty(ref _activeTabIndex, value); }

    private bool _isCurrentLoopActiveUiBinding;
    public bool IsCurrentLoopActiveUiBinding
    {
        get => _isCurrentLoopActiveUiBinding;
        set
        {
            if (SetProperty(ref _isCurrentLoopActiveUiBinding, value))
            {
                if (PlaybackService.CurrentSong != null && PlaybackService.CurrentSong.SavedLoop != null)
                {
                    PlaybackService.CurrentSong.IsLoopActive = value;
                }
                else if (PlaybackService.CurrentSong != null && PlaybackService.CurrentSong.SavedLoop == null && value == true)
                {
                    _isCurrentLoopActiveUiBinding = false;
                    OnPropertyChanged(nameof(IsCurrentLoopActiveUiBinding));
                    Debug.WriteLine($"[MainVM] Attempted to activate loop via UI, but no loop is defined for {PlaybackService.CurrentSong.Title}.");
                }
            }
        }
    }

    private string _statusBarText = "Welcome to Sonorize!";
    public string StatusBarText { get => _statusBarText; set => SetProperty(ref _statusBarText, value); }

    private bool _isLoadingLibrary = false;
    public bool IsLoadingLibrary { get => _isLoadingLibrary; set { if (SetProperty(ref _isLoadingLibrary, value)) OnIsLoadingLibraryChanged(); } }

    private bool _isAdvancedPanelVisible;
    public bool IsAdvancedPanelVisible { get => _isAdvancedPanelVisible; set { if (SetProperty(ref _isAdvancedPanelVisible, value)) OnAdvancedPanelVisibleChanged(); } }

    private double _playbackSpeed = 1.0;
    public double PlaybackSpeed { get => _playbackSpeed; set { value = Math.Clamp(value, 0.5, 2.0); if (SetProperty(ref _playbackSpeed, value)) { PlaybackService.PlaybackRate = (float)value; OnPropertyChanged(nameof(PlaybackSpeedDisplay)); } } }
    public string PlaybackSpeedDisplay => $"{PlaybackSpeed:F2}x";

    private double _playbackPitch = 0.0;
    public double PlaybackPitch { get => _playbackPitch; set { value = Math.Round(value * 2, MidpointRounding.AwayFromZero) / 2.0; value = Math.Clamp(value, -4.0, 4.0); if (SetProperty(ref _playbackPitch, value)) { PlaybackService.PitchSemitones = (float)_playbackPitch; OnPropertyChanged(nameof(PlaybackPitchDisplay)); } } }
    public string PlaybackPitchDisplay => $"{PlaybackPitch:+0.0;-0.0;0} st";

    public ObservableCollection<WaveformPoint> WaveformRenderData { get; } = new();
    private bool _isWaveformLoading = false;
    public bool IsWaveformLoading { get => _isWaveformLoading; private set => SetProperty(ref _isWaveformLoading, value); }

    private TimeSpan? _newLoopStartCandidate;
    public TimeSpan? NewLoopStartCandidate { get => _newLoopStartCandidate; set { SetProperty(ref _newLoopStartCandidate, value); OnPropertyChanged(nameof(CanSaveLoopRegion)); OnPropertyChanged(nameof(NewLoopStartCandidateDisplay)); } }

    private TimeSpan? _newLoopEndCandidate;
    public TimeSpan? NewLoopEndCandidate { get => _newLoopEndCandidate; set { SetProperty(ref _newLoopEndCandidate, value); OnPropertyChanged(nameof(CanSaveLoopRegion)); OnPropertyChanged(nameof(NewLoopEndCandidateDisplay)); } }

    public string NewLoopStartCandidateDisplay => _newLoopStartCandidate.HasValue ? $"{_newLoopStartCandidate.Value:mm\\:ss\\.ff}" : "Not set";
    public string NewLoopEndCandidateDisplay => _newLoopEndCandidate.HasValue ? $"{_newLoopEndCandidate.Value:mm\\:ss\\.ff}" : "Not set";

    private string _activeLoopDisplayText = "No loop defined.";
    public string ActiveLoopDisplayText { get => _activeLoopDisplayText; set => SetProperty(ref _activeLoopDisplayText, value); }

    public double SliderPositionSeconds
    {
        get => PlaybackService.CurrentPosition.TotalSeconds;
        set
        {
            if (PlaybackService.HasCurrentSong && PlaybackService.CurrentSongDuration.TotalSeconds > 0)
            {
                // Check if the new value is significantly different from the current playback position
                // to avoid seeking for tiny adjustments that might come from the binding itself during updates.
                // A threshold of 50-100ms might be reasonable.
                if (Math.Abs(PlaybackService.CurrentPosition.TotalSeconds - value) > 0.1)
                {
                    Debug.WriteLine($"[MainVM.SliderPositionSeconds.set] User seeking via slider to: {value:F2}s. Current playback pos: {PlaybackService.CurrentPosition.TotalSeconds:F2}s");
                    PlaybackService.Seek(TimeSpan.FromSeconds(value));
                }
            }
            // We don't call OnPropertyChanged(nameof(SliderPositionSeconds)) here.
            // The slider will be updated when PlaybackService.CurrentPosition changes,
            // which triggers OnPlaybackServicePropertyChanged, which then calls
            // OnPropertyChanged(nameof(SliderPositionSeconds)). This creates the correct notification loop.
        }
    }

    public ICommand LoadInitialDataCommand { get; }
    public ICommand OpenSettingsCommand { get; }
    public ICommand ExitCommand { get; }
    public ICommand AddDirectoryAndRefreshCommand { get; }
    public ICommand ToggleAdvancedPanelCommand { get; }
    public ICommand CaptureLoopStartCandidateCommand { get; }
    public ICommand CaptureLoopEndCandidateCommand { get; }
    public ICommand SaveLoopCommand { get; }
    public ICommand ClearLoopCommand { get; }
    public ICommand ToggleLoopActiveCommand { get; }
    public ICommand WaveformSeekCommand { get; }

    public MainWindowViewModel(
        SettingsService settingsService,
        MusicLibraryService musicLibraryService,
        PlaybackService playbackService,
        ThemeColors theme,
        WaveformService waveformService,
        LoopDataService loopDataService)
    {
        _settingsService = settingsService;
        _musicLibraryService = musicLibraryService;
        PlaybackService = playbackService;
        CurrentTheme = theme;
        _waveformService = waveformService;
        _loopDataService = loopDataService;

        LoadInitialDataCommand = new RelayCommand(async _ => await LoadMusicLibrary(), _ => !IsLoadingLibrary);
        OpenSettingsCommand = new RelayCommand(async owner => await OpenSettingsDialog(owner), _ => !IsLoadingLibrary);
        ExitCommand = new RelayCommand(_ => Environment.Exit(0));
        AddDirectoryAndRefreshCommand = new RelayCommand(async owner => await AddMusicDirectoryAndRefresh(owner), _ => !IsLoadingLibrary);
        ToggleAdvancedPanelCommand = new RelayCommand(_ => IsAdvancedPanelVisible = !IsAdvancedPanelVisible, _ => (SelectedSong != null || PlaybackService.CurrentSong != null) && !IsLoadingLibrary);
        CaptureLoopStartCandidateCommand = new RelayCommand(_ => NewLoopStartCandidate = PlaybackService.CurrentPosition, _ => PlaybackService.CurrentSong != null && PlaybackService.CurrentPlaybackStatus != PlaybackStateStatus.Stopped);
        CaptureLoopEndCandidateCommand = new RelayCommand(_ => NewLoopEndCandidate = PlaybackService.CurrentPosition, _ => PlaybackService.CurrentSong != null && PlaybackService.CurrentPlaybackStatus != PlaybackStateStatus.Stopped);
        SaveLoopCommand = new RelayCommand(SaveLoopAction, _ => CanSaveLoopRegion);
        ClearLoopCommand = new RelayCommand(ClearSavedLoopAction, _ => PlaybackService.CurrentSong?.SavedLoop != null);
        ToggleLoopActiveCommand = new RelayCommand(ToggleCurrentSongLoopActive, _ => PlaybackService.CurrentSong?.SavedLoop != null);
        WaveformSeekCommand = new RelayCommand(timeSpanObj => { if (timeSpanObj is TimeSpan ts && PlaybackService.CurrentSong != null) PlaybackService.Seek(ts); }, _ => PlaybackService.CurrentSong != null);

        PlaybackService.PropertyChanged += OnPlaybackServicePropertyChanged;
        PlaybackSpeed = 1.0;
        PlaybackPitch = 0.0;
        UpdateAllUIDependentStates();
    }

    private void OnIsLoadingLibraryChanged()
    {
        (LoadInitialDataCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (OpenSettingsCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (AddDirectoryAndRefreshCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (ToggleAdvancedPanelCommand as RelayCommand)?.RaiseCanExecuteChanged();
        if (_isLoadingLibrary) IsAdvancedPanelVisible = false;
    }

    private void OnAdvancedPanelVisibleChanged()
    {
        (ToggleAdvancedPanelCommand as RelayCommand)?.RaiseCanExecuteChanged();
        if (IsAdvancedPanelVisible && PlaybackService.CurrentSong != null && (!WaveformRenderData.Any() || !IsWaveformLoading))
        {
            _ = LoadWaveformForCurrentSong();
        }
    }

    private void UpdateAllUIDependentStates()
    {
        OnPropertyChanged(nameof(HasCurrentSong));
        UpdateLoopEditorForCurrentSong();
        UpdateActiveLoopDisplayText();
        UpdateStatusBarText();
        RaiseAllCommandsCanExecuteChanged();
    }

    private void RaiseAllCommandsCanExecuteChanged()
    {
        (LoadInitialDataCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (OpenSettingsCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (AddDirectoryAndRefreshCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (ToggleAdvancedPanelCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (SaveLoopCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (ClearLoopCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (ToggleLoopActiveCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (CaptureLoopStartCandidateCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (CaptureLoopEndCandidateCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (WaveformSeekCommand as RelayCommand)?.RaiseCanExecuteChanged();
    }

    private void HandleSelectedSongChange(Song? oldSong, Song? newSong)
    {
        Debug.WriteLine($"[MainVM] HandleSelectedSongChange. Old: {oldSong?.Title ?? "null"}, New: {newSong?.Title ?? "null"}");
        if (oldSong != null)
        {
            oldSong.PropertyChanged -= OnCurrentSongSavedLoopChanged;
            oldSong.PropertyChanged -= OnCurrentSongIsLoopActiveChanged;
        }

        if (newSong != null)
        {
            if (newSong != PlaybackService.CurrentSong || PlaybackService.CurrentPlaybackStatus == PlaybackStateStatus.Stopped)
            {
                PlaybackService.Play(newSong);
            }
            else
            {
                IsCurrentLoopActiveUiBinding = newSong.IsLoopActive;
            }

            if (_selectedSongInternal != null)
            {
                _selectedSongInternal.PropertyChanged += OnCurrentSongSavedLoopChanged;
                _selectedSongInternal.PropertyChanged += OnCurrentSongIsLoopActiveChanged;
            }
        }
        else
        {
            if (PlaybackService.CurrentSong != null)
            {
                PlaybackService.Stop();
            }
        }
        (ToggleAdvancedPanelCommand as RelayCommand)?.RaiseCanExecuteChanged();
    }

    private void OnPlaybackServicePropertyChanged(object? sender, PropertyChangedEventArgs args)
    {
        Dispatcher.UIThread.InvokeAsync(() =>
        {
            switch (args.PropertyName)
            {
                case nameof(PlaybackService.CurrentSong):
                    var currentServiceSong = PlaybackService.CurrentSong;
                    Debug.WriteLine($"[MainVM_PSPChanged] Service.CurrentSong is now: {currentServiceSong?.Title ?? "null"}");

                    if (_selectedSongInternal != null && _selectedSongInternal != currentServiceSong)
                    {
                        _selectedSongInternal.PropertyChanged -= OnCurrentSongSavedLoopChanged;
                        _selectedSongInternal.PropertyChanged -= OnCurrentSongIsLoopActiveChanged;
                    }

                    if (currentServiceSong != null)
                    {
                        IsCurrentLoopActiveUiBinding = currentServiceSong.IsLoopActive;
                        if (_selectedSongInternal != currentServiceSong)
                        {
                            currentServiceSong.PropertyChanged += OnCurrentSongSavedLoopChanged;
                            currentServiceSong.PropertyChanged += OnCurrentSongIsLoopActiveChanged;
                        }
                    }
                    else
                    {
                        IsCurrentLoopActiveUiBinding = false;
                        WaveformRenderData.Clear();
                        OnPropertyChanged(nameof(WaveformRenderData));
                    }
                    UpdateAllUIDependentStates();
                    OnPropertyChanged(nameof(SliderPositionSeconds)); // Update slider when song changes
                    if (currentServiceSong != null) _ = LoadWaveformForCurrentSong();
                    break;

                case nameof(PlaybackService.IsPlaying):
                case nameof(PlaybackService.CurrentPlaybackStatus):
                    UpdateStatusBarText();
                    RaiseAllCommandsCanExecuteChanged();
                    break;

                case nameof(PlaybackService.CurrentPosition):
                    OnPropertyChanged(nameof(SliderPositionSeconds)); // Update slider when position changes
                    OnPropertyChanged(nameof(CanSaveLoopRegion));
                    (CaptureLoopStartCandidateCommand as RelayCommand)?.RaiseCanExecuteChanged(); // Position changed
                    (CaptureLoopEndCandidateCommand as RelayCommand)?.RaiseCanExecuteChanged(); // Position changed
                    // No need to call RaiseAllCommandsCanExecuteChanged() generally, as slider itself doesn't use CanExecute
                    break;

                case nameof(PlaybackService.CurrentSongDuration):
                    OnPropertyChanged(nameof(SliderPositionSeconds)); // Max value might have changed
                    OnPropertyChanged(nameof(CanSaveLoopRegion));
                    break;
            }
        });
    }

    private void OnCurrentSongSavedLoopChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName == nameof(Song.SavedLoop) && sender is Song song && song == PlaybackService.CurrentSong)
        {
            Dispatcher.UIThread.InvokeAsync(() =>
            {
                Debug.WriteLine($"[MainVM_SongPChanged] SavedLoop changed for {song.Title}. Active: {song.IsLoopActive}");
                UpdateActiveLoopDisplayText();
                UpdateStatusBarText();
                (ToggleLoopActiveCommand as RelayCommand)?.RaiseCanExecuteChanged();
                (ClearLoopCommand as RelayCommand)?.RaiseCanExecuteChanged();
                (SaveLoopCommand as RelayCommand)?.RaiseCanExecuteChanged();
                if (song.SavedLoop != null && !song.IsLoopActive)
                {
                    song.IsLoopActive = true;
                }
                else if (song.SavedLoop == null && song.IsLoopActive)
                {
                    song.IsLoopActive = false;
                }
                IsCurrentLoopActiveUiBinding = song.IsLoopActive;
            });
        }
    }

    private void OnCurrentSongIsLoopActiveChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName == nameof(Song.IsLoopActive) && sender is Song song && song == PlaybackService.CurrentSong)
        {
            Dispatcher.UIThread.InvokeAsync(() =>
            {
                Debug.WriteLine($"[MainVM_SongPChanged] IsLoopActive changed to {song.IsLoopActive} for {song.Title}. Persisting.");
                if (song.SavedLoop != null)
                {
                    _loopDataService.UpdateLoopActiveState(song.FilePath, song.IsLoopActive);
                }
                if (_isCurrentLoopActiveUiBinding != song.IsLoopActive)
                {
                    IsCurrentLoopActiveUiBinding = song.IsLoopActive;
                }
                UpdateActiveLoopDisplayText();
                UpdateStatusBarText();
            });
        }
    }

    private void ToggleCurrentSongLoopActive(object? parameter)
    {
        if (PlaybackService.CurrentSong != null && PlaybackService.CurrentSong.SavedLoop != null)
        {
            IsCurrentLoopActiveUiBinding = !IsCurrentLoopActiveUiBinding;
        }
    }

    private void OnArtistSelected(ArtistViewModel artist)
    {
        if (artist?.Name == null) return;
        Debug.WriteLine($"[MainVM] Artist selected: {artist.Name}");
        SearchQuery = artist.Name;
        ActiveTabIndex = 0;
    }

    private void OnAlbumSelected(AlbumViewModel album)
    {
        if (album?.Title == null || album.Artist == null) return;
        Debug.WriteLine($"[MainVM] Album selected: {album.Title} by {album.Artist}");
        SearchQuery = string.Empty;

        FilteredSongs.Clear();
        var songsInAlbum = _allSongs.Where(s =>
            s.Album.Equals(album.Title, StringComparison.OrdinalIgnoreCase) &&
            s.Artist.Equals(album.Artist, StringComparison.OrdinalIgnoreCase))
            .OrderBy(s => s.Title);

        foreach (var song in songsInAlbum)
        {
            FilteredSongs.Add(song);
        }
        UpdateStatusBarText();
        ActiveTabIndex = 0;
    }


    private void ApplyFilter()
    {
        FilteredSongs.Clear();
        var songsToFilter = _allSongs.AsEnumerable();
        if (!string.IsNullOrWhiteSpace(SearchQuery))
        {
            var query = SearchQuery.ToLowerInvariant().Trim();
            songsToFilter = songsToFilter.Where(s =>
                (s.Title?.ToLowerInvariant().Contains(query) ?? false) ||
                (s.Artist?.ToLowerInvariant().Contains(query) ?? false) ||
                (s.Album?.ToLowerInvariant().Contains(query) ?? false));
        }
        foreach (var song in songsToFilter.OrderBy(s => s.Artist).ThenBy(s => s.Album).ThenBy(s => s.Title))
        {
            FilteredSongs.Add(song);
        }
        if (SelectedSong != null && !FilteredSongs.Contains(SelectedSong))
        {
            SelectedSong = null;
        }
        UpdateStatusBarText();
    }

    private async Task LoadWaveformForCurrentSong()
    {
        var songToLoadWaveformFor = PlaybackService.CurrentSong;
        if (songToLoadWaveformFor == null || string.IsNullOrEmpty(songToLoadWaveformFor.FilePath))
        {
            WaveformRenderData.Clear(); OnPropertyChanged(nameof(WaveformRenderData)); IsWaveformLoading = false; return;
        }
        IsWaveformLoading = true;
        try
        {
            Debug.WriteLine($"[MainVM] Requesting waveform for: {songToLoadWaveformFor.Title}");
            var points = await _waveformService.GetWaveformAsync(songToLoadWaveformFor.FilePath, 1000);
            if (PlaybackService.CurrentSong == songToLoadWaveformFor) // Check if song is still current
            {
                WaveformRenderData.Clear(); foreach (var p in points) WaveformRenderData.Add(p); OnPropertyChanged(nameof(WaveformRenderData));
                Debug.WriteLine($"[MainVM] Waveform loaded for: {songToLoadWaveformFor.Title}, {points.Count} points.");
            }
            else
            {
                Debug.WriteLine($"[MainVM] Waveform for {songToLoadWaveformFor.Title} loaded, but current song is now {PlaybackService.CurrentSong?.Title ?? "null"}. Discarding.");
                WaveformRenderData.Clear(); OnPropertyChanged(nameof(WaveformRenderData)); // Clear if stale
            }
        }
        catch (Exception ex) { Debug.WriteLine($"[MainVM] Failed to load waveform for {songToLoadWaveformFor.Title}: {ex.Message}"); WaveformRenderData.Clear(); OnPropertyChanged(nameof(WaveformRenderData)); }
        finally { IsWaveformLoading = false; }
    }

    private void UpdateLoopEditorForCurrentSong()
    {
        var currentServiceSong = PlaybackService.CurrentSong;
        if (currentServiceSong?.SavedLoop != null)
        {
            NewLoopStartCandidate = currentServiceSong.SavedLoop.Start;
            NewLoopEndCandidate = currentServiceSong.SavedLoop.End;
            IsCurrentLoopActiveUiBinding = currentServiceSong.IsLoopActive;
        }
        else
        {
            NewLoopStartCandidate = null; NewLoopEndCandidate = null; IsCurrentLoopActiveUiBinding = false;
        }
        OnPropertyChanged(nameof(CanSaveLoopRegion));
        // Commands related to loop editing might need CanExecuteChanged raised here
        (CaptureLoopStartCandidateCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (CaptureLoopEndCandidateCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (SaveLoopCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (ClearLoopCommand as RelayCommand)?.RaiseCanExecuteChanged();
        (ToggleLoopActiveCommand as RelayCommand)?.RaiseCanExecuteChanged();
    }

    private void ClearLoopCandidateInputs() { NewLoopStartCandidate = null; NewLoopEndCandidate = null; /* CanSaveLoopRegion will update, and its command */ }
    public bool CanSaveLoopRegion => PlaybackService.CurrentSong != null && NewLoopStartCandidate.HasValue && NewLoopEndCandidate.HasValue && NewLoopEndCandidate.Value > NewLoopStartCandidate.Value && NewLoopEndCandidate.Value <= PlaybackService.CurrentSongDuration && NewLoopStartCandidate.Value >= TimeSpan.Zero;

    private void SaveLoopAction(object? param)
    {
        var currentServiceSong = PlaybackService.CurrentSong;
        if (!CanSaveLoopRegion || currentServiceSong == null || !NewLoopStartCandidate.HasValue || !NewLoopEndCandidate.HasValue) return;
        var newLoop = new LoopRegion(NewLoopStartCandidate.Value, NewLoopEndCandidate.Value, "User Loop");
        bool shouldBeActive = (currentServiceSong.SavedLoop != null && currentServiceSong.IsLoopActive) || currentServiceSong.SavedLoop == null; // Default to active if new, or preserve current state
        currentServiceSong.SavedLoop = newLoop;
        if (currentServiceSong.IsLoopActive != shouldBeActive) { currentServiceSong.IsLoopActive = shouldBeActive; } // This will trigger persistence via OnCurrentSongIsLoopActiveChanged
        else { _loopDataService.SetLoop(currentServiceSong.FilePath, newLoop.Start, newLoop.End, currentServiceSong.IsLoopActive); } // Persist if IsLoopActive didn't change but loop did
        Debug.WriteLine($"[MainVM] Loop saved for {currentServiceSong.Title}. Active: {currentServiceSong.IsLoopActive}");
        UpdateLoopEditorForCurrentSong(); // Refresh editor state (e.g. CanExecute for Clear)
    }

    private void ClearSavedLoopAction(object? param)
    {
        var currentServiceSong = PlaybackService.CurrentSong;
        if (currentServiceSong != null)
        {
            var filePath = currentServiceSong.FilePath;
            currentServiceSong.SavedLoop = null; // This will trigger OnCurrentSongSavedLoopChanged, then OnCurrentSongIsLoopActiveChanged if it's set to false by the former's logic
            currentServiceSong.IsLoopActive = false; // Explicitly set to false and ensure persistence if SavedLoop was already null by some chance
            if (!string.IsNullOrEmpty(filePath)) { _loopDataService.ClearLoop(filePath); }
        }
        ClearLoopCandidateInputs();
        UpdateLoopEditorForCurrentSong();
    }

    private void UpdateActiveLoopDisplayText()
    {
        var currentServiceSong = PlaybackService.CurrentSong;
        if (currentServiceSong?.SavedLoop != null)
        {
            var loop = currentServiceSong.SavedLoop; string activeStatus = currentServiceSong.IsLoopActive ? " (Active)" : " (Inactive)";
            ActiveLoopDisplayText = $"Loop: {loop.Start:mm\\:ss\\.f} - {loop.End:mm\\:ss\\.f}{activeStatus}";
        }
        else ActiveLoopDisplayText = "No loop defined.";
    }

    private void UpdateStatusBarText()
    {
        if (IsLoadingLibrary) return; string status; var currentServiceSong = PlaybackService.CurrentSong;
        if (currentServiceSong != null)
        {
            string stateStr = PlaybackService.CurrentPlaybackStatus switch { PlaybackStateStatus.Playing => "Playing", PlaybackStateStatus.Paused => "Paused", PlaybackStateStatus.Stopped => "Stopped", _ => "Idle" };
            status = $"{stateStr}: {currentServiceSong.Title}";
            if (currentServiceSong.SavedLoop != null && currentServiceSong.IsLoopActive) status += $" (Loop Active)";
        }
        else
        {
            status = $"Sonorize - {FilteredSongs.Count} of {_allSongs.Count} songs displayed.";
            if (_allSongs.Count == 0 && !IsLoadingLibrary && !_settingsService.LoadSettings().MusicDirectories.Any()) status = "Sonorize - Library empty. Add directories via File menu.";
            else if (_allSongs.Count == 0 && !IsLoadingLibrary && _settingsService.LoadSettings().MusicDirectories.Any()) status = "Sonorize - No songs found in configured directories.";
        }
        StatusBarText = status;
    }

    private async Task LoadMusicLibrary()
    {
        if (IsLoadingLibrary) return; IsAdvancedPanelVisible = false; IsLoadingLibrary = true; SearchQuery = string.Empty; var settings = _settingsService.LoadSettings();
        await Dispatcher.UIThread.InvokeAsync(() => {
            SelectedSong = null; _allSongs.Clear(); Artists.Clear(); Albums.Clear(); FilteredSongs.Clear(); WaveformRenderData.Clear(); OnPropertyChanged(nameof(WaveformRenderData)); StatusBarText = "Preparing to load music..."; UpdateAllUIDependentStates();
        });
        if (settings.MusicDirectories.Any())
        {
            try
            {
                await Task.Run(async () => { await _musicLibraryService.LoadMusicFromDirectoriesAsync(settings.MusicDirectories, song => Dispatcher.UIThread.InvokeAsync(() => _allSongs.Add(song)), s => Dispatcher.UIThread.InvokeAsync(() => StatusBarText = s)); });
                await Dispatcher.UIThread.InvokeAsync(() => {
                    Artists.Clear(); var uniqueArtistNames = _allSongs.Select(s => s.Artist).Where(a => !string.IsNullOrWhiteSpace(a)).Distinct(StringComparer.OrdinalIgnoreCase).OrderBy(a => a, StringComparer.OrdinalIgnoreCase).ToList();
                    Bitmap? defaultThumb = _musicLibraryService.GetDefaultThumbnail(); foreach (var artistName in uniqueArtistNames!) { Bitmap? repThumb = _allSongs.FirstOrDefault(s => (s.Artist?.Equals(artistName, StringComparison.OrdinalIgnoreCase) ?? false) && s.Thumbnail != null)?.Thumbnail ?? defaultThumb; Artists.Add(new ArtistViewModel { Name = artistName, Thumbnail = repThumb }); }
                    OnPropertyChanged(nameof(Artists));
                    Albums.Clear(); Func<Song, (string Album, string Artist)> keySelector = s => (s.Album?.Trim() ?? string.Empty, s.Artist?.Trim() ?? string.Empty);
                    var uniqueAlbums = _allSongs.Where(s => !string.IsNullOrWhiteSpace(s.Album) && !string.IsNullOrWhiteSpace(s.Artist)).GroupBy(keySelector, AlbumArtistTupleComparer.Instance)
                        .Select(g => new { AlbumTitle = g.First().Album, ArtistName = g.First().Artist, ThumbSong = g.FirstOrDefault(s => s.Thumbnail != null) })
                        .OrderBy(a => a.ArtistName, StringComparer.OrdinalIgnoreCase).ThenBy(a => a.AlbumTitle, StringComparer.OrdinalIgnoreCase).ToList();
                    foreach (var albumData in uniqueAlbums) Albums.Add(new AlbumViewModel { Title = albumData.AlbumTitle, Artist = albumData.ArtistName, Thumbnail = albumData.ThumbSong?.Thumbnail ?? defaultThumb }); OnPropertyChanged(nameof(Albums));
                    ApplyFilter(); // This populates FilteredSongs
                });
            }
            catch (Exception ex) { Debug.WriteLine($"[MainVM] Error loading library: {ex}"); await Dispatcher.UIThread.InvokeAsync(() => StatusBarText = "Error loading music library."); }
        }
        // This should be called after ApplyFilter to accurately reflect count.
        IsLoadingLibrary = false; UpdateStatusBarText(); // Update status after loading finishes.
    }

    private async Task OpenSettingsDialog(object? ownerWindow)
    {
        if (ownerWindow is not Window owner || IsLoadingLibrary) return; IsAdvancedPanelVisible = false; var currentSettingsBeforeDialog = _settingsService.LoadSettings();
        var settingsVM = new SettingsViewModel(_settingsService); var settingsDialog = new Sonorize.Views.SettingsWindow(CurrentTheme) { DataContext = settingsVM };
        await settingsDialog.ShowDialog(owner);
        if (settingsVM.SettingsChanged) // This flag is now more accurately set by SettingsViewModel
        {
            var newSettingsAfterDialog = _settingsService.LoadSettings(); // Re-load to get what was actually saved
            bool dirsActuallyChanged = !currentSettingsBeforeDialog.MusicDirectories.SequenceEqual(newSettingsAfterDialog.MusicDirectories);
            bool themeActuallyChanged = currentSettingsBeforeDialog.PreferredThemeFileName != newSettingsAfterDialog.PreferredThemeFileName;

            if (dirsActuallyChanged) { await LoadMusicLibrary(); }
            if (themeActuallyChanged) { StatusBarText = "Theme changed. Please restart Sonorize for the changes to take full effect."; }
        }
    }

    private async Task AddMusicDirectoryAndRefresh(object? ownerWindow)
    {
        if (ownerWindow is not Window owner || IsLoadingLibrary) return; IsAdvancedPanelVisible = false;
        var result = await owner.StorageProvider.OpenFolderPickerAsync(new FolderPickerOpenOptions { Title = "Select Music Directory", AllowMultiple = false });
        if (result != null && result.Count > 0)
        {
            string? folderPath = result[0].Path.LocalPath;
            if (string.IsNullOrEmpty(folderPath) && result[0].Path.IsAbsoluteUri) { try { folderPath = new Uri(result[0].Path.ToString()).LocalPath; } catch { folderPath = null; Debug.WriteLine($"[MainVM] Could not convert folder URI: {result[0].Path}"); } }
            if (!string.IsNullOrEmpty(folderPath))
            {
                var settings = _settingsService.LoadSettings(); if (!settings.MusicDirectories.Contains(folderPath)) { settings.MusicDirectories.Add(folderPath); _settingsService.SaveSettings(settings); await LoadMusicLibrary(); }
            }
            else { Debug.WriteLine($"[MainVM] Selected folder path could not be determined: {result[0].Name}"); }
        }
    }
}
</file>

<file path="Source\ViewModels\RelayCommand.cs">
using System;
using System.Windows.Input;

namespace Sonorize.ViewModels;

public class RelayCommand : ICommand
{
    private readonly Action<object?> _execute;
    private readonly Predicate<object?>? _canExecute;
    private EventHandler? _canExecuteChanged;

    public event EventHandler? CanExecuteChanged
    {
        add
        {
            // Note: Avalonia doesn't have a global CommandManager.RequerySuggested like WPF.
            // For simplicity, this basic RelayCommand requires manual raising of CanExecuteChanged
            // or relies on UI controls that re-evaluate CanExecute on interactions.
            // For more robust scenarios, integrate with a mechanism that allows VMs to signal changes.
            _canExecuteChanged += value;
        }
        remove
        {
            _canExecuteChanged -= value;
        }
    }

    public void RaiseCanExecuteChanged()
    {
        _canExecuteChanged?.Invoke(this, EventArgs.Empty);
    }

    public RelayCommand(Action<object?> execute, Predicate<object?>? canExecute = null)
    {
        _execute = execute ?? throw new ArgumentNullException(nameof(execute));
        _canExecute = canExecute;
    }

    public RelayCommand(Action execute, Func<bool>? canExecute = null)
        : this(o => execute(), canExecute == null ? (Predicate<object?>?)null : o => canExecute())
    {
    }


    public bool CanExecute(object? parameter) => _canExecute == null || _canExecute(parameter);
    public void Execute(object? parameter) => _execute(parameter);
}
</file>

<file path="Source\ViewModels\SettingsViewModel.cs">
using Avalonia.Controls;
using Avalonia.Platform.Storage;
using Sonorize.Models;
using Sonorize.Services;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Diagnostics;
using System.Collections.Generic; // Required for List<string>

namespace Sonorize.ViewModels;

public class SettingsViewModel : ViewModelBase
{
    private readonly SettingsService _settingsService;
    private readonly ThemeService _themeService;

    public ObservableCollection<string> MusicDirectories { get; } = new();
    public List<string> InitialMusicDirectories { get; private set; } // To track changes

    private string? _selectedDirectory;
    public string? SelectedDirectory
    {
        get => _selectedDirectory;
        set => SetProperty(ref _selectedDirectory, value, nameof(CanRemoveDirectory));
    }

    public ObservableCollection<string> AvailableThemes { get; } = new();
    private string? _selectedThemeFile;
    public string? SelectedThemeFile
    {
        get => _selectedThemeFile;
        set
        {
            if (SetProperty(ref _selectedThemeFile, value))
            {
                SettingsChanged = true;
            }
        }
    }

    // This flag indicates if any setting that requires action (like reload or restart) has changed.
    public bool SettingsChanged { get; private set; } = false;

    public ICommand AddDirectoryCommand { get; }
    public ICommand RemoveDirectoryCommand { get; }
    public ICommand SaveAndCloseCommand { get; }

    public bool CanRemoveDirectory => SelectedDirectory != null;

    public SettingsViewModel(SettingsService settingsService)
    {
        _settingsService = settingsService;
        _themeService = new ThemeService(null); // Create a temporary instance to list files

        var settings = _settingsService.LoadSettings();
        InitialMusicDirectories = new List<string>(settings.MusicDirectories); // Store initial state

        foreach (var dir in settings.MusicDirectories)
        {
            MusicDirectories.Add(dir);
        }

        foreach (var themeFile in _themeService.GetAvailableThemeFiles())
        {
            AvailableThemes.Add(themeFile);
        }

        SelectedThemeFile = settings.PreferredThemeFileName ?? ThemeService.DefaultThemeFileName;
        if (!AvailableThemes.Contains(SelectedThemeFile) && AvailableThemes.Any())
        {
            SelectedThemeFile = AvailableThemes.First(); // Fallback if saved theme not found
        }

        // Reset SettingsChanged after initial load, as SelectedThemeFile property set might trigger it
        SettingsChanged = false;

        AddDirectoryCommand = new RelayCommand(async owner => await AddDirectory(owner as Window));
        RemoveDirectoryCommand = new RelayCommand(RemoveSelectedDirectory, _ => CanRemoveDirectory);
        SaveAndCloseCommand = new RelayCommand(SaveSettings);

        PropertyChanged += (s, e) => {
            if (e.PropertyName == nameof(SelectedDirectory))
            {
                (RemoveDirectoryCommand as RelayCommand)?.RaiseCanExecuteChanged();
            }
        };
        // Any change to MusicDirectories collection or SelectedThemeFile marks settings as changed.
        MusicDirectories.CollectionChanged += (s, e) => SettingsChanged = true;
    }

    private async Task AddDirectory(Window? owner)
    {
        if (owner == null) return;
        var dialog = new OpenFolderDialog() { Title = "Select Music Directory" };
        var result = await dialog.ShowAsync(owner);
        if (result != null && !string.IsNullOrEmpty(result))
        {
            if (!MusicDirectories.Contains(result))
            {
                MusicDirectories.Add(result);
                // SettingsChanged will be set by the CollectionChanged event handler
            }
        }
    }

    private void RemoveSelectedDirectory(object? parameter)
    {
        if (SelectedDirectory != null)
        {
            MusicDirectories.Remove(SelectedDirectory);
            SelectedDirectory = null;
            // SettingsChanged will be set by the CollectionChanged event handler
        }
    }

    private void SaveSettings(object? parameter)
    {
        var currentSettings = _settingsService.LoadSettings(); // Load current to preserve other settings if any

        // Check if directories actually changed before saving and marking
        bool dirsActuallyChanged = !InitialMusicDirectories.SequenceEqual(MusicDirectories);
        bool themeActuallyChanged = currentSettings.PreferredThemeFileName != SelectedThemeFile;

        if (dirsActuallyChanged)
        {
            currentSettings.MusicDirectories = MusicDirectories.ToList();
            Debug.WriteLine($"[SettingsVM] Saved directories count: {currentSettings.MusicDirectories.Count}");
        }

        if (themeActuallyChanged)
        {
            currentSettings.PreferredThemeFileName = SelectedThemeFile;
            Debug.WriteLine($"[SettingsVM] Saved theme: {SelectedThemeFile}");
        }

        if (dirsActuallyChanged || themeActuallyChanged)
        {
            _settingsService.SaveSettings(currentSettings);
            SettingsChanged = true; // Ensure this is true if anything was actually saved
                                    // Update InitialMusicDirectories to reflect the saved state for subsequent checks if dialog is reopened
            if (dirsActuallyChanged) InitialMusicDirectories = new List<string>(currentSettings.MusicDirectories);
        }
        else
        {
            SettingsChanged = false; // No actual changes were made that need saving.
        }
    }
}
</file>

<file path="Source\ViewModels\ViewModelBase.cs">
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace Sonorize.ViewModels;

public class ViewModelBase : INotifyPropertyChanged
{
    public event PropertyChangedEventHandler? PropertyChanged;

    protected bool SetProperty<T>(ref T field, T value, [CallerMemberName] string? propertyName = null)
    {
        if (EqualityComparer<T>.Default.Equals(field, value)) return false;
        field = value;
        OnPropertyChanged(propertyName);
        return true;
    }

    protected void OnPropertyChanged([CallerMemberName] string? propertyName = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
</file>

<file path="Source\Views\MainWindow.axaml.cs">
using System;
using Avalonia.Controls;
using Avalonia.Media;
using Sonorize.Models;
using Sonorize.ViewModels;
using Sonorize.Controls; // Required for WaveformDisplayControl
using Avalonia.Data.Converters; // Required for IValueConverter (if defined here)
using Avalonia.Interactivity; // Required for RoutedEventArgs
using System.Globalization;
using Sonorize.Services; // Required for CultureInfo

namespace Sonorize.Views
{
    public partial class MainWindow : Window // Ensure 'partial' keyword
    {
        private readonly ThemeColors _theme;

        public MainWindow() // Parameterless constructor for XAML
        {
            InitializeComponent();
            // _theme might not be available here if not passed.
            // If default theme values are needed before DataContext is set, handle appropriately.
            // For this example, we assume ThemeColors comes from DataContext or is passed.
        }

        public MainWindow(ThemeColors theme)
        {
            _theme = theme;
            InitializeComponent();

            var waveformDisplay = this.FindControl<WaveformDisplayControl>("WaveformDisplay");
            if (waveformDisplay != null)
            {
                if (_theme.B_AccentColor is ISolidColorBrush accentBrush)
                {
                    waveformDisplay.LoopRegionBrush = new SolidColorBrush(accentBrush.Color, 0.3);
                }
                else
                {
                    // Fallback if B_AccentColor is not a SolidColorBrush, though your model implies it is.
                    waveformDisplay.LoopRegionBrush = new SolidColorBrush(Colors.Orange, 0.3);
                }
            }
        }

        private void MainPlayPauseButton_Click(object? sender, RoutedEventArgs e)
        {
            if (DataContext is MainWindowViewModel vm)
            {
                if (vm.PlaybackService.CurrentPlaybackStatus == PlaybackStateStatus.Playing)
                    vm.PlaybackService.Pause();
                else
                    vm.PlaybackService.Resume(); // Resume will handle playing from stopped or paused
            }
        }

        private void WaveformDisplay_SeekRequested(object? sender, TimeSpan time)
        {
            if (DataContext is MainWindowViewModel vm)
            {
                vm.WaveformSeekCommand.Execute(time);
            }
        }
    }

    // Converters are better placed in their own files or a shared Converters namespace/file,
    // but kept here for direct translation from your original structure.
    // If they are already in separate files (as they seem to be, based on your MainView.cs),
    // you don't need to redefine them here. The XAML will use xmlns to find them.

    public class BooleanToPlayPauseTextConverter : IValueConverter
    {
        public static readonly BooleanToPlayPauseTextConverter Instance = new();

        public object Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
        {
            if (value is bool isPlaying) return isPlaying ? "Pause" : "Play";
            return "Play";
        }
        public object ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
            => throw new NotSupportedException();
    }

    public class NotNullToBooleanConverter : IValueConverter
    {
        public static readonly NotNullToBooleanConverter Instance = new();

        public object Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
        {
            return value != null;
        }

        public object ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
        {
            throw new NotSupportedException();
        }
    }
}
</file>

<file path="Source\Views\SettingsWindow.axaml.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Markup.Xaml; // Required for AvaloniaXamlLoader or InitializeComponent
using Avalonia.Interactivity; // Required for RoutedEventArgs
using Sonorize.Models;
using Sonorize.ViewModels;

namespace Sonorize.Views
{
    public partial class SettingsWindow : Window // Add 'partial' keyword
    {
        // The ThemeColors field is not directly used in the constructor if
        // all theme bindings are handled by the DataContext (ViewModel) in XAML.
        // However, the constructor that takes ThemeColors is called from MainWindowViewModel.
        // We need one constructor for XAML previewer and one for runtime.
        private readonly ThemeColors? _theme;

        // Parameterless constructor for XAML previewer and instantiation if DataContext is set later
        public SettingsWindow()
        {
            InitializeComponent();
        }

        // Constructor used by your MainWindowViewModel
        public SettingsWindow(ThemeColors currentDisplayTheme)
        {
            _theme = currentDisplayTheme; // Store it if needed for specific logic not handled by bindings
            InitializeComponent();

            // If you were setting styles programmatically based on _theme, you'd do it here.
            // For instance, if Background wasn't bound in XAML:
            // this.Background = _theme.B_SlightlyLighterBackground;
            // However, with the XAML bindings, this is often not necessary for simple properties.
        }

        private void SaveButton_Click(object? sender, RoutedEventArgs e)
        {
            if (DataContext is SettingsViewModel vm)
            {
                vm.SaveAndCloseCommand.Execute(null);
            }
            Close();
        }

        private void CancelButton_Click(object? sender, RoutedEventArgs e)
        {
            Close();
        }
    }
}
</file>

